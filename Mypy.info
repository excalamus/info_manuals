This is Mypy.info, produced by makeinfo version 6.7 from Mypy.texi.

     mypy 0.990+dev.f85dfa1b2533621094bc45b4263ea41fd3bc2e39, Oct 01,
     2022

     Jukka

     Copyright © 2012-2022 Jukka Lehtosalo and mypy contributors

INFO-DIR-SECTION Miscellaneous
START-INFO-DIR-ENTRY
* Mypy: (Mypy.info). One line description of project.
END-INFO-DIR-ENTRY


   Generated by Sphinx 5.1.1.


File: Mypy.info,  Node: Top,  Next: Contents,  Up: (dir)

Mypy Documentation
******************

     mypy 0.990+dev.f85dfa1b2533621094bc45b4263ea41fd3bc2e39, Oct 01,
     2022

     Jukka

     Copyright © 2012-2022 Jukka Lehtosalo and mypy contributors

Mypy is a static type checker for Python.

Type checkers help ensure that you’re using variables and functions in
your code correctly.  With mypy, add type hints ( PEP 484(1)) to your
Python programs, and mypy will warn you when you use those types
incorrectly.

Python is a dynamic language, so usually you’ll only see errors in your
code when you attempt to run it.  Mypy is a ‘static’ checker, so it
finds bugs in your programs without even running them!

Here is a small example to whet your appetite:

     number = input("What is your favourite number?")
     print("It is", number + 1)  # error: Unsupported operand types for + ("str" and "int")

Adding type hints for mypy does not interfere with the way your program
would otherwise run.  Think of type hints as similar to comments!  You
can always use the Python interpreter to run your code, even if mypy
reports errors.

Mypy is designed with gradual typing in mind.  This means you can add
type hints to your code base slowly and that you can always fall back to
dynamic typing when static typing is not convenient.

Mypy has a powerful and easy-to-use type system, supporting features
such as type inference, generics, callable types, tuple types, union
types, structural subtyping and more.  Using mypy will make your
programs easier to understand, debug, and maintain.

     Note: Mypy is used in production by many companies and projects,
     but mypy is officially beta software.  There will be occasional
     changes that break backward compatibility.  The mypy development
     team tries to minimize the impact of changes to user code.

* Menu:

* Contents::
* Indices and tables::
* Index::

 — The Detailed Node Listing —

Contents

* Getting started::
* Using mypy with an existing codebase::
* Type hints cheat sheet::
* Built-in types::
* Type inference and type annotations::
* Kinds of types::
* Class basics::
* Annotation issues at runtime::
* Protocols and structural subtyping::
* Dynamically typed code::
* Type narrowing::
* Duck type compatibility::
* Stub files::
* Generics::
* More types::
* Literal types and Enums::
* Final names, methods and classes: Final names methods and classes.
* Metaclasses::
* Running mypy and managing imports::
* The mypy command line::
* The mypy configuration file::
* Inline configuration::
* Mypy daemon (mypy server): Mypy daemon mypy server.
* Using installed packages::
* Extending and integrating mypy::
* Automatic stub generation (stubgen): Automatic stub generation stubgen.
* Automatic stub testing (stubtest): Automatic stub testing stubtest.
* Common issues and solutions::
* Supported Python features::
* Error codes::
* Error codes enabled by default::
* Error codes for optional checks::
* Additional features::
* Frequently Asked Questions::

Getting started

* Installing and running mypy::
* Function signatures and dynamic vs static typing::
* More function signatures::
* Additional types, and the typing module: Additional types and the typing module.
* Local type inference::
* Types and classes::
* Stubs files and typeshed::
* Configuring mypy::
* Next steps::

Using mypy with an existing codebase

* Start small::
* Run mypy consistently and prevent regressions::
* Ignoring errors from certain modules::
* Fixing errors related to imports::
* Prioritise annotating widely imported modules::
* Write annotations as you go::
* Automate annotation of legacy code::
* Introduce stricter options::
* Speed up mypy runs::

Type hints cheat sheet

* Variables::
* Useful built-in types::
* Functions::
* When you’re puzzled or when things are complicated::
* Standard “duck types”::
* Classes::
* Coroutines and asyncio::
* Miscellaneous::
* Decorators::

Built-in types

* Simple types::
* Any type::
* Generic types::

Type inference and type annotations

* Type inference::
* Explicit types for variables::
* Explicit types for collections::
* Compatibility of container types::
* Context in type inference::
* Silencing type errors::

Kinds of types

* Class types::
* The Any type::
* Tuple types::
* Callable types (and lambdas): Callable types and lambdas.
* Union types::
* Optional types and the None type::
* Disabling strict optional checking::
* Type aliases::
* Named tuples::
* The type of class objects::
* Generators::

Optional types and the None type

* X | Y syntax for Unions::

Class basics

* Instance and class attributes::
* Annotating __init__ methods::
* Class attribute annotations::
* Overriding statically typed methods::
* Abstract base classes and multiple inheritance::
* Slots::

Annotation issues at runtime

* String literal types and type comments::
* Future annotations import (PEP 563): Future annotations import PEP 563.
* typing.TYPE_CHECKING: typing TYPE_CHECKING.
* Class name forward references::
* Import cycles::
* Using classes that are generic in stubs but not at runtime::
* Using types defined in stubs but not at runtime::
* Using generic builtins::
* Using X | Y syntax for Unions::
* Using new additions to the typing module::

Protocols and structural subtyping

* Predefined protocols::
* Simple user-defined protocols::
* Defining subprotocols and subclassing protocols::
* Recursive protocols::
* Using isinstance() with protocols: Using isinstance with protocols.
* Callback protocols::
* Predefined protocol reference::

Predefined protocol reference

* Iteration protocols::
* Collection protocols::
* One-off protocols::
* Async protocols::
* Context manager protocols::

Iteration protocols

* Iterable[T]::
* Iterator[T]::

Collection protocols

* Sized::
* Container[T]::
* Collection[T]::

One-off protocols

* Reversible[T]::
* SupportsAbs[T]::
* SupportsBytes::
* SupportsComplex::
* SupportsFloat::
* SupportsInt::
* SupportsRound[T]::

Async protocols

* Awaitable[T]::
* AsyncIterable[T]::
* AsyncIterator[T]::

Context manager protocols

* ContextManager[T]::
* AsyncContextManager[T]::

Dynamically typed code

* Operations on Any values::
* Any vs. object: Any vs object.

Type narrowing

* Type narrowing expressions::
* Casts::
* User-Defined Type Guards::

Type narrowing expressions

* issubclass::
* callable::

User-Defined Type Guards

* Generic TypeGuards::
* Typeguards with parameters::
* TypeGuards as methods::
* Assignment expressions as TypeGuards::

Stub files

* Creating a stub::
* Stub file syntax::
* Using stub file syntax at runtime::

Generics

* Defining generic classes::
* Generic class internals::
* Defining sub-classes of generic classes::
* Generic functions::
* Generic methods and generic self::
* Variance of generic types::
* Type variables with value restriction::
* Type variables with upper bounds::
* Declaring decorators::
* Generic protocols::
* Generic type aliases::

Declaring decorators

* Decorator factories::

More types

* The NoReturn type::
* NewTypes::
* Function overloading::
* Advanced uses of self-types::
* Typing async/await::
* TypedDict::

Function overloading

* Runtime behavior::
* Type checking calls to overloads::
* Type checking the variants::
* Type checking the implementation::
* Conditional overloads::

Advanced uses of self-types

* Restricted methods in generic classes::
* Mixin classes::
* Precise typing of alternative constructors::

TypedDict

* Totality::
* Supported operations::
* Class-based syntax::
* Mixing required and non-required items::
* Unions of TypedDicts::

Literal types and Enums

* Literal types::
* Enums::

Literal types

* Parameterizing Literals::
* Declaring literal variables::
* Intelligent indexing::
* Tagged unions::
* Exhaustiveness checking::
* Limitations::

Enums

* Exhaustiveness checking: Exhaustiveness checking<2>.
* Extra Enum checks::

Final names, methods and classes

* Final names::
* Final methods::
* Final classes::

Final names

* Syntax variants::
* Details of using Final::

Metaclasses

* Defining a metaclass::
* Metaclass usage example::
* Gotchas and limitations of metaclass support::

Running mypy and managing imports

* Specifying code to be checked::
* Reading a list of files from a file::
* Mapping file paths to modules::
* How mypy handles imports::
* Missing imports::
* How imports are found::
* Following imports::

Missing imports

* Missing library stubs or py.typed marker: Missing library stubs or py typed marker.
* Library stubs not installed::
* Cannot find implementation or library stub::

The mypy command line

* Specifying what to type check::
* Optional arguments::
* Config file::
* Import discovery::
* Platform configuration::
* Disallow dynamic typing::
* Untyped definitions and calls::
* None and Optional handling::
* Configuring warnings::
* Miscellaneous strictness flags::
* Configuring error messages::
* Incremental mode::
* Advanced options::
* Report generation::
* Miscellaneous: Miscellaneous<2>.

The mypy configuration file

* Config file format::
* Per-module and global options::
* Inverting option values::
* Examples::
* Import discovery: Import discovery<2>.
* Platform configuration: Platform configuration<2>.
* Disallow dynamic typing: Disallow dynamic typing<2>.
* Untyped definitions and calls: Untyped definitions and calls<2>.
* None and Optional handling: None and Optional handling<2>.
* Configuring warnings: Configuring warnings<2>.
* Suppressing errors::
* Miscellaneous strictness flags: Miscellaneous strictness flags<2>.
* Configuring error messages: Configuring error messages<2>.
* Incremental mode: Incremental mode<2>.
* Advanced options: Advanced options<2>.
* Report generation: Report generation<2>.
* Miscellaneous: Miscellaneous<3>.
* Using a pyproject.toml file: Using a pyproject toml file.
* Example pyproject.toml: Example pyproject toml.

Inline configuration

* Configuration comment format::

Mypy daemon (mypy server)

* Basic usage::
* Daemon client commands::
* Additional daemon flags::
* Static inference of annotations::
* Statically inspect expressions::

Using installed packages

* Using installed packages with mypy (PEP 561): Using installed packages with mypy PEP 561.
* Creating PEP 561 compatible packages::

Extending and integrating mypy

* Integrating mypy into another Python application::
* Extending mypy using plugins::
* Configuring mypy to use plugins::
* High-level overview::
* Current list of plugin hooks::
* Notes about the semantic analyzer::

Automatic stub generation (stubgen)

* Specifying what to stub::
* Specifying how to generate stubs::
* Additional flags::

Automatic stub testing (stubtest)

* What stubtest does and does not do::
* Example::
* Usage::

Common issues and solutions

* Can’t install mypy using pip::
* No errors reported for obviously wrong code::
* Spurious errors and locally silencing the checker::
* Ignoring a whole file::
* Issues with code at runtime::
* Mypy runs are slow::
* Types of empty collections::
* Redefinitions with incompatible types::
* Invariance vs covariance::
* Declaring a supertype as variable type::
* Complex type tests::
* Python version and system platform checks::
* Displaying the type of an expression::
* Silencing linters::
* Covariant subtyping of mutable protocol members is rejected::
* Dealing with conflicting names::
* Using a development mypy build::
* Variables vs type aliases::
* Incompatible overrides::
* Unreachable code::
* Narrowing and inner functions::

Supported Python features

* Runtime definition of methods and functions::

Error codes

* Displaying error codes::
* Silencing errors based on error codes::
* Enabling specific error codes::
* Per-module enabling/disabling error codes::

Error codes enabled by default

* Check that attribute exists [attr-defined]::
* Check that attribute exists in each union item [union-attr]::
* Check that name is defined [name-defined]::
* Check arguments in calls [call-arg]::
* Check argument types [arg-type]::
* Check calls to overloaded functions [call-overload]::
* Check validity of types [valid-type]::
* Require annotation if variable type is unclear [var-annotated]::
* Check validity of overrides [override]::
* Check that function returns a value [return]::
* Check that return value is compatible [return-value]::
* Check types in assignment statement [assignment]::
* Check type variable values [type-var]::
* Check uses of various operators [operator]::
* Check indexing operations [index]::
* Check list items [list-item]::
* Check dict items [dict-item]::
* Check TypedDict items [typeddict-item]::
* Check that type of target is known [has-type]::
* Check that import target can be found [import]::
* Check that each name is defined once [no-redef]::
* Check that called function returns a value [func-returns-value]::
* Check instantiation of abstract classes [abstract]::
* Safe handling of abstract type object types [type-abstract]::
* Check that call to an abstract method via super is valid [safe-super]::
* Check the target of NewType [valid-newtype]::
* Check the return type of __exit__ [exit-return]::
* Check that naming is consistent [name-match]::
* Check that overloaded functions have an implementation [no-overload-impl]::
* Check that coroutine return value is used [unused-coroutine]::
* Check types in assert_type [assert-type]::
* Report syntax errors [syntax]::
* Miscellaneous checks [misc]::

Error codes for optional checks

* Check that type arguments exist [type-arg]::
* Check that every function has an annotation [no-untyped-def]::
* Check that cast is not redundant [redundant-cast]::
* Check that comparisons are overlapping [comparison-overlap]::
* Check that no untyped functions are called [no-untyped-call]::
* Check that function does not return Any value [no-any-return]::
* Check that types have no Any components due to missing imports [no-any-unimported]::
* Check that statement or expression is unreachable [unreachable]::
* Check that expression is redundant [redundant-expr]::
* Check that expression is not implicitly true in boolean context [truthy-bool]::
* Check that # type; ignore include an error code [ignore-without-code]: Check that # type ignore include an error code [ignore-without-code].
* Check that awaitable return value is used [unused-awaitable]::

Additional features

* Dataclasses::
* The attrs package::
* Using a remote cache to speed up mypy runs::
* Extended Callable types::

Dataclasses

* Caveats/Known Issues::

The attrs package

* Caveats/Known Issues: Caveats/Known Issues<2>.

Using a remote cache to speed up mypy runs

* Shared repository for cache files::
* Continuous Integration build::
* Mypy wrapper script::
* Caching with mypy daemon::
* Refinements::

Frequently Asked Questions

* Why have both dynamic and static typing?::
* Would my project benefit from static typing?::
* Can I use mypy to type check my existing Python code?::
* Will static typing make my programs run faster?::
* Is mypy free?::
* Can I use duck typing with mypy?::
* I like Python and I have no need for static typing::
* How are mypy programs different from normal Python?::
* How is mypy different from Cython?::
* Does it run on PyPy?::
* Mypy is a cool project. Can I help?: Mypy is a cool project Can I help?.


   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/


File: Mypy.info,  Node: Contents,  Next: Indices and tables,  Prev: Top,  Up: Top

1 Contents
**********

* Menu:

* Getting started::
* Using mypy with an existing codebase::
* Type hints cheat sheet::
* Built-in types::
* Type inference and type annotations::
* Kinds of types::
* Class basics::
* Annotation issues at runtime::
* Protocols and structural subtyping::
* Dynamically typed code::
* Type narrowing::
* Duck type compatibility::
* Stub files::
* Generics::
* More types::
* Literal types and Enums::
* Final names, methods and classes: Final names methods and classes.
* Metaclasses::
* Running mypy and managing imports::
* The mypy command line::
* The mypy configuration file::
* Inline configuration::
* Mypy daemon (mypy server): Mypy daemon mypy server.
* Using installed packages::
* Extending and integrating mypy::
* Automatic stub generation (stubgen): Automatic stub generation stubgen.
* Automatic stub testing (stubtest): Automatic stub testing stubtest.
* Common issues and solutions::
* Supported Python features::
* Error codes::
* Error codes enabled by default::
* Error codes for optional checks::
* Additional features::
* Frequently Asked Questions::


File: Mypy.info,  Node: Getting started,  Next: Using mypy with an existing codebase,  Up: Contents

1.1 Getting started
===================

This chapter introduces some core concepts of mypy, including function
annotations, the typing(1) module, stub files, and more.

If you’re looking for a quick intro, see the *note mypy cheatsheet: 6.

If you’re unfamiliar with the concepts of static and dynamic type
checking, be sure to read this chapter carefully, as the rest of the
documentation may not make much sense otherwise.

* Menu:

* Installing and running mypy::
* Function signatures and dynamic vs static typing::
* More function signatures::
* Additional types, and the typing module: Additional types and the typing module.
* Local type inference::
* Types and classes::
* Stubs files and typeshed::
* Configuring mypy::
* Next steps::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Installing and running mypy,  Next: Function signatures and dynamic vs static typing,  Up: Getting started

1.1.1 Installing and running mypy
---------------------------------

Mypy requires Python 3.7 or later to run.  You can install mypy using
pip:

     $ python3 -m pip install mypy

Once mypy is installed, run it by using the ‘mypy’ tool:

     $ mypy program.py

This command makes mypy ‘type check’ your ‘program.py’ file and print
out any errors it finds.  Mypy will type check your code ‘statically’:
this means that it will check for errors without ever running your code,
just like a linter.

This also means that you are always free to ignore the errors mypy
reports, if you so wish.  You can always use the Python interpreter to
run your code, even if mypy reports errors.

However, if you try directly running mypy on your existing Python code,
it will most likely report little to no errors.  This is a feature!  It
makes it easy to adopt mypy incrementally.

In order to get useful diagnostics from mypy, you must add ‘type
annotations’ to your code.  See the section below for details.


File: Mypy.info,  Node: Function signatures and dynamic vs static typing,  Next: More function signatures,  Prev: Installing and running mypy,  Up: Getting started

1.1.2 Function signatures and dynamic vs static typing
------------------------------------------------------

A function without type annotations is considered to be ‘dynamically
typed’ by mypy:

     def greeting(name):
         return 'Hello ' + name

By default, mypy will ‘not’ type check dynamically typed functions.
This means that with a few exceptions, mypy will not report any errors
with regular unannotated Python.

This is the case even if you misuse the function: for example, mypy
would currently not report any errors if you tried running ‘greeting(3)’
or ‘greeting(b"Alice")’ even though those function calls would result in
errors at runtime.

You can teach mypy to detect these kinds of bugs by adding ‘type
annotations’ (also known as ‘type hints’).  For example, you can teach
mypy that ‘greeting’ both accepts and returns a string like so:

     def greeting(name: str) -> str:
         return 'Hello ' + name

This function is now ‘statically typed’: mypy can use the provided type
hints to detect incorrect usages of the ‘greeting’ function.  For
example, it will reject the following calls since the arguments have
invalid types:

     def greeting(name: str) -> str:
         return 'Hello ' + name

     greeting(3)         # Argument 1 to "greeting" has incompatible type "int"; expected "str"
     greeting(b'Alice')  # Argument 1 to "greeting" has incompatible type "bytes"; expected "str"

Being able to pick whether you want a function to be dynamically or
statically typed can be very helpful.  For example, if you are migrating
an existing Python codebase to use static types, it’s usually easier to
migrate by incrementally adding type hints to your code rather than
adding them all at once.  Similarly, when you are prototyping a new
feature, it may be convenient to initially implement the code using
dynamic typing and only add type hints later once the code is more
stable.

Once you are finished migrating or prototyping your code, you can make
mypy warn you if you add a dynamic function by mistake by using the
*note –disallow-untyped-defs: 9. flag.  See *note The mypy command line:
a. for more information on configuring mypy.


File: Mypy.info,  Node: More function signatures,  Next: Additional types and the typing module,  Prev: Function signatures and dynamic vs static typing,  Up: Getting started

1.1.3 More function signatures
------------------------------

Here are a few more examples of adding type hints to function
signatures.

If a function does not explicitly return a value, give it a return type
of ‘None’.  Using a ‘None’ result in a statically typed context results
in a type check error:

     def p() -> None:
         print('hello')

     a = p()  # Error: "p" does not return a value

Make sure to remember to include ‘None’: if you don’t, the function will
be dynamically typed.  For example:

     def f():
         1 + 'x'  # No static type error (dynamically typed)

     def g() -> None:
         1 + 'x'  # Type check error (statically typed)

Arguments with default values can be annotated like so:

     def greeting(name: str, excited: bool = False) -> str:
         message = f'Hello, {name}'
         if excited:
             message += '!!!'
         return message

‘*args’ and ‘**kwargs’ arguments can be annotated like so:

     def stars(*args: int, **kwargs: float) -> None:
         # 'args' has type 'tuple[int, ...]' (a tuple of ints)
         # 'kwargs' has type 'dict[str, float]' (a dict of strs to floats)
         for arg in args:
             print(arg)
         for key, value in kwargs.items():
             print(key, value)


File: Mypy.info,  Node: Additional types and the typing module,  Next: Local type inference,  Prev: More function signatures,  Up: Getting started

1.1.4 Additional types, and the typing module
---------------------------------------------

So far, we’ve added type hints that use only basic concrete types like
‘str’ and ‘float’.  What if we want to express more complex types, such
as “a list of strings” or “an iterable of ints”?

For example, to indicate that some function can accept a list of
strings, use the ‘list[str]’ type (Python 3.9 and later):

     def greet_all(names: list[str]) -> None:
         for name in names:
             print('Hello ' + name)

     names = ["Alice", "Bob", "Charlie"]
     ages = [10, 20, 30]

     greet_all(names)   # Ok!
     greet_all(ages)    # Error due to incompatible types

The list(1) type is an example of something called a ‘generic type’: it
can accept one or more ‘type parameters’.  In this case, we
‘parameterized’ list(2) by writing ‘list[str]’.  This lets mypy know
that ‘greet_all’ accepts specifically lists containing strings, and not
lists containing ints or any other type.

In Python 3.8 and earlier, you can instead import the List(3) type from
the typing(4) module:

     from typing import List  # Python 3.8 and earlier

     def greet_all(names: List[str]) -> None:
         for name in names:
             print('Hello ' + name)

     ...

You can find many of these more complex static types in the typing(5)
module.

In the above examples, the type signature is perhaps a little too rigid.
After all, there’s no reason why this function must accept
‘specifically’ a list – it would run just fine if you were to pass in a
tuple, a set, or any other custom iterable.

You can express this idea using the collections.abc.Iterable(6) (or
typing.Iterable(7) in Python 3.8 and earlier) type instead of list(8) :

     from collections.abc import Iterable  # or "from typing import Iterable"

     def greet_all(names: Iterable[str]) -> None:
         for name in names:
             print('Hello ' + name)

As another example, suppose you want to write a function that can accept
‘either’ ints or strings, but no other types.  You can express this
using the Union(9) type:

     from typing import Union

     def normalize_id(user_id: Union[int, str]) -> str:
         if isinstance(user_id, int):
             return f'user-{100_000 + user_id}'
         else:
             return user_id

Similarly, suppose that you want the function to accept only strings or
‘None’.  You can again use Union(10) and use ‘Union[str, None]’ – or
alternatively, use the type ‘Optional[str]’.  These two types are
identical and interchangeable: ‘Optional[str]’ is just a shorthand or
‘alias’ for ‘Union[str, None]’.  It exists mostly as a convenience to
help function signatures look a little cleaner:

     from typing import Optional

     def greeting(name: Optional[str] = None) -> str:
         # Optional[str] means the same thing as Union[str, None]
         if name is None:
             name = 'stranger'
         return 'Hello, ' + name

The typing(11) module contains many other useful types.  You can find a
quick overview by looking through the *note mypy cheatsheet: 6. and a
more detailed overview (including information on how to make your own
generic types or your own type aliases) by looking through the *note
type system reference: d.

     Note: When adding types, the convention is to import types using
     the form ‘from typing import Union’ (as opposed to doing just
     ‘import typing’ or ‘import typing as t’ or ‘from typing import *’).

     For brevity, we often omit imports from typing(12) or
     collections.abc(13) in code examples, but mypy will give an error
     if you use types such as Iterable(14) without first importing them.

     Note: In some examples we use capitalized variants of types, such
     as ‘List’, and sometimes we use plain ‘list’.  They are equivalent,
     but the prior variant is needed if you are using Python 3.8 or
     earlier.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#list

   (2) https://docs.python.org/3/library/stdtypes.html#list

   (3) https://docs.python.org/3/library/typing.html#typing.List

   (4) https://docs.python.org/3/library/typing.html#module-typing

   (5) https://docs.python.org/3/library/typing.html#module-typing

   (6) 
https://docs.python.org/3/library/collections.abc.html#collections.abc.Iterable

   (7) https://docs.python.org/3/library/typing.html#typing.Iterable

   (8) https://docs.python.org/3/library/stdtypes.html#list

   (9) https://docs.python.org/3/library/typing.html#typing.Union

   (10) https://docs.python.org/3/library/typing.html#typing.Union

   (11) https://docs.python.org/3/library/typing.html#module-typing

   (12) https://docs.python.org/3/library/typing.html#module-typing

   (13) 
https://docs.python.org/3/library/collections.abc.html#module-collections.abc

   (14) https://docs.python.org/3/library/typing.html#typing.Iterable


File: Mypy.info,  Node: Local type inference,  Next: Types and classes,  Prev: Additional types and the typing module,  Up: Getting started

1.1.5 Local type inference
--------------------------

Once you have added type hints to a function (i.e.  made it statically
typed), mypy will automatically type check that function’s body.  While
doing so, mypy will try and ‘infer’ as many details as possible.

We saw an example of this in the ‘normalize_id’ function above – mypy
understands basic isinstance(1) checks and so can infer that the
‘user_id’ variable was of type ‘int’ in the if-branch and of type ‘str’
in the else-branch.  Similarly, mypy was able to understand that ‘name’
could not possibly be ‘None’ in the ‘greeting’ function above, based
both on the ‘name is None’ check and the variable assignment in that if
statement.

As another example, consider the following function.  Mypy can type
check this function without a problem: it will use the available context
and deduce that ‘output’ must be of type ‘list[float]’ and that ‘num’
must be of type ‘float’:

     def nums_below(numbers: Iterable[float], limit: float) -> list[float]:
         output = []
         for num in numbers:
             if num < limit:
                 output.append(num)
         return output

Mypy will warn you if it is unable to determine the type of some
variable – for example, when assigning an empty dictionary to some
global value:

     my_global_dict = {}  # Error: Need type annotation for "my_global_dict"

You can teach mypy what type ‘my_global_dict’ is meant to have by giving
it a type hint.  For example, if you knew this variable is supposed to
be a dict of ints to floats, you could annotate it using either variable
annotations (introduced in Python 3.6 by PEP 526(2)) or using a
comment-based syntax like so:

     # If you're using Python 3.9+
     my_global_dict: dict[int, float] = {}

     # If you're using Python 3.6+
     my_global_dict: Dict[int, float] = {}

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance

   (2) https://peps.python.org/pep-0526/


File: Mypy.info,  Node: Types and classes,  Next: Stubs files and typeshed,  Prev: Local type inference,  Up: Getting started

1.1.6 Types and classes
-----------------------

So far, we’ve only seen examples of pre-existing types like the ‘int’ or
‘float’ builtins, or generic types from ‘collections.abc’ and ‘typing’,
such as ‘Iterable’.  However, these aren’t the only types you can use:
in fact, you can use any Python class as a type!

For example, suppose you’ve defined a custom class representing a bank
account:

     class BankAccount:
         # Note: It is ok to omit type hints for the "self" parameter.
         # Mypy will infer the correct type.

         def __init__(self, account_name: str, initial_balance: int = 0) -> None:
             # Note: Mypy will infer the correct types of your fields
             # based on the types of the parameters.
             self.account_name = account_name
             self.balance = initial_balance

         def deposit(self, amount: int) -> None:
             self.balance += amount

         def withdraw(self, amount: int) -> None:
             self.balance -= amount

         def overdrawn(self) -> bool:
             return self.balance < 0

You can declare that a function will accept any instance of your class
by simply annotating the parameters with ‘BankAccount’:

     def transfer(src: BankAccount, dst: BankAccount, amount: int) -> None:
         src.withdraw(amount)
         dst.deposit(amount)

     account_1 = BankAccount('Alice', 400)
     account_2 = BankAccount('Bob', 200)
     transfer(account_1, account_2, 50)

In fact, the ‘transfer’ function we wrote above can accept more then
just instances of ‘BankAccount’: it can also accept any instance of a
‘subclass’ of ‘BankAccount’.  For example, suppose you write a new class
that looks like this:

     class AuditedBankAccount(BankAccount):
         def __init__(self, account_name: str, initial_balance: int = 0) -> None:
             super().__init__(account_name, initial_balance)
             self.audit_log: list[str] = []

         def deposit(self, amount: int) -> None:
             self.audit_log.append(f"Deposited {amount}")
             self.balance += amount

         def withdraw(self, amount: int) -> None:
             self.audit_log.append(f"Withdrew {amount}")
             self.balance -= amount

Since ‘AuditedBankAccount’ is a subclass of ‘BankAccount’, we can
directly pass in instances of it into our ‘transfer’ function:

     audited = AuditedBankAccount('Charlie', 300)
     transfer(account_1, audited, 100)   # Type checks!

This behavior is actually a fundamental aspect of the PEP 484 type
system: when we annotate some variable with a type ‘T’, we are actually
telling mypy that variable can be assigned an instance of ‘T’, or an
instance of a ‘subclass’ of ‘T’.  The same rule applies to type hints on
parameters or fields.

See *note Class basics: 10. to learn more about how to work with code
involving classes.


File: Mypy.info,  Node: Stubs files and typeshed,  Next: Configuring mypy,  Prev: Types and classes,  Up: Getting started

1.1.7 Stubs files and typeshed
------------------------------

Mypy also understands how to work with classes found in the standard
library.  For example, here is a function which uses the ‘Path’ object
from the pathlib standard library module(1):

     from pathlib import Path

     def load_template(template_path: Path, name: str) -> str:
         # Mypy understands that 'file_path.read_text()' returns a str...
         template = template_path.read_text()

         # ...so understands this line type checks.
         return template.replace('USERNAME', name)

This behavior may surprise you if you’re familiar with how Python
internally works.  The standard library does not use type hints
anywhere, so how did mypy know that ‘Path.read_text()’ returns a ‘str’,
or that ‘str.replace(...)’ accepts exactly two ‘str’ arguments?

The answer is that mypy comes bundled with ‘stub files’ from the the
typeshed(2) project, which contains stub files for the Python builtins,
the standard library, and selected third-party packages.

A ‘stub file’ is a file containing a skeleton of the public interface of
that Python module, including classes, variables, functions – and most
importantly, their types.

Mypy complains if it can’t find a stub (or a real module) for a library
module that you import.  Some modules ship with stubs or inline
annotations that mypy can automatically find, or you can install
additional stubs using pip (see *note Missing imports: 13. and *note
Using installed packages: 14. for the details).  For example, you can
install the stubs for the ‘requests’ package like this:

     $ python3 -m pip install types-requests

The stubs are usually packaged in a distribution named
‘types-<distribution>’.  Note that the distribution name may be
different from the name of the package that you import.  For example,
‘types-PyYAML’ contains stubs for the ‘yaml’ package.  Mypy can often
suggest the name of the stub distribution:

     prog.py:1: error: Library stubs not installed for "yaml"
     prog.py:1: note: Hint: "python3 -m pip install types-PyYAML"
     ...

You can also *note create stubs: 15. easily.  We discuss strategies for
handling errors about missing stubs in *note Missing imports: 16.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/pathlib.html

   (2) https://github.com/python/typeshed


File: Mypy.info,  Node: Configuring mypy,  Next: Next steps,  Prev: Stubs files and typeshed,  Up: Getting started

1.1.8 Configuring mypy
----------------------

Mypy supports many command line options that you can use to tweak how
mypy behaves: see *note The mypy command line: a. for more details.

For example, suppose you want to make sure ‘all’ functions within your
codebase are using static typing and make mypy report an error if you
add a dynamically-typed function by mistake.  You can make mypy do this
by running mypy with the *note –disallow-untyped-defs: 9. flag.

Another potentially useful flag is *note –strict: 18, which enables many
(though not all) of the available strictness options – including *note
–disallow-untyped-defs: 9.

This flag is mostly useful if you’re starting a new project from scratch
and want to maintain a high degree of type safety from day one.
However, this flag will probably be too aggressive if you either plan on
using many untyped third party libraries or are trying to add static
types to a large, existing codebase.  See *note Using mypy with an
existing codebase: 19. for more suggestions on how to handle the latter
case.


File: Mypy.info,  Node: Next steps,  Prev: Configuring mypy,  Up: Getting started

1.1.9 Next steps
----------------

If you are in a hurry and don’t want to read lots of documentation
before getting started, here are some pointers to quick learning
resources:

   * Read the *note mypy cheatsheet: 6.

   * Read *note Using mypy with an existing codebase: 19. if you have a
     significant existing codebase without many type annotations.

   * Read the blog post(1) about the Zulip project’s experiences with
     adopting mypy.

   * If you prefer watching talks instead of reading, here are some
     ideas:

        * Carl Meyer: Type Checked Python in the Real World(2) (PyCon
          2018)

        * Greg Price: Clearer Code at Scale: Static Types at Zulip and
          Dropbox(3) (PyCon 2018)

   * Look at *note solutions to common issues: 1b. with mypy if you
     encounter problems.

   * You can ask questions about mypy in the mypy issue tracker(4) and
     typing Gitter chat(5).

You can also continue reading this document and skip sections that
aren’t relevant for you.  You don’t need to read sections in order.

   ---------- Footnotes ----------

   (1) https://blog.zulip.org/2016/10/13/static-types-in-python-oh-mypy/

   (2) https://www.youtube.com/watch?v=pMgmKJyWKn8

   (3) https://www.youtube.com/watch?v=0c46YHS3RY8

   (4) https://github.com/python/mypy/issues

   (5) https://gitter.im/python/typing


File: Mypy.info,  Node: Using mypy with an existing codebase,  Next: Type hints cheat sheet,  Prev: Getting started,  Up: Contents

1.2 Using mypy with an existing codebase
========================================

This section explains how to get started using mypy with an existing,
significant codebase that has little or no type annotations.  If you are
a beginner, you can skip this section.

* Menu:

* Start small::
* Run mypy consistently and prevent regressions::
* Ignoring errors from certain modules::
* Fixing errors related to imports::
* Prioritise annotating widely imported modules::
* Write annotations as you go::
* Automate annotation of legacy code::
* Introduce stricter options::
* Speed up mypy runs::


File: Mypy.info,  Node: Start small,  Next: Run mypy consistently and prevent regressions,  Up: Using mypy with an existing codebase

1.2.1 Start small
-----------------

If your codebase is large, pick a subset of your codebase (say, 5,000 to
50,000 lines) and get mypy to run successfully only on this subset at
first, ‘before adding annotations’.  This should be doable in a day or
two.  The sooner you get some form of mypy passing on your codebase, the
sooner you benefit.

You’ll likely need to fix some mypy errors, either by inserting
annotations requested by mypy or by adding ‘# type: ignore’ comments to
silence errors you don’t want to fix now.

We’ll mention some tips for getting mypy passing on your codebase in
various sections below.


File: Mypy.info,  Node: Run mypy consistently and prevent regressions,  Next: Ignoring errors from certain modules,  Prev: Start small,  Up: Using mypy with an existing codebase

1.2.2 Run mypy consistently and prevent regressions
---------------------------------------------------

Make sure all developers on your codebase run mypy the same way.  One
way to ensure this is adding a small script with your mypy invocation to
your codebase, or adding your mypy invocation to existing tools you use
to run tests, like ‘tox’.

   * Make sure everyone runs mypy with the same options.  Checking a
     mypy *note configuration file: 20. into your codebase can help with
     this.

   * Make sure everyone type checks the same set of files.  See *note
     Specifying code to be checked: 21. for details.

   * Make sure everyone runs mypy with the same version of mypy, for
     instance by pinning mypy with the rest of your dev requirements.

In particular, you’ll want to make sure to run mypy as part of your
Continuous Integration (CI) system as soon as possible.  This will
prevent new type errors from being introduced into your codebase.

A simple CI script could look something like this:

     python3 -m pip install mypy==0.971
     # Run your standardised mypy invocation, e.g.
     mypy my_project
     # This could also look like `scripts/run_mypy.sh`, `tox -e mypy`, `make mypy`, etc


File: Mypy.info,  Node: Ignoring errors from certain modules,  Next: Fixing errors related to imports,  Prev: Run mypy consistently and prevent regressions,  Up: Using mypy with an existing codebase

1.2.3 Ignoring errors from certain modules
------------------------------------------

By default mypy will follow imports in your code and try to check
everything.  This means even if you only pass in a few files to mypy, it
may still process a large number of imported files.  This could
potentially result in lots of errors you don’t want to deal with at the
moment.

One way to deal with this is to ignore errors in modules you aren’t yet
ready to type check.  The *note ignore_errors: 23. option is useful for
this, for instance, if you aren’t yet ready to deal with errors from
‘package_to_fix_later’:

     [mypy-package_to_fix_later.*]
     ignore_errors = True

You could even invert this, by setting ‘ignore_errors = True’ in your
global config section and only enabling error reporting with
‘ignore_errors = False’ for the set of modules you are ready to type
check.


File: Mypy.info,  Node: Fixing errors related to imports,  Next: Prioritise annotating widely imported modules,  Prev: Ignoring errors from certain modules,  Up: Using mypy with an existing codebase

1.2.4 Fixing errors related to imports
--------------------------------------

A common class of error you will encounter is errors from mypy about
modules that it can’t find, that don’t have types, or don’t have stub
files:

     core/config.py:7: error: Cannot find implementation or library stub for module named 'frobnicate'
     core/model.py:9: error: Cannot find implementation or library stub for module named 'acme'
     ...

Sometimes these can be fixed by installing the relevant packages or stub
libraries in the environment you’re running ‘mypy’ in.

See *note Missing imports: 16. for a complete reference on these errors
and the ways in which you can fix them.

You’ll likely find that you want to suppress all errors from importing a
given module that doesn’t have types.  If you only import that module in
one or two places, you can use ‘# type: ignore’ comments.  For example,
here we ignore an error about a third-party module ‘frobnicate’ that
doesn’t have stubs using ‘# type: ignore’:

     import frobnicate  # type: ignore
     ...
     frobnicate.initialize()  # OK (but not checked)

But if you import the module in many places, this becomes unwieldy.  In
this case, we recommend using a *note configuration file: 20.  For
example, to disable errors about importing ‘frobnicate’ and ‘acme’
everywhere in your codebase, use a config like this:

     [mypy-frobnicate.*]
     ignore_missing_imports = True

     [mypy-acme.*]
     ignore_missing_imports = True

If you get a large number of errors, you may want to ignore all errors
about missing imports, for instance by setting *note
ignore_missing_imports: 25. to true globally.  This can hide errors
later on, so we recommend avoiding this if possible.

Finally, mypy allows fine-grained control over specific import following
behaviour.  It’s very easy to silently shoot yourself in the foot when
playing around with these, so it’s mostly recommended as a last resort.
For more details, look *note here: 26.


File: Mypy.info,  Node: Prioritise annotating widely imported modules,  Next: Write annotations as you go,  Prev: Fixing errors related to imports,  Up: Using mypy with an existing codebase

1.2.5 Prioritise annotating widely imported modules
---------------------------------------------------

Most projects have some widely imported modules, such as utilities or
model classes.  It’s a good idea to annotate these pretty early on,
since this allows code using these modules to be type checked more
effectively.

Mypy is designed to support gradual typing, i.e.  letting you add
annotations at your own pace, so it’s okay to leave some of these
modules unannotated.  The more you annotate, the more useful mypy will
be, but even a little annotation coverage is useful.


File: Mypy.info,  Node: Write annotations as you go,  Next: Automate annotation of legacy code,  Prev: Prioritise annotating widely imported modules,  Up: Using mypy with an existing codebase

1.2.6 Write annotations as you go
---------------------------------

Consider adding something like these in your code style conventions:

  1. Developers should add annotations for any new code.

  2. It’s also encouraged to write annotations when you modify existing
     code.

This way you’ll gradually increase annotation coverage in your codebase
without much effort.


File: Mypy.info,  Node: Automate annotation of legacy code,  Next: Introduce stricter options,  Prev: Write annotations as you go,  Up: Using mypy with an existing codebase

1.2.7 Automate annotation of legacy code
----------------------------------------

There are tools for automatically adding draft annotations based on
simple static analysis or on type profiles collected at runtime.  Tools
include MonkeyType(1), autotyping(2) and PyAnnotate(3).

A simple approach is to collect types from test runs.  This may work
well if your test coverage is good (and if your tests aren’t very slow).

Another approach is to enable type collection for a small, random
fraction of production network requests.  This clearly requires more
care, as type collection could impact the reliability or the performance
of your service.

   ---------- Footnotes ----------

   (1) https://monkeytype.readthedocs.io/en/latest/index.html

   (2) https://github.com/JelleZijlstra/autotyping

   (3) https://github.com/dropbox/pyannotate


File: Mypy.info,  Node: Introduce stricter options,  Next: Speed up mypy runs,  Prev: Automate annotation of legacy code,  Up: Using mypy with an existing codebase

1.2.8 Introduce stricter options
--------------------------------

Mypy is very configurable.  Once you get started with static typing, you
may want to explore the various strictness options mypy provides to
catch more bugs.  For example, you can ask mypy to require annotations
for all functions in certain modules to avoid accidentally introducing
code that won’t be type checked using *note disallow_untyped_defs: 2b.
Refer to *note The mypy configuration file: 20. for the details.

An excellent goal to aim for is to have your codebase pass when run
against ‘mypy --strict’.  This basically ensures that you will never
have a type related error without an explicit circumvention somewhere
(such as a ‘# type: ignore’ comment).

The following config is equivalent to ‘--strict’:

     # Start off with these
     warn_unused_configs = True
     warn_redundant_casts = True
     warn_unused_ignores = True
     no_implicit_optional = True

     # Getting these passing should be easy
     strict_equality = True
     strict_concatenate = True

     # Strongly recommend enabling this one as soon as you can
     check_untyped_defs = True

     # These shouldn't be too much additional work, but may be tricky to
     # get passing if you use a lot of untyped libraries
     disallow_subclassing_any = True
     disallow_untyped_decorators = True
     disallow_any_generics = True

     # These next few are various gradations of forcing use of type annotations
     disallow_untyped_calls = True
     disallow_incomplete_defs = True
     disallow_untyped_defs = True

     # This one isn't too hard to get passing, but return on investment is lower
     no_implicit_reexport = True

     # This one can be tricky to get passing if you use a lot of untyped libraries
     warn_return_any = True

Note that you can also start with ‘--strict’ and subtract, for instance:

     strict = True
     warn_return_any = False

Remember that many of these options can be enabled on a per-module
basis.  For instance, you may want to enable ‘disallow_untyped_defs’ for
modules which you’ve completed annotations for, in order to prevent new
code from being added without annotations.

And if you want, it doesn’t stop at ‘--strict’.  Mypy has additional
checks that are not part of ‘--strict’ that can be useful.  See the
complete *note The mypy command line: a. reference and *note Error codes
for optional checks: 2c.


File: Mypy.info,  Node: Speed up mypy runs,  Prev: Introduce stricter options,  Up: Using mypy with an existing codebase

1.2.9 Speed up mypy runs
------------------------

You can use *note mypy daemon: 2e. to get much faster incremental mypy
runs.  The larger your project is, the more useful this will be.  If
your project has at least 100,000 lines of code or so, you may also want
to set up *note remote caching: 2f. for further speedups.


File: Mypy.info,  Node: Type hints cheat sheet,  Next: Built-in types,  Prev: Using mypy with an existing codebase,  Up: Contents

1.3 Type hints cheat sheet
==========================

This document is a quick cheat sheet showing how to use type annotations
for various common types in Python.

* Menu:

* Variables::
* Useful built-in types::
* Functions::
* When you’re puzzled or when things are complicated::
* Standard “duck types”::
* Classes::
* Coroutines and asyncio::
* Miscellaneous::
* Decorators::


File: Mypy.info,  Node: Variables,  Next: Useful built-in types,  Up: Type hints cheat sheet

1.3.1 Variables
---------------

Technically many of the type annotations shown below are redundant,
since mypy can usually infer the type of a variable from its value.  See
*note Type inference and type annotations: 34. for more details.

     # This is how you declare the type of a variable
     age: int = 1

     # You don't need to initialize a variable to annotate it
     a: int  # Ok (no value at runtime until assigned)

     # Doing so is useful in conditional branches
     child: bool
     if age < 18:
         child = True
     else:
         child = False


File: Mypy.info,  Node: Useful built-in types,  Next: Functions,  Prev: Variables,  Up: Type hints cheat sheet

1.3.2 Useful built-in types
---------------------------

     from typing import List, Set, Dict, Tuple, Optional

     # For most types, just use the name of the type
     x: int = 1
     x: float = 1.0
     x: bool = True
     x: str = "test"
     x: bytes = b"test"

     # For collections, the type of the collection item is in brackets
     # (Python 3.9+)
     x: list[int] = [1]
     x: set[int] = {6, 7}

     # In Python 3.8 and earlier, the name of the collection type is
     # capitalized, and the type is imported from the 'typing' module
     x: List[int] = [1]
     x: Set[int] = {6, 7}

     # For mappings, we need the types of both keys and values
     x: dict[str, float] = {"field": 2.0}  # Python 3.9+
     x: Dict[str, float] = {"field": 2.0}

     # For tuples of fixed size, we specify the types of all the elements
     x: tuple[int, str, float] = (3, "yes", 7.5)  # Python 3.9+
     x: Tuple[int, str, float] = (3, "yes", 7.5)

     # For tuples of variable size, we use one type and ellipsis
     x: tuple[int, ...] = (1, 2, 3)  # Python 3.9+
     x: Tuple[int, ...] = (1, 2, 3)

     # Use Optional[] for values that could be None
     x: Optional[str] = some_function()
     # Mypy understands a value can't be None in an if-statement
     if x is not None:
         print(x.upper())
     # If a value can never be None due to some invariants, use an assert
     assert x is not None
     print(x.upper())


File: Mypy.info,  Node: Functions,  Next: When you’re puzzled or when things are complicated,  Prev: Useful built-in types,  Up: Type hints cheat sheet

1.3.3 Functions
---------------

     from typing import Callable, Iterator, Union, Optional

     # This is how you annotate a function definition
     def stringify(num: int) -> str:
         return str(num)

     # And here's how you specify multiple arguments
     def plus(num1: int, num2: int) -> int:
         return num1 + num2

     # Add default value for an argument after the type annotation
     def f(num1: int, my_float: float = 3.5) -> float:
         return num1 + my_float

     # This is how you annotate a callable (function) value
     x: Callable[[int, float], float] = f

     # A generator function that yields ints is secretly just a function that
     # returns an iterator of ints, so that's how we annotate it
     def g(n: int) -> Iterator[int]:
         i = 0
         while i < n:
             yield i
             i += 1

     # You can of course split a function annotation over multiple lines
     def send_email(address: Union[str, list[str]],
                    sender: str,
                    cc: Optional[list[str]],
                    bcc: Optional[list[str]],
                    subject: str = '',
                    body: Optional[list[str]] = None
                    ) -> bool:
         ...

     # Mypy understands positional-only and keyword-only arguments
     # Positional-only arguments can also be marked by using a name starting with
     # two underscores
     def quux(x: int, / *, y: int) -> None:
         pass

     quux(3, y=5)  # Ok
     quux(3, 5)  # error: Too many positional arguments for "quux"
     quux(x=3, y=5)  # error: Unexpected keyword argument "x" for "quux"

     # This makes each positional arg and each keyword arg a "str"
     def call(self, *args: str, **kwargs: str) -> str:
         reveal_type(args)  # Revealed type is "tuple[str, ...]"
         reveal_type(kwargs)  # Revealed type is "dict[str, str]"
         request = make_request(*args, **kwargs)
         return self.do_api_query(request)


File: Mypy.info,  Node: When you’re puzzled or when things are complicated,  Next: Standard “duck types”,  Prev: Functions,  Up: Type hints cheat sheet

1.3.4 When you’re puzzled or when things are complicated
--------------------------------------------------------

     from typing import Union, Any, Optional, TYPE_CHECKING, cast

     # To find out what type mypy infers for an expression anywhere in
     # your program, wrap it in reveal_type().  Mypy will print an error
     # message with the type; remove it again before running the code.
     reveal_type(1)  # Revealed type is "builtins.int"

     # Use Union when something could be one of a few types
     x: list[Union[int, str]] = [3, 5, "test", "fun"]

     # If you initialize a variable with an empty container or "None"
     # you may have to help mypy a bit by providing an explicit type annotation
     x: list[str] = []
     x: Optional[str] = None

     # Use Any if you don't know the type of something or it's too
     # dynamic to write a type for
     x: Any = mystery_function()

     # Use a "type: ignore" comment to suppress errors on a given line,
     # when your code confuses mypy or runs into an outright bug in mypy.
     # Good practice is to add a comment explaining the issue.
     x = confusing_function()  # type: ignore  # confusing_function won't return None here because ...

     # "cast" is a helper function that lets you override the inferred
     # type of an expression. It's only for mypy -- there's no runtime check.
     a = [4]
     b = cast(list[int], a)  # Passes fine
     c = cast(list[str], a)  # Passes fine despite being a lie (no runtime check)
     reveal_type(c)  # Revealed type is "builtins.list[builtins.str]"
     print(c)  # Still prints [4] ... the object is not changed or casted at runtime

     # Use "TYPE_CHECKING" if you want to have code that mypy can see but will not
     # be executed at runtime (or to have code that mypy can't see)
     if TYPE_CHECKING:
         import json
     else:
         import orjson as json  # mypy is unaware of this

In some cases type annotations can cause issues at runtime, see *note
Annotation issues at runtime: 38. for dealing with this.


File: Mypy.info,  Node: Standard “duck types”,  Next: Classes,  Prev: When you’re puzzled or when things are complicated,  Up: Type hints cheat sheet

1.3.5 Standard “duck types”
---------------------------

In typical Python code, many functions that can take a list or a dict as
an argument only need their argument to be somehow “list-like” or
“dict-like”.  A specific meaning of “list-like” or “dict-like” (or
something-else-like) is called a “duck type”, and several duck types
that are common in idiomatic Python are standardized.

     from typing import Mapping, MutableMapping, Sequence, Iterable

     # Use Iterable for generic iterables (anything usable in "for"),
     # and Sequence where a sequence (supporting "len" and "__getitem__") is
     # required
     def f(ints: Iterable[int]) -> list[str]:
         return [str(x) for x in ints]

     f(range(1, 3))

     # Mapping describes a dict-like object (with "__getitem__") that we won't
     # mutate, and MutableMapping one (with "__setitem__") that we might
     def f(my_mapping: Mapping[int, str]) -> list[int]:
         my_mapping[5] = 'maybe'  # mypy will complain about this line...
         return list(my_mapping.keys())

     f({3: 'yes', 4: 'no'})

     def f(my_mapping: MutableMapping[int, str]) -> set[str]:
         my_mapping[5] = 'maybe'  # ...but mypy is OK with this.
         return set(my_mapping.values())

     f({3: 'yes', 4: 'no'})

You can even make your own duck types using *note Protocols and
structural subtyping: 3a.


File: Mypy.info,  Node: Classes,  Next: Coroutines and asyncio,  Prev: Standard “duck types”,  Up: Type hints cheat sheet

1.3.6 Classes
-------------

     class MyClass:
         # You can optionally declare instance variables in the class body
         attr: int
         # This is an instance variable with a default value
         charge_percent: int = 100

         # The "__init__" method doesn't return anything, so it gets return
         # type "None" just like any other method that doesn't return anything
         def __init__(self) -> None:
             ...

         # For instance methods, omit type for "self"
         def my_method(self, num: int, str1: str) -> str:
             return num * str1

     # User-defined classes are valid as types in annotations
     x: MyClass = MyClass()

     # You can use the ClassVar annotation to declare a class variable
     class Car:
         seats: ClassVar[int] = 4
         passengers: ClassVar[list[str]]

     # You can also declare the type of an attribute in "__init__"
     class Box:
         def __init__(self) -> None:
             self.items: list[str] = []

     # If you want dynamic attributes on your class, have it override "__setattr__"
     # or "__getattr__" in a stub or in your source code.
     #
     # "__setattr__" allows for dynamic assignment to names
     # "__getattr__" allows for dynamic access to names
     class A:
         # This will allow assignment to any A.x, if x is the same type as "value"
         # (use "value: Any" to allow arbitrary types)
         def __setattr__(self, name: str, value: int) -> None: ...

         # This will allow access to any A.x, if x is compatible with the return type
         def __getattr__(self, name: str) -> int: ...

     a.foo = 42  # Works
     a.bar = 'Ex-parrot'  # Fails type checking


File: Mypy.info,  Node: Coroutines and asyncio,  Next: Miscellaneous,  Prev: Classes,  Up: Type hints cheat sheet

1.3.7 Coroutines and asyncio
----------------------------

See *note Typing async/await: 3d. for the full detail on typing
coroutines and asynchronous code.

     import asyncio

     # A coroutine is typed like a normal function
     async def countdown35(tag: str, count: int) -> str:
         while count > 0:
             print(f'T-minus {count} ({tag})')
             await asyncio.sleep(0.1)
             count -= 1
         return "Blastoff!"


File: Mypy.info,  Node: Miscellaneous,  Next: Decorators,  Prev: Coroutines and asyncio,  Up: Type hints cheat sheet

1.3.8 Miscellaneous
-------------------

     import sys
     import re
     from typing import Match, IO

     # "typing.Match" describes regex matches from the re module
     x: Match[str] = re.match(r'[0-9]+', "15")

     # Use IO[] for functions that should accept or return any
     # object that comes from an open() call (IO[] does not
     # distinguish between reading, writing or other modes)
     def get_sys_IO(mode: str = 'w') -> IO[str]:
         if mode == 'w':
             return sys.stdout
         elif mode == 'r':
             return sys.stdin
         else:
             return sys.stdout

     # Forward references are useful if you want to reference a class before
     # it is defined
     def f(foo: A) -> int:  # This will fail
         ...

     class A:
         ...

     # If you use the string literal 'A', it will pass as long as there is a
     # class of that name later on in the file
     def f(foo: 'A') -> int:  # Ok
         ...


File: Mypy.info,  Node: Decorators,  Prev: Miscellaneous,  Up: Type hints cheat sheet

1.3.9 Decorators
----------------

Decorator functions can be expressed via generics.  See *note Declaring
decorators: 40. for more details.

     from typing import Any, Callable, TypeVar

     F = TypeVar('F', bound=Callable[..., Any])

     def bare_decorator(func: F) -> F:
         ...

     def decorator_args(url: str) -> Callable[[F], F]:
         ...


File: Mypy.info,  Node: Built-in types,  Next: Type inference and type annotations,  Prev: Type hints cheat sheet,  Up: Contents

1.4 Built-in types
==================

This chapter introduces some commonly used built-in types.  We will
cover many other kinds of types later.

* Menu:

* Simple types::
* Any type::
* Generic types::


File: Mypy.info,  Node: Simple types,  Next: Any type,  Up: Built-in types

1.4.1 Simple types
------------------

Here are examples of some common built-in types:

Type                       Description
                           
-----------------------------------------------------------------------------------------
                           
‘int’                      integer
                           
                           
‘float’                    floating point number
                           
                           
‘bool’                     boolean value (subclass of ‘int’)
                           
                           
‘str’                      text, sequence of unicode codepoints
                           
                           
‘bytes’                    8-bit string, sequence of byte values
                           
                           
‘object’                   an arbitrary object (‘object’ is the common base class)
                           

All built-in classes can be used as types.


File: Mypy.info,  Node: Any type,  Next: Generic types,  Prev: Simple types,  Up: Built-in types

1.4.2 Any type
--------------

If you can’t find a good type for some value, you can always fall back
to ‘Any’:

Type                       Description
                           
------------------------------------------------------------------------------
                           
‘Any’                      dynamically typed value with an arbitrary type
                           

The type ‘Any’ is defined in the typing(1) module.  See *note
Dynamically typed code: 45. for more details.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Generic types,  Prev: Any type,  Up: Built-in types

1.4.3 Generic types
-------------------

In Python 3.9 and later, built-in collection type objects support
indexing:

Type                       Description
                           
----------------------------------------------------------------------------------------------------
                           
‘list[str]’                list of ‘str’ objects
                           
                           
‘tuple[int, int]’          tuple of two ‘int’ objects (‘tuple[()]’ is the empty tuple)
                           
                           
‘tuple[int, ...]’          tuple of an arbitrary number of ‘int’ objects
                           
                           
‘dict[str, int]’           dictionary from ‘str’ keys to ‘int’ values
                           
                           
‘Iterable[int]’            iterable object containing ints
                           
                           
‘Sequence[bool]’           sequence of booleans (read-only)
                           
                           
‘Mapping[str, int]’        mapping from ‘str’ keys to ‘int’ values (read-only)
                           
                           
‘type[C]’                  type object of ‘C’ (‘C’ is a class/type variable/union of types)
                           

The type ‘dict’ is a ‘generic’ class, signified by type arguments within
‘[...]’.  For example, ‘dict[int, str]’ is a dictionary from integers to
strings and ‘dict[Any, Any]’ is a dictionary of dynamically typed
(arbitrary) values and keys.  ‘list’ is another generic class.

‘Iterable’, ‘Sequence’, and ‘Mapping’ are generic types that correspond
to Python protocols.  For example, a ‘str’ object or a ‘list[str]’
object is valid when ‘Iterable[str]’ or ‘Sequence[str]’ is expected.
You can import them from collections.abc(1) instead of importing from
typing(2) in Python 3.9.

See *note Using generic builtins: 47. for more details, including how
you can use these in annotations also in Python 3.7 and 3.8.

These legacy types defined in typing(3) are needed if you need to
support Python 3.8 and earlier:

Type                       Description
                           
----------------------------------------------------------------------------------------------------
                           
‘List[str]’                list of ‘str’ objects
                           
                           
‘Tuple[int, int]’          tuple of two ‘int’ objects (‘Tuple[()]’ is the empty tuple)
                           
                           
‘Tuple[int, ...]’          tuple of an arbitrary number of ‘int’ objects
                           
                           
‘Dict[str, int]’           dictionary from ‘str’ keys to ‘int’ values
                           
                           
‘Iterable[int]’            iterable object containing ints
                           
                           
‘Sequence[bool]’           sequence of booleans (read-only)
                           
                           
‘Mapping[str, int]’        mapping from ‘str’ keys to ‘int’ values (read-only)
                           
                           
‘Type[C]’                  type object of ‘C’ (‘C’ is a class/type variable/union of types)
                           

‘List’ is an alias for the built-in type ‘list’ that supports indexing
(and similarly for ‘dict’/‘Dict’ and ‘tuple’/‘Tuple’).

Note that even though ‘Iterable’, ‘Sequence’ and ‘Mapping’ look similar
to abstract base classes defined in collections.abc(4) (formerly
‘collections’), they are not identical, since the latter don’t support
indexing prior to Python 3.9.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/collections.abc.html#module-collections.abc

   (2) https://docs.python.org/3/library/typing.html#module-typing

   (3) https://docs.python.org/3/library/typing.html#module-typing

   (4) 
https://docs.python.org/3/library/collections.abc.html#module-collections.abc


File: Mypy.info,  Node: Type inference and type annotations,  Next: Kinds of types,  Prev: Built-in types,  Up: Contents

1.5 Type inference and type annotations
=======================================

* Menu:

* Type inference::
* Explicit types for variables::
* Explicit types for collections::
* Compatibility of container types::
* Context in type inference::
* Silencing type errors::


File: Mypy.info,  Node: Type inference,  Next: Explicit types for variables,  Up: Type inference and type annotations

1.5.1 Type inference
--------------------

For most variables, if you do not explicitly specify its type, mypy will
infer the correct type based on what is initially assigned to the
variable.

     # Mypy will infer the type of these variables, despite no annotations
     i = 1
     reveal_type(i)  # Revealed type is "builtins.int"
     l = [1, 2]
     reveal_type(l)  # Revealed type is "builtins.list[builtins.int]"

     Note: Note that mypy will not use type inference in dynamically
     typed functions (those without a function type annotation) — every
     local variable type defaults to ‘Any’ in such functions.  For more
     details, see *note Dynamically typed code: 45.

          def untyped_function():
              i = 1
              reveal_type(i) # Revealed type is "Any"
                             # 'reveal_type' always outputs 'Any' in unchecked functions


File: Mypy.info,  Node: Explicit types for variables,  Next: Explicit types for collections,  Prev: Type inference,  Up: Type inference and type annotations

1.5.2 Explicit types for variables
----------------------------------

You can override the inferred type of a variable by using a variable
type annotation:

     from typing import Union

     x: Union[int, str] = 1

Without the type annotation, the type of ‘x’ would be just ‘int’.  We
use an annotation to give it a more general type ‘Union[int, str]’ (this
type means that the value can be either an ‘int’ or a ‘str’).

The best way to think about this is that the type annotation sets the
type of the variable, not the type of the expression.  For instance,
mypy will complain about the following code:

     x: Union[int, str] = 1.1  # error: Incompatible types in assignment
                               # (expression has type "float", variable has type "Union[int, str]")

     Note: To explicitly override the type of an expression you can use
     cast(<type>, <expression>)(1).  See *note Casts: 4d. for details.

Note that you can explicitly declare the type of a variable without
giving it an initial value:

     # We only unpack two values, so there's no right-hand side value
     # for mypy to infer the type of "cs" from:
     a, b, *cs = 1, 2  # error: Need type annotation for "cs"

     rs: list[int]  # no assignment!
     p, q, *rs = 1, 2  # OK

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.cast


File: Mypy.info,  Node: Explicit types for collections,  Next: Compatibility of container types,  Prev: Explicit types for variables,  Up: Type inference and type annotations

1.5.3 Explicit types for collections
------------------------------------

The type checker cannot always infer the type of a list or a dictionary.
This often arises when creating an empty list or dictionary and
assigning it to a new variable that doesn’t have an explicit variable
type.  Here is an example where mypy can’t infer the type without some
help:

     l = []  # Error: Need type annotation for "l"

In these cases you can give the type explicitly using a type annotation:

     l: list[int] = []       # Create empty list of int
     d: dict[str, int] = {}  # Create empty dictionary (str -> int)

     Note: Using type arguments (e.g.  ‘list[int]’) on builtin
     collections like list(1), dict(2), tuple(3), and set(4) only works
     in Python 3.9 and later.  For Python 3.8 and earlier, you must use
     List(5) (e.g.  ‘List[int]’), Dict(6), and so on.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#list

   (2) https://docs.python.org/3/library/stdtypes.html#dict

   (3) https://docs.python.org/3/library/stdtypes.html#tuple

   (4) https://docs.python.org/3/library/stdtypes.html#set

   (5) https://docs.python.org/3/library/typing.html#typing.List

   (6) https://docs.python.org/3/library/typing.html#typing.Dict


File: Mypy.info,  Node: Compatibility of container types,  Next: Context in type inference,  Prev: Explicit types for collections,  Up: Type inference and type annotations

1.5.4 Compatibility of container types
--------------------------------------

A quick note: container types can sometimes be unintuitive.  We’ll
discuss this more in *note Invariance vs covariance: 50.  For example,
the following program generates a mypy error, because mypy treats
‘list[int]’ as incompatible with ‘list[object]’:

     def f(l: list[object], k: list[int]) -> None:
         l = k  # error: Incompatible types in assignment

The reason why the above assignment is disallowed is that allowing the
assignment could result in non-int values stored in a list of ‘int’:

     def f(l: list[object], k: list[int]) -> None:
         l = k
         l.append('x')
         print(k[-1])  # Ouch; a string in list[int]

Other container types like dict(1) and set(2) behave similarly.

You can still run the above program; it prints ‘x’.  This illustrates
the fact that static types do not affect the runtime behavior of
programs.  You can run programs with type check failures, which is often
very handy when performing a large refactoring.  Thus you can always
‘work around’ the type system, and it doesn’t really limit what you can
do in your program.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#dict

   (2) https://docs.python.org/3/library/stdtypes.html#set


File: Mypy.info,  Node: Context in type inference,  Next: Silencing type errors,  Prev: Compatibility of container types,  Up: Type inference and type annotations

1.5.5 Context in type inference
-------------------------------

Type inference is ‘bidirectional’ and takes context into account.

Mypy will take into account the type of the variable on the left-hand
side of an assignment when inferring the type of the expression on the
right-hand side.  For example, the following will type check:

     def f(l: list[object]) -> None:
         l = [1, 2]  # Infer type list[object] for [1, 2], not list[int]

The value expression ‘[1, 2]’ is type checked with the additional
context that it is being assigned to a variable of type ‘list[object]’.
This is used to infer the type of the ‘expression’ as ‘list[object]’.

Declared argument types are also used for type context.  In this program
mypy knows that the empty list ‘[]’ should have type ‘list[int]’ based
on the declared type of ‘arg’ in ‘foo’:

     def foo(arg: list[int]) -> None:
         print('Items:', ''.join(str(a) for a in arg))

     foo([])  # OK

However, context only works within a single statement.  Here mypy
requires an annotation for the empty list, since the context would only
be available in the following statement:

     def foo(arg: list[int]) -> None:
         print('Items:', ', '.join(arg))

     a = []  # Error: Need type annotation for "a"
     foo(a)

Working around the issue is easy by adding a type annotation:

     ...
     a: list[int] = []  # OK
     foo(a)


File: Mypy.info,  Node: Silencing type errors,  Prev: Context in type inference,  Up: Type inference and type annotations

1.5.6 Silencing type errors
---------------------------

You might want to disable type checking on specific lines, or within
specific files in your codebase.  To do that, you can use a ‘# type:
ignore’ comment.

For example, say in its latest update, the web framework you use can now
take an integer argument to ‘run()’, which starts it on localhost on
that port.  Like so:

     # Starting app on http://localhost:8000
     app.run(8000)

However, the devs forgot to update their type annotations for ‘run’, so
mypy still thinks ‘run’ only expects ‘str’ types.  This would give you
the following error:

     error: Argument 1 to "run" of "A" has incompatible type "int"; expected "str"

If you cannot directly fix the web framework yourself, you can
temporarily disable type checking on that line, by adding a ‘# type:
ignore’:

     # Starting app on http://localhost:8000
     app.run(8000)  # type: ignore

This will suppress any mypy errors that would have raised on that
specific line.

You should probably add some more information on the ‘# type: ignore’
comment, to explain why the ignore was added in the first place.  This
could be a link to an issue on the repository responsible for the type
stubs, or it could be a short explanation of the bug.  To do that, use
this format:

     # Starting app on http://localhost:8000
     app.run(8000)  # type: ignore  # `run()` in v2.0 accepts an `int`, as a port

By default, mypy displays an error code for each error:

     error: "str" has no attribute "trim"  [attr-defined]

It is possible to add a specific error-code in your ignore comment (e.g.
‘# type: ignore[attr-defined]’) to clarify what’s being silenced.  You
can find more information about error codes *note here: 53.

Similarly, you can also ignore all mypy errors in a file, by adding a ‘#
mypy: ignore-errors’ at the top of the file:

     # mypy: ignore-errors
     # This is a test file, skipping type checking in it.
     import unittest
     ...

Finally, adding a ‘@typing.no_type_check’ decorator to a class, method
or function has the effect of ignoring that class, method or function.

     @typing.no_type_check
     def foo() -> str:
        return 12345  # No error!


File: Mypy.info,  Node: Kinds of types,  Next: Class basics,  Prev: Type inference and type annotations,  Up: Contents

1.6 Kinds of types
==================

We’ve mostly restricted ourselves to built-in types until now.  This
section introduces several additional kinds of types.  You are likely to
need at least some of them to type check any non-trivial programs.

* Menu:

* Class types::
* The Any type::
* Tuple types::
* Callable types (and lambdas): Callable types and lambdas.
* Union types::
* Optional types and the None type::
* Disabling strict optional checking::
* Type aliases::
* Named tuples::
* The type of class objects::
* Generators::


File: Mypy.info,  Node: Class types,  Next: The Any type,  Up: Kinds of types

1.6.1 Class types
-----------------

Every class is also a valid type.  Any instance of a subclass is also
compatible with all superclasses – it follows that every value is
compatible with the object(1) type (and incidentally also the ‘Any’
type, discussed below).  Mypy analyzes the bodies of classes to
determine which methods and attributes are available in instances.  This
example uses subclassing:

     class A:
         def f(self) -> int:  # Type of self inferred (A)
             return 2

     class B(A):
         def f(self) -> int:
              return 3
         def g(self) -> int:
             return 4

     def foo(a: A) -> None:
         print(a.f())  # 3
         a.g()         # Error: "A" has no attribute "g"

     foo(B())  # OK (B is a subclass of A)

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#object


File: Mypy.info,  Node: The Any type,  Next: Tuple types,  Prev: Class types,  Up: Kinds of types

1.6.2 The Any type
------------------

A value with the ‘Any’ type is dynamically typed.  Mypy doesn’t know
anything about the possible runtime types of such value.  Any operations
are permitted on the value, and the operations are only checked at
runtime.  You can use ‘Any’ as an “escape hatch” when you can’t use a
more precise type for some reason.

‘Any’ is compatible with every other type, and vice versa.  You can
freely assign a value of type ‘Any’ to a variable with a more precise
type:

     a: Any = None
     s: str = ''
     a = 2     # OK (assign "int" to "Any")
     s = a     # OK (assign "Any" to "str")

Declared (and inferred) types are ignored (or ‘erased’) at runtime.
They are basically treated as comments, and thus the above code does not
generate a runtime error, even though ‘s’ gets an ‘int’ value when the
program is run, while the declared type of ‘s’ is actually ‘str’!  You
need to be careful with ‘Any’ types, since they let you lie to mypy, and
this could easily hide bugs.

If you do not define a function return value or argument types, these
default to ‘Any’:

     def show_heading(s) -> None:
         print('=== ' + s + ' ===')  # No static type checking, as s has type Any

     show_heading(1)  # OK (runtime error only; mypy won't generate an error)

You should give a statically typed function an explicit ‘None’ return
type even if it doesn’t return a value, as this lets mypy catch
additional type errors:

     def wait(t: float):  # Implicit Any return value
         print('Waiting...')
         time.sleep(t)

     if wait(2) > 1:   # Mypy doesn't catch this error!
         ...

If we had used an explicit ‘None’ return type, mypy would have caught
the error:

     def wait(t: float) -> None:
         print('Waiting...')
         time.sleep(t)

     if wait(2) > 1:   # Error: can't compare None and int
         ...

The ‘Any’ type is discussed in more detail in section *note Dynamically
typed code: 45.

     Note: A function without any types in the signature is dynamically
     typed.  The body of a dynamically typed function is not checked
     statically, and local variables have implicit ‘Any’ types.  This
     makes it easier to migrate legacy Python code to mypy, as mypy
     won’t complain about dynamically typed functions.


File: Mypy.info,  Node: Tuple types,  Next: Callable types and lambdas,  Prev: The Any type,  Up: Kinds of types

1.6.3 Tuple types
-----------------

The type ‘tuple[T1, ..., Tn]’ represents a tuple with the item types
‘T1’, …, ‘Tn’:

     # Use `typing.Tuple` in Python 3.8 and earlier
     def f(t: tuple[int, str]) -> None:
         t = 1, 'foo'    # OK
         t = 'foo', 1    # Type check error

A tuple type of this kind has exactly a specific number of items (2 in
the above example).  Tuples can also be used as immutable,
varying-length sequences.  You can use the type ‘tuple[T, ...]’ (with a
literal ‘...’ – it’s part of the syntax) for this purpose.  Example:

     def print_squared(t: tuple[int, ...]) -> None:
         for n in t:
             print(n, n ** 2)

     print_squared(())           # OK
     print_squared((1, 3, 5))    # OK
     print_squared([1, 2])       # Error: only a tuple is valid

     Note: Usually it’s a better idea to use ‘Sequence[T]’ instead of
     ‘tuple[T, ...]’, as Sequence(1) is also compatible with lists and
     other non-tuple sequences.

     Note: ‘tuple[...]’ is valid as a base class in Python 3.6 and
     later, and always in stub files.  In earlier Python versions you
     can sometimes work around this limitation by using a named tuple as
     a base class (see section *note Named tuples: 5a.).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Sequence


File: Mypy.info,  Node: Callable types and lambdas,  Next: Union types,  Prev: Tuple types,  Up: Kinds of types

1.6.4 Callable types (and lambdas)
----------------------------------

You can pass around function objects and bound methods in statically
typed code.  The type of a function that accepts arguments ‘A1’, …, ‘An’
and returns ‘Rt’ is ‘Callable[[A1, ..., An], Rt]’.  Example:

     from typing import Callable

     def twice(i: int, next: Callable[[int], int]) -> int:
         return next(next(i))

     def add(i: int) -> int:
         return i + 1

     print(twice(3, add))   # 5

You can only have positional arguments, and only ones without default
values, in callable types.  These cover the vast majority of uses of
callable types, but sometimes this isn’t quite enough.  Mypy recognizes
a special form ‘Callable[..., T]’ (with a literal ‘...’) which can be
used in less typical cases.  It is compatible with arbitrary callable
objects that return a type compatible with ‘T’, independent of the
number, types or kinds of arguments.  Mypy lets you call such callable
values with arbitrary arguments, without any checking – in this respect
they are treated similar to a ‘(*args: Any, **kwargs: Any)’ function
signature.  Example:

     from typing import Callable

     def arbitrary_call(f: Callable[..., int]) -> int:
         return f('x') + f(y=2)  # OK

     arbitrary_call(ord)   # No static error, but fails at runtime
     arbitrary_call(open)  # Error: does not return an int
     arbitrary_call(1)     # Error: 'int' is not callable

In situations where more precise or complex types of callbacks are
necessary one can use flexible *note callback protocols: 5d.  Lambdas
are also supported.  The lambda argument and return value types cannot
be given explicitly; they are always inferred based on context using
bidirectional type inference:

     l = map(lambda x: x + 1, [1, 2, 3])   # Infer x as int and l as list[int]

If you want to give the argument or return value types explicitly, use
an ordinary, perhaps nested function definition.


File: Mypy.info,  Node: Union types,  Next: Optional types and the None type,  Prev: Callable types and lambdas,  Up: Kinds of types

1.6.5 Union types
-----------------

Python functions often accept values of two or more different types.
You can use *note overloading: 60. to represent this, but union types
are often more convenient.

Use the ‘Union[T1, ..., Tn]’ type constructor to construct a union type.
For example, if an argument has type ‘Union[int, str]’, both integers
and strings are valid argument values.

You can use an isinstance()(1) check to narrow down a union type to a
more specific type:

     from typing import Union

     def f(x: Union[int, str]) -> None:
         x + 1     # Error: str + int is not valid
         if isinstance(x, int):
             # Here type of x is int.
             x + 1      # OK
         else:
             # Here type of x is str.
             x + 'a'    # OK

     f(1)    # OK
     f('x')  # OK
     f(1.1)  # Error

     Note: Operations are valid for union types only if they are valid
     for ‘every’ union item.  This is why it’s often necessary to use an
     isinstance()(2) check to first narrow down a union type to a
     non-union type.  This also means that it’s recommended to avoid
     union types as function return types, since the caller may have to
     use isinstance()(3) before doing anything interesting with the
     value.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance

   (2) https://docs.python.org/3/library/functions.html#isinstance

   (3) https://docs.python.org/3/library/functions.html#isinstance


File: Mypy.info,  Node: Optional types and the None type,  Next: Disabling strict optional checking,  Prev: Union types,  Up: Kinds of types

1.6.6 Optional types and the None type
--------------------------------------

You can use the Optional(1) type modifier to define a type variant that
allows ‘None’, such as ‘Optional[int]’ (‘Optional[X]’ is the preferred
shorthand for ‘Union[X, None]’):

     from typing import Optional

     def strlen(s: str) -> Optional[int]:
         if not s:
             return None  # OK
         return len(s)

     def strlen_invalid(s: str) -> int:
         if not s:
             return None  # Error: None not compatible with int
         return len(s)

Most operations will not be allowed on unguarded ‘None’ or Optional(2)
values:

     def my_inc(x: Optional[int]) -> int:
         return x + 1  # Error: Cannot add None and int

Instead, an explicit ‘None’ check is required.  Mypy has powerful type
inference that lets you use regular Python idioms to guard against
‘None’ values.  For example, mypy recognizes ‘is None’ checks:

     def my_inc(x: Optional[int]) -> int:
         if x is None:
             return 0
         else:
             # The inferred type of x is just int here.
             return x + 1

Mypy will infer the type of ‘x’ to be ‘int’ in the else block due to the
check against ‘None’ in the if condition.

Other supported checks for guarding against a ‘None’ value include ‘if x
is not None’, ‘if x’ and ‘if not x’.  Additionally, mypy understands
‘None’ checks within logical expressions:

     def concat(x: Optional[str], y: Optional[str]) -> Optional[str]:
         if x is not None and y is not None:
             # Both x and y are not None here
             return x + y
         else:
             return None

Sometimes mypy doesn’t realize that a value is never ‘None’.  This
notably happens when a class instance can exist in a partially defined
state, where some attribute is initialized to ‘None’ during object
construction, but a method assumes that the attribute is no longer
‘None’.  Mypy will complain about the possible ‘None’ value.  You can
use ‘assert x is not None’ to work around this in the method:

     class Resource:
         path: Optional[str] = None

         def initialize(self, path: str) -> None:
             self.path = path

         def read(self) -> str:
             # We require that the object has been initialized.
             assert self.path is not None
             with open(self.path) as f:  # OK
                return f.read()

     r = Resource()
     r.initialize('/foo/bar')
     r.read()

When initializing a variable as ‘None’, ‘None’ is usually an empty
place-holder value, and the actual value has a different type.  This is
why you need to annotate an attribute in cases like the class ‘Resource’
above:

     class Resource:
         path: Optional[str] = None
         ...

This also works for attributes defined within methods:

     class Counter:
         def __init__(self) -> None:
             self.count: Optional[int] = None

This is not a problem when using variable annotations, since no initial
value is needed:

     class Container:
         items: list[str]  # No initial value

Mypy generally uses the first assignment to a variable to infer the type
of the variable.  However, if you assign both a ‘None’ value and a
non-‘None’ value in the same scope, mypy can usually do the right thing
without an annotation:

     def f(i: int) -> None:
         n = None  # Inferred type Optional[int] because of the assignment below
         if i > 0:
              n = i
         ...

Sometimes you may get the error “Cannot determine type of <something>”.
In this case you should add an explicit ‘Optional[...]’ annotation (or
type comment).

     Note: ‘None’ is a type with only one value, ‘None’.  ‘None’ is also
     used as the return type for functions that don’t return a value,
     i.e.  functions that implicitly return ‘None’.

     Note: The Python interpreter internally uses the name ‘NoneType’
     for the type of ‘None’, but ‘None’ is always used in type
     annotations.  The latter is shorter and reads better.  (‘NoneType’
     is available as types.NoneType(3) on Python 3.10+, but is not
     exposed at all on earlier versions of Python.)

     Note: ‘Optional[...]’ ‘does not’ mean a function argument with a
     default value.  It simply means that ‘None’ is a valid value for
     the argument.  This is a common confusion because ‘None’ is a
     common default value for arguments.

* Menu:

* X | Y syntax for Unions::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Optional

   (2) https://docs.python.org/3/library/typing.html#typing.Optional

   (3) https://docs.python.org/3/library/types.html#types.NoneType


File: Mypy.info,  Node: X | Y syntax for Unions,  Up: Optional types and the None type

1.6.6.1 X | Y syntax for Unions
...............................

PEP 604(1) introduced an alternative way for spelling union types.  In
Python 3.10 and later, you can write ‘Union[int, str]’ as ‘int | str’.
It is possible to use this syntax in versions of Python where it isn’t
supported by the runtime with some limitations (see *note Annotation
issues at runtime: 38.).

     t1: int | str  # equivalent to Union[int, str]

     t2: int | None  # equivalent to Optional[int]

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0604/


File: Mypy.info,  Node: Disabling strict optional checking,  Next: Type aliases,  Prev: Optional types and the None type,  Up: Kinds of types

1.6.7 Disabling strict optional checking
----------------------------------------

Mypy also has an option to treat ‘None’ as a valid value for every type
(in case you know Java, it’s useful to think of it as similar to the
Java ‘null’).  In this mode ‘None’ is also valid for primitive types
such as ‘int’ and ‘float’, and Optional(1) types are not required.

The mode is enabled through the *note –no-strict-optional: 67.
command-line option.  In mypy versions before 0.600 this was the default
mode.  You can enable this option explicitly for backward compatibility
with earlier mypy versions, in case you don’t want to introduce optional
types to your codebase yet.

It will cause mypy to silently accept some buggy code, such as this
example – it’s not recommended if you can avoid it:

     def inc(x: int) -> int:
         return x + 1

     x = inc(None)  # No error reported by mypy if strict optional mode disabled!

However, making code “optional clean” can take some work!  You can also
use *note the mypy configuration file: 20. to migrate your code to
strict optional checking one file at a time, since there exists the
per-module flag *note strict_optional: 68. to control strict optional
mode.

Often it’s still useful to document whether a variable can be ‘None’.
For example, this function accepts a ‘None’ argument, but it’s not
obvious from its signature:

     def greeting(name: str) -> str:
         if name:
             return f'Hello, {name}'
         else:
             return 'Hello, stranger'

     print(greeting('Python'))  # Okay!
     print(greeting(None))      # Also okay!

You can still use Optional[t](2) to document that ‘None’ is a valid
argument type, even if strict ‘None’ checking is not enabled:

     from typing import Optional

     def greeting(name: Optional[str]) -> str:
         if name:
             return f'Hello, {name}'
         else:
             return 'Hello, stranger'

Mypy treats this as semantically equivalent to the previous example if
strict optional checking is disabled, since ‘None’ is implicitly valid
for any type, but it’s much more useful for a programmer who is reading
the code.  This also makes it easier to migrate to strict ‘None’
checking in the future.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Optional

   (2) https://docs.python.org/3/library/typing.html#typing.Optional


File: Mypy.info,  Node: Type aliases,  Next: Named tuples,  Prev: Disabling strict optional checking,  Up: Kinds of types

1.6.8 Type aliases
------------------

In certain situations, type names may end up being long and painful to
type:

     def f() -> Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]:
         ...

When cases like this arise, you can define a type alias by simply
assigning the type to a variable:

     AliasType = Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]

     # Now we can use AliasType in place of the full name:

     def f() -> AliasType:
         ...

     Note: A type alias does not create a new type.  It’s just a
     shorthand notation for another type – it’s equivalent to the target
     type except for *note generic aliases: 6b.

Since Mypy 0.930 you can also use ‘explicit type aliases’, which were
introduced in PEP 613(1).

There can be confusion about exactly when an assignment defines an
implicit type alias – for example, when the alias contains forward
references, invalid types, or violates some other restrictions on type
alias declarations.  Because the distinction between an unannotated
variable and a type alias is implicit, ambiguous or incorrect type alias
declarations default to defining a normal variable instead of a type
alias.

Explicit type aliases are unambiguous and can also improve readability
by making the intent clear:

     from typing import TypeAlias  # "from typing_extensions" in Python 3.9 and earlier

     AliasType: TypeAlias = Union[list[dict[tuple[int, str], set[int]]], tuple[str, list[str]]]

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0613/


File: Mypy.info,  Node: Named tuples,  Next: The type of class objects,  Prev: Type aliases,  Up: Kinds of types

1.6.9 Named tuples
------------------

Mypy recognizes named tuples and can type check code that defines or
uses them.  In this example, we can detect code trying to access a
missing attribute:

     Point = namedtuple('Point', ['x', 'y'])
     p = Point(x=1, y=2)
     print(p.z)  # Error: Point has no attribute 'z'

If you use namedtuple(1) to define your named tuple, all the items are
assumed to have ‘Any’ types.  That is, mypy doesn’t know anything about
item types.  You can use NamedTuple(2) to also define item types:

     from typing import NamedTuple

     Point = NamedTuple('Point', [('x', int),
                                  ('y', int)])
     p = Point(x=1, y='x')  # Argument has incompatible type "str"; expected "int"

Python 3.6 introduced an alternative, class-based syntax for named
tuples with types:

     from typing import NamedTuple

     class Point(NamedTuple):
         x: int
         y: int

     p = Point(x=1, y='x')  # Argument has incompatible type "str"; expected "int"

     Note: You can use the raw ‘NamedTuple’ “pseudo-class” in type
     annotations if any ‘NamedTuple’ object is valid.

     For example, it can be useful for deserialization:

          def deserialize_named_tuple(arg: NamedTuple) -> Dict[str, Any]:
              return arg._asdict()

          Point = namedtuple('Point', ['x', 'y'])
          Person = NamedTuple('Person', [('name', str), ('age', int)])

          deserialize_named_tuple(Point(x=1, y=2))  # ok
          deserialize_named_tuple(Person(name='Nikita', age=18))  # ok

          # Error: Argument 1 to "deserialize_named_tuple" has incompatible type
          # "Tuple[int, int]"; expected "NamedTuple"
          deserialize_named_tuple((1, 2))

     Note that this behavior is highly experimental, non-standard, and
     may not be supported by other type checkers and IDEs.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/collections.html#collections.namedtuple

   (2) https://docs.python.org/3/library/typing.html#typing.NamedTuple


File: Mypy.info,  Node: The type of class objects,  Next: Generators,  Prev: Named tuples,  Up: Kinds of types

1.6.10 The type of class objects
--------------------------------

(Freely after PEP 484: The type of class objects(1).)

Sometimes you want to talk about class objects that inherit from a given
class.  This can be spelled as ‘type[C]’ (or, on Python 3.8 and lower,
typing.Type[C](2)) where ‘C’ is a class.  In other words, when ‘C’ is
the name of a class, using ‘C’ to annotate an argument declares that the
argument is an instance of ‘C’ (or of a subclass of ‘C’), but using
‘type[C]’ as an argument annotation declares that the argument is a
class object deriving from ‘C’ (or ‘C’ itself).

For example, assume the following classes:

     class User:
         # Defines fields like name, email

     class BasicUser(User):
         def upgrade(self):
             """Upgrade to Pro"""

     class ProUser(User):
         def pay(self):
             """Pay bill"""

Note that ‘ProUser’ doesn’t inherit from ‘BasicUser’.

Here’s a function that creates an instance of one of these classes if
you pass it the right class object:

     def new_user(user_class):
         user = user_class()
         # (Here we could write the user object to a database)
         return user

How would we annotate this function?  Without the ability to
parameterize ‘type’, the best we could do would be:

     def new_user(user_class: type) -> User:
         # Same  implementation as before

This seems reasonable, except that in the following example, mypy
doesn’t see that the ‘buyer’ variable has type ‘ProUser’:

     buyer = new_user(ProUser)
     buyer.pay()  # Rejected, not a method on User

However, using the ‘type[C]’ syntax and a type variable with an upper
bound (see *note Type variables with upper bounds: 6f.) we can do
better:

     U = TypeVar('U', bound=User)

     def new_user(user_class: type[U]) -> U:
         # Same  implementation as before

Now mypy will infer the correct type of the result when we call
‘new_user()’ with a specific subclass of ‘User’:

     beginner = new_user(BasicUser)  # Inferred type is BasicUser
     beginner.upgrade()  # OK

     Note: The value corresponding to ‘type[C]’ must be an actual class
     object that’s a subtype of ‘C’.  Its constructor must be compatible
     with the constructor of ‘C’.  If ‘C’ is a type variable, its upper
     bound must be a class object.

For more details about ‘type[]’ and typing.Type[](3), see PEP 484: The
type of class objects(4).

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/#the-type-of-class-objects

   (2) https://docs.python.org/3/library/typing.html#typing.Type

   (3) https://docs.python.org/3/library/typing.html#typing.Type

   (4) https://peps.python.org/pep-0484/#the-type-of-class-objects


File: Mypy.info,  Node: Generators,  Prev: The type of class objects,  Up: Kinds of types

1.6.11 Generators
-----------------

A basic generator that only yields values can be succinctly annotated as
having a return type of either Iterator[YieldType](1) or
Iterable[YieldType](2).  For example:

     def squares(n: int) -> Iterator[int]:
         for i in range(n):
             yield i * i

A good rule of thumb is to annotate functions with the most specific
return type possible.  However, you should also take care to avoid
leaking implementation details into a function’s public API. In keeping
with these two principles, prefer Iterator[YieldType](3) over
Iterable[YieldType](4) as the return-type annotation for a generator
function, as it lets mypy know that users are able to call next()(5) on
the object returned by the function.  Nonetheless, bear in mind that
‘Iterable’ may sometimes be the better option, if you consider it an
implementation detail that ‘next()’ can be called on the object returned
by your function.

If you want your generator to accept values via the send()(6) method or
return a value, on the other hand, you should use the
Generator[YieldType, SendType, ReturnType](7) generic type instead of
either ‘Iterator’ or ‘Iterable’.  For example:

     def echo_round() -> Generator[int, float, str]:
         sent = yield 0
         while sent >= 0:
             sent = yield round(sent)
         return 'Done'

Note that unlike many other generics in the typing module, the
‘SendType’ of Generator(8) behaves contravariantly, not covariantly or
invariantly.

If you do not plan on receiving or returning values, then set the
‘SendType’ or ‘ReturnType’ to ‘None’, as appropriate.  For example, we
could have annotated the first example as the following:

     def squares(n: int) -> Generator[int, None, None]:
         for i in range(n):
             yield i * i

This is slightly different from using ‘Iterator[int]’ or
‘Iterable[int]’, since generators have close()(9), send()(10), and
throw()(11) methods that generic iterators and iterables don’t.  If you
plan to call these methods on the returned generator, use the
Generator(12) type instead of Iterator(13) or Iterable(14).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Iterator

   (2) https://docs.python.org/3/library/typing.html#typing.Iterable

   (3) https://docs.python.org/3/library/typing.html#typing.Iterator

   (4) https://docs.python.org/3/library/typing.html#typing.Iterable

   (5) https://docs.python.org/3/library/functions.html#next

   (6) 
https://docs.python.org/3/reference/expressions.html#generator.send

   (7) https://docs.python.org/3/library/typing.html#typing.Generator

   (8) https://docs.python.org/3/library/typing.html#typing.Generator

   (9) 
https://docs.python.org/3/reference/expressions.html#generator.close

   (10) 
https://docs.python.org/3/reference/expressions.html#generator.send

   (11) 
https://docs.python.org/3/reference/expressions.html#generator.throw

   (12) https://docs.python.org/3/library/typing.html#typing.Generator

   (13) https://docs.python.org/3/library/typing.html#typing.Iterator

   (14) https://docs.python.org/3/library/typing.html#typing.Iterable


File: Mypy.info,  Node: Class basics,  Next: Annotation issues at runtime,  Prev: Kinds of types,  Up: Contents

1.7 Class basics
================

This section will help get you started annotating your classes.
Built-in classes such as ‘int’ also follow these same rules.

* Menu:

* Instance and class attributes::
* Annotating __init__ methods::
* Class attribute annotations::
* Overriding statically typed methods::
* Abstract base classes and multiple inheritance::
* Slots::


File: Mypy.info,  Node: Instance and class attributes,  Next: Annotating __init__ methods,  Up: Class basics

1.7.1 Instance and class attributes
-----------------------------------

The mypy type checker detects if you are trying to access a missing
attribute, which is a very common programming error.  For this to work
correctly, instance and class attributes must be defined or initialized
within the class.  Mypy infers the types of attributes:

     class A:
         def __init__(self, x: int) -> None:
             self.x = x  # Aha, attribute 'x' of type 'int'

     a = A(1)
     a.x = 2  # OK!
     a.y = 3  # Error: "A" has no attribute "y"

This is a bit like each class having an implicitly defined __slots__(1)
attribute.  This is only enforced during type checking and not when your
program is running.

You can declare types of variables in the class body explicitly using a
type annotation:

     class A:
         x: list[int]  # Declare attribute 'x' of type list[int]

     a = A()
     a.x = [1]     # OK

As in Python generally, a variable defined in the class body can be used
as a class or an instance variable.  (As discussed in the next section,
you can override this with a ClassVar(2) annotation.)

Similarly, you can give explicit types to instance variables defined in
a method:

     class A:
         def __init__(self) -> None:
             self.x: list[int] = []

         def f(self) -> None:
             self.y: Any = 0

You can only define an instance variable within a method if you assign
to it explicitly using ‘self’:

     class A:
         def __init__(self) -> None:
             self.y = 1   # Define 'y'
             a = self
             a.x = 1      # Error: 'x' not defined

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__slots__

   (2) https://docs.python.org/3/library/typing.html#typing.ClassVar


File: Mypy.info,  Node: Annotating __init__ methods,  Next: Class attribute annotations,  Prev: Instance and class attributes,  Up: Class basics

1.7.2 Annotating __init__ methods
---------------------------------

The __init__(1) method is somewhat special – it doesn’t return a value.
This is best expressed as ‘-> None’.  However, since many feel this is
redundant, it is allowed to omit the return type declaration on
__init__(2) methods ‘if at least one argument is annotated’.  For
example, in the following classes __init__(3) is considered fully
annotated:

     class C1:
         def __init__(self) -> None:
             self.var = 42

     class C2:
         def __init__(self, arg: int):
             self.var = arg

However, if __init__(4) has no annotated arguments and no return type
annotation, it is considered an untyped method:

     class C3:
         def __init__(self):
             # This body is not type checked
             self.var = 42 + 'abc'

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (2) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (3) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (4) 
https://docs.python.org/3/reference/datamodel.html#object.__init__


File: Mypy.info,  Node: Class attribute annotations,  Next: Overriding statically typed methods,  Prev: Annotating __init__ methods,  Up: Class basics

1.7.3 Class attribute annotations
---------------------------------

You can use a ClassVar[t](1) annotation to explicitly declare that a
particular attribute should not be set on instances:

     from typing import ClassVar

     class A:
         x: ClassVar[int] = 0  # Class variable only

     A.x += 1  # OK

     a = A()
     a.x = 1  # Error: Cannot assign to class variable "x" via instance
     print(a.x)  # OK -- can be read through an instance

It’s not necessary to annotate all class variables using ClassVar(2).
An attribute without the ClassVar(3) annotation can still be used as a
class variable.  However, mypy won’t prevent it from being used as an
instance variable, as discussed previously:

     class A:
         x = 0  # Can be used as a class or instance variable

     A.x += 1  # OK

     a = A()
     a.x = 1  # Also OK

Note that ClassVar(4) is not a class, and you can’t use it with
isinstance()(5) or issubclass()(6).  It does not change Python runtime
behavior – it’s only for type checkers such as mypy (and also helpful
for human readers).

You can also omit the square brackets and the variable type in a
ClassVar(7) annotation, but this might not do what you’d expect:

     class A:
         y: ClassVar = 0  # Type implicitly Any!

In this case the type of the attribute will be implicitly ‘Any’.  This
behavior will change in the future, since it’s surprising.

An explicit ClassVar(8) may be particularly handy to distinguish between
class and instance variables with callable types.  For example:

     from typing import Callable, ClassVar

     class A:
         foo: Callable[[int], None]
         bar: ClassVar[Callable[[A, int], None]]
         bad: Callable[[A], None]

     A().foo(42)  # OK
     A().bar(42)  # OK
     A().bad()  # Error: Too few arguments

     Note: A ClassVar(9) type parameter cannot include type variables:
     ‘ClassVar[T]’ and ‘ClassVar[list[T]]’ are both invalid if ‘T’ is a
     type variable (see *note Defining generic classes: 77. for more
     about type variables).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (2) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (3) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (4) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (5) https://docs.python.org/3/library/functions.html#isinstance

   (6) https://docs.python.org/3/library/functions.html#issubclass

   (7) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (8) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (9) https://docs.python.org/3/library/typing.html#typing.ClassVar


File: Mypy.info,  Node: Overriding statically typed methods,  Next: Abstract base classes and multiple inheritance,  Prev: Class attribute annotations,  Up: Class basics

1.7.4 Overriding statically typed methods
-----------------------------------------

When overriding a statically typed method, mypy checks that the override
has a compatible signature:

     class Base:
         def f(self, x: int) -> None:
             ...

     class Derived1(Base):
         def f(self, x: str) -> None:   # Error: type of 'x' incompatible
             ...

     class Derived2(Base):
         def f(self, x: int, y: int) -> None:  # Error: too many arguments
             ...

     class Derived3(Base):
         def f(self, x: int) -> None:   # OK
             ...

     class Derived4(Base):
         def f(self, x: float) -> None:   # OK: mypy treats int as a subtype of float
             ...

     class Derived5(Base):
         def f(self, x: int, y: int = 0) -> None:   # OK: accepts more than the base
             ...                                    #     class method

     Note: You can also vary return types ‘covariantly’ in overriding.
     For example, you could override the return type ‘Iterable[int]’
     with a subtype such as ‘list[int]’.  Similarly, you can vary
     argument types ‘contravariantly’ – subclasses can have more general
     argument types.

You can also override a statically typed method with a dynamically typed
one.  This allows dynamically typed code to override methods defined in
library classes without worrying about their type signatures.

As always, relying on dynamically typed code can be unsafe.  There is no
runtime enforcement that the method override returns a value that is
compatible with the original return type, since annotations have no
effect at runtime:

     class Base:
         def inc(self, x: int) -> int:
             return x + 1

     class Derived(Base):
         def inc(self, x):   # Override, dynamically typed
             return 'hello'  # Incompatible with 'Base', but no mypy error


File: Mypy.info,  Node: Abstract base classes and multiple inheritance,  Next: Slots,  Prev: Overriding statically typed methods,  Up: Class basics

1.7.5 Abstract base classes and multiple inheritance
----------------------------------------------------

Mypy supports Python abstract base classes (ABCs).  Abstract classes
have at least one abstract method or property that must be implemented
by any ‘concrete’ (non-abstract) subclass.  You can define abstract base
classes using the abc.ABCMeta(1) metaclass and the
@abc.abstractmethod(2) function decorator.  Example:

     from abc import ABCMeta, abstractmethod

     class Animal(metaclass=ABCMeta):
         @abstractmethod
         def eat(self, food: str) -> None: pass

         @property
         @abstractmethod
         def can_walk(self) -> bool: pass

     class Cat(Animal):
         def eat(self, food: str) -> None:
             ...  # Body omitted

         @property
         def can_walk(self) -> bool:
             return True

     x = Animal()  # Error: 'Animal' is abstract due to 'eat' and 'can_walk'
     y = Cat()     # OK

Note that mypy performs checking for unimplemented abstract methods even
if you omit the ABCMeta(3) metaclass.  This can be useful if the
metaclass would cause runtime metaclass conflicts.

Since you can’t create instances of ABCs, they are most commonly used in
type annotations.  For example, this method accepts arbitrary iterables
containing arbitrary animals (instances of concrete ‘Animal’
subclasses):

     def feed_all(animals: Iterable[Animal], food: str) -> None:
         for animal in animals:
             animal.eat(food)

There is one important peculiarity about how ABCs work in Python –
whether a particular class is abstract or not is somewhat implicit.  In
the example below, ‘Derived’ is treated as an abstract base class since
‘Derived’ inherits an abstract ‘f’ method from ‘Base’ and doesn’t
explicitly implement it.  The definition of ‘Derived’ generates no
errors from mypy, since it’s a valid ABC:

     from abc import ABCMeta, abstractmethod

     class Base(metaclass=ABCMeta):
         @abstractmethod
         def f(self, x: int) -> None: pass

     class Derived(Base):  # No error -- Derived is implicitly abstract
         def g(self) -> None:
             ...

Attempting to create an instance of ‘Derived’ will be rejected, however:

     d = Derived()  # Error: 'Derived' is abstract

     Note: It’s a common error to forget to implement an abstract
     method.  As shown above, the class definition will not generate an
     error in this case, but any attempt to construct an instance will
     be flagged as an error.

Mypy allows you to omit the body for an abstract method, but if you do
so, it is unsafe to call such method via ‘super()’.  For example:

     from abc import abstractmethod
     class Base:
         @abstractmethod
         def foo(self) -> int: pass
         @abstractmethod
         def bar(self) -> int:
             return 0
     class Sub(Base):
         def foo(self) -> int:
             return super().foo() + 1  # error: Call to abstract method "foo" of "Base"
                                       # with trivial body via super() is unsafe
         @abstractmethod
         def bar(self) -> int:
             return super().bar() + 1  # This is OK however.

A class can inherit any number of classes, both abstract and concrete.
As with normal overrides, a dynamically typed method can override or
implement a statically typed method defined in any base class, including
an abstract method defined in an abstract base class.

You can implement an abstract property using either a normal property or
an instance variable.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/abc.html#abc.ABCMeta

   (2) https://docs.python.org/3/library/abc.html#abc.abstractmethod

   (3) https://docs.python.org/3/library/abc.html#abc.ABCMeta


File: Mypy.info,  Node: Slots,  Prev: Abstract base classes and multiple inheritance,  Up: Class basics

1.7.6 Slots
-----------

When a class has explicitly defined __slots__(1), mypy will check that
all attributes assigned to are members of ‘__slots__’:

     class Album:
         __slots__ = ('name', 'year')

         def __init__(self, name: str, year: int) -> None:
            self.name = name
            self.year = year
            # Error: Trying to assign name "released" that is not in "__slots__" of type "Album"
            self.released = True

     my_album = Album('Songs about Python', 2021)

Mypy will only check attribute assignments against ‘__slots__’ when the
following conditions hold:

  1. All base classes (except builtin ones) must have explicit
     ‘__slots__’ defined (this mirrors Python semantics).

  2. ‘__slots__’ does not include ‘__dict__’.  If ‘__slots__’ includes
     ‘__dict__’, arbitrary attributes can be set, similar to when
     ‘__slots__’ is not defined (this mirrors Python semantics).

  3. All values in ‘__slots__’ must be string literals.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/reference/datamodel.html#slots


File: Mypy.info,  Node: Annotation issues at runtime,  Next: Protocols and structural subtyping,  Prev: Class basics,  Up: Contents

1.8 Annotation issues at runtime
================================

Idiomatic use of type annotations can sometimes run up against what a
given version of Python considers legal code.  This section describes
these scenarios and explains how to get your code running again.
Generally speaking, we have three tools at our disposal:

   * Use of ‘from __future__ import annotations’ ( PEP 563(1)) (this
     behaviour may eventually be made the default in a future Python
     version)

   * Use of string literal types or type comments

   * Use of ‘typing.TYPE_CHECKING’

We provide a description of these before moving onto discussion of
specific problems you may encounter.

* Menu:

* String literal types and type comments::
* Future annotations import (PEP 563): Future annotations import PEP 563.
* typing.TYPE_CHECKING: typing TYPE_CHECKING.
* Class name forward references::
* Import cycles::
* Using classes that are generic in stubs but not at runtime::
* Using types defined in stubs but not at runtime::
* Using generic builtins::
* Using X | Y syntax for Unions::
* Using new additions to the typing module::

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0563/


File: Mypy.info,  Node: String literal types and type comments,  Next: Future annotations import PEP 563,  Up: Annotation issues at runtime

1.8.1 String literal types and type comments
--------------------------------------------

Mypy allows you to add type annotations using ‘# type:’ type comments.
For example:

     a = 1  # type: int

     def f(x):  # type: (int) -> int
         return x + 1

     # Alternative type comment syntax for functions with many arguments
     def send_email(
          address,     # type: Union[str, List[str]]
          sender,      # type: str
          cc,          # type: Optional[List[str]]
          subject='',
          body=None    # type: List[str]
     ):
         # type: (...) -> bool

Type comments can’t cause runtime errors because comments are not
evaluated by Python.

In a similar way, using string literal types sidesteps the problem of
annotations that would cause runtime errors.

Any type can be entered as a string literal, and you can combine
string-literal types with non-string-literal types freely:

     def f(a: list['A']) -> None: ...  # OK, prevents NameError since A is defined later
     def g(n: 'int') -> None: ...      # Also OK, though not useful

     class A: pass

String literal types are never needed in ‘# type:’ comments and *note
stub files: 15.

String literal types must be defined (or imported) later ‘in the same
module’.  They cannot be used to leave cross-module references
unresolved.  (For dealing with import cycles, see *note Import cycles:
7f.)


File: Mypy.info,  Node: Future annotations import PEP 563,  Next: typing TYPE_CHECKING,  Prev: String literal types and type comments,  Up: Annotation issues at runtime

1.8.2 Future annotations import (PEP 563)
-----------------------------------------

Many of the issues described here are caused by Python trying to
evaluate annotations.  Future Python versions (potentially Python 3.12)
will by default no longer attempt to evaluate function and variable
annotations.  This behaviour is made available in Python 3.7 and later
through the use of ‘from __future__ import annotations’.

This can be thought of as automatic string literal-ification of all
function and variable annotations.  Note that function and variable
annotations are still required to be valid Python syntax.  For more
details, see PEP 563(1).

     Note: Even with the ‘__future__’ import, there are some scenarios
     that could still require string literals or result in errors,
     typically involving use of forward references or generics in:

        * *note type aliases: 6a.;

        * *note type narrowing: 82.;

        * type definitions (see TypeVar(2), ‘NewType()’, NamedTuple(3));

        * base classes.

          # base class example
          from __future__ import annotations
          class A(tuple['B', 'C']): ... # String literal types needed here
          class B: ...
          class C: ...

     Warning: Some libraries may have use cases for dynamic evaluation
     of annotations, for instance, through use of
     ‘typing.get_type_hints’ or ‘eval’.  If your annotation would raise
     an error when evaluated (say by using PEP 604(4) syntax with Python
     3.9), you may need to be careful when using such libraries.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0563/

   (2) https://docs.python.org/3/library/typing.html#typing.TypeVar

   (3) https://docs.python.org/3/library/typing.html#typing.NamedTuple

   (4) https://peps.python.org/pep-0604/


File: Mypy.info,  Node: typing TYPE_CHECKING,  Next: Class name forward references,  Prev: Future annotations import PEP 563,  Up: Annotation issues at runtime

1.8.3 typing.TYPE_CHECKING
--------------------------

The typing(1) module defines a TYPE_CHECKING(2) constant that is ‘False’
at runtime but treated as ‘True’ while type checking.

Since code inside ‘if TYPE_CHECKING:’ is not executed at runtime, it
provides a convenient way to tell mypy something without the code being
evaluated at runtime.  This is most useful for resolving *note import
cycles: 7f.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing

   (2) 
https://docs.python.org/3/library/typing.html#typing.TYPE_CHECKING


File: Mypy.info,  Node: Class name forward references,  Next: Import cycles,  Prev: typing TYPE_CHECKING,  Up: Annotation issues at runtime

1.8.4 Class name forward references
-----------------------------------

Python does not allow references to a class object before the class is
defined (aka forward reference).  Thus this code does not work as
expected:

     def f(x: A) -> None: ...  # NameError: name "A" is not defined
     class A: ...

Starting from Python 3.7, you can add ‘from __future__ import
annotations’ to resolve this, as discussed earlier:

     from __future__ import annotations

     def f(x: A) -> None: ...  # OK
     class A: ...

For Python 3.6 and below, you can enter the type as a string literal or
type comment:

     def f(x: 'A') -> None: ...  # OK

     # Also OK
     def g(x):  # type: (A) -> None
         ...

     class A: ...

Of course, instead of using future annotations import or string literal
types, you could move the function definition after the class
definition.  This is not always desirable or even possible, though.


File: Mypy.info,  Node: Import cycles,  Next: Using classes that are generic in stubs but not at runtime,  Prev: Class name forward references,  Up: Annotation issues at runtime

1.8.5 Import cycles
-------------------

An import cycle occurs where module A imports module B and module B
imports module A (perhaps indirectly, e.g.  ‘A -> B -> C -> A’).
Sometimes in order to add type annotations you have to add extra imports
to a module and those imports cause cycles that didn’t exist before.
This can lead to errors at runtime like:

     ImportError: cannot import name 'b' from partially initialized module 'A' (most likely due to a circular import)

If those cycles do become a problem when running your program, there’s a
trick: if the import is only needed for type annotations and you’re
using a) the *note future annotations import: 80, or b) string literals
or type comments for the relevant annotations, you can write the imports
inside ‘if TYPE_CHECKING:’ so that they are not executed at runtime.
Example:

File ‘foo.py’:

     from typing import TYPE_CHECKING

     if TYPE_CHECKING:
         import bar

     def listify(arg: 'bar.BarClass') -> 'list[bar.BarClass]':
         return [arg]

File ‘bar.py’:

     from foo import listify

     class BarClass:
         def listifyme(self) -> 'list[BarClass]':
             return listify(self)


File: Mypy.info,  Node: Using classes that are generic in stubs but not at runtime,  Next: Using types defined in stubs but not at runtime,  Prev: Import cycles,  Up: Annotation issues at runtime

1.8.6 Using classes that are generic in stubs but not at runtime
----------------------------------------------------------------

Some classes are declared as *note generic: 77. in stubs, but not at
runtime.

In Python 3.8 and earlier, there are several examples within the
standard library, for instance, os.PathLike(1) and queue.Queue(2).
Subscripting such a class will result in a runtime error:

     from queue import Queue

     class Tasks(Queue[str]):  # TypeError: 'type' object is not subscriptable
         ...

     results: Queue[int] = Queue()  # TypeError: 'type' object is not subscriptable

To avoid errors from use of these generics in annotations, just use the
*note future annotations import: 80. (or string literals or type
comments for Python 3.6 and below).

To avoid errors when inheriting from these classes, things are a little
more complicated and you need to use *note typing.TYPE_CHECKING: 84.:

     from typing import TYPE_CHECKING
     from queue import Queue

     if TYPE_CHECKING:
         BaseQueue = Queue[str]  # this is only processed by mypy
     else:
         BaseQueue = Queue  # this is not seen by mypy but will be executed at runtime

     class Tasks(BaseQueue):  # OK
         ...

     task_queue: Tasks
     reveal_type(task_queue.get())  # Reveals str

If your subclass is also generic, you can use the following:

     from typing import TYPE_CHECKING, TypeVar, Generic
     from queue import Queue

     _T = TypeVar("_T")
     if TYPE_CHECKING:
         class _MyQueueBase(Queue[_T]): pass
     else:
         class _MyQueueBase(Generic[_T], Queue): pass

     class MyQueue(_MyQueueBase[_T]): pass

     task_queue: MyQueue[str]
     reveal_type(task_queue.get())  # Reveals str

In Python 3.9, we can just inherit directly from ‘Queue[str]’ or
‘Queue[T]’ since its queue.Queue(3) implements ‘__class_getitem__()’, so
the class object can be subscripted at runtime without issue.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/os.html#os.PathLike

   (2) https://docs.python.org/3/library/queue.html#queue.Queue

   (3) https://docs.python.org/3/library/queue.html#queue.Queue


File: Mypy.info,  Node: Using types defined in stubs but not at runtime,  Next: Using generic builtins,  Prev: Using classes that are generic in stubs but not at runtime,  Up: Annotation issues at runtime

1.8.7 Using types defined in stubs but not at runtime
-----------------------------------------------------

Sometimes stubs that you’re using may define types you wish to re-use
that do not exist at runtime.  Importing these types naively will cause
your code to fail at runtime with ‘ImportError’ or
‘ModuleNotFoundError’.  Similar to previous sections, these can be dealt
with by using *note typing.TYPE_CHECKING: 84.:

     from typing import TYPE_CHECKING
     if TYPE_CHECKING:
         from _typeshed import SupportsRichComparison


File: Mypy.info,  Node: Using generic builtins,  Next: Using X | Y syntax for Unions,  Prev: Using types defined in stubs but not at runtime,  Up: Annotation issues at runtime

1.8.8 Using generic builtins
----------------------------

Starting with Python 3.9 ( PEP 585(1)), the type objects of many
collections in the standard library support subscription at runtime.
This means that you no longer have to import the equivalents from
typing(2); you can simply use the built-in collections or those from
collections.abc(3):

     from collections.abc import Sequence
     x: list[str]
     y: dict[int, str]
     z: Sequence[str] = x

There is limited support for using this syntax in Python 3.7 and later
as well: if you use ‘from __future__ import annotations’, mypy will
understand this syntax in annotations.  However, since this will not be
supported by the Python interpreter at runtime, make sure you’re aware
of the caveats mentioned in the notes at *note future annotations
import: 80.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0585/

   (2) https://docs.python.org/3/library/typing.html#module-typing

   (3) 
https://docs.python.org/3/library/collections.abc.html#module-collections.abc


File: Mypy.info,  Node: Using X | Y syntax for Unions,  Next: Using new additions to the typing module,  Prev: Using generic builtins,  Up: Annotation issues at runtime

1.8.9 Using X | Y syntax for Unions
-----------------------------------

Starting with Python 3.10 ( PEP 604(1)), you can spell union types as
‘x: int | str’, instead of ‘x: typing.Union[int, str]’.

There is limited support for using this syntax in Python 3.7 and later
as well: if you use ‘from __future__ import annotations’, mypy will
understand this syntax in annotations, string literal types, type
comments and stub files.  However, since this will not be supported by
the Python interpreter at runtime (if evaluated, ‘int | str’ will raise
‘TypeError: unsupported operand type(s) for |: 'type' and 'type'’), make
sure you’re aware of the caveats mentioned in the notes at *note future
annotations import: 80.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0604/


File: Mypy.info,  Node: Using new additions to the typing module,  Prev: Using X | Y syntax for Unions,  Up: Annotation issues at runtime

1.8.10 Using new additions to the typing module
-----------------------------------------------

You may find yourself wanting to use features added to the typing(1)
module in earlier versions of Python than the addition, for example,
using any of ‘Literal’, ‘Protocol’, ‘TypedDict’ with Python 3.6.

The easiest way to do this is to install and use the ‘typing_extensions’
package from PyPI for the relevant imports, for example:

     from typing_extensions import Literal
     x: Literal["open", "close"]

If you don’t want to rely on ‘typing_extensions’ being installed on
newer Pythons, you could alternatively use:

     import sys
     if sys.version_info >= (3, 8):
         from typing import Literal
     else:
         from typing_extensions import Literal

     x: Literal["open", "close"]

This plays nicely well with following PEP 508(2) dependency
specification: ‘typing_extensions; python_version<"3.8"’

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing

   (2) https://peps.python.org/pep-0508/


File: Mypy.info,  Node: Protocols and structural subtyping,  Next: Dynamically typed code,  Prev: Annotation issues at runtime,  Up: Contents

1.9 Protocols and structural subtyping
======================================

Mypy supports two ways of deciding whether two classes are compatible as
types: nominal subtyping and structural subtyping.  ‘Nominal’ subtyping
is strictly based on the class hierarchy.  If class ‘D’ inherits class
‘C’, it’s also a subtype of ‘C’, and instances of ‘D’ can be used when
‘C’ instances are expected.  This form of subtyping is used by default
in mypy, since it’s easy to understand and produces clear and concise
error messages, and since it matches how the native isinstance(1) check
works – based on class hierarchy.  ‘Structural’ subtyping can also be
useful.  Class ‘D’ is a structural subtype of class ‘C’ if the former
has all attributes and methods of the latter, and with compatible types.

Structural subtyping can be seen as a static equivalent of duck typing,
which is well known to Python programmers.  Mypy provides support for
structural subtyping via protocol classes described below.  See PEP
544(2) for the detailed specification of protocols and structural
subtyping in Python.

* Menu:

* Predefined protocols::
* Simple user-defined protocols::
* Defining subprotocols and subclassing protocols::
* Recursive protocols::
* Using isinstance() with protocols: Using isinstance with protocols.
* Callback protocols::
* Predefined protocol reference::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance

   (2) https://peps.python.org/pep-0544/


File: Mypy.info,  Node: Predefined protocols,  Next: Simple user-defined protocols,  Up: Protocols and structural subtyping

1.9.1 Predefined protocols
--------------------------

The typing(1) module defines various protocol classes that correspond to
common Python protocols, such as Iterable[T](2). If a class defines a
suitable __iter__(3) method, mypy understands that it implements the
iterable protocol and is compatible with Iterable[T](4). For example,
‘IntList’ below is iterable, over ‘int’ values:

     from typing import Iterator, Iterable, Optional

     class IntList:
         def __init__(self, value: int, next: Optional['IntList']) -> None:
             self.value = value
             self.next = next

         def __iter__(self) -> Iterator[int]:
             current = self
             while current:
                 yield current.value
                 current = current.next

     def print_numbered(items: Iterable[int]) -> None:
         for n, x in enumerate(items):
             print(n + 1, x)

     x = IntList(3, IntList(5, None))
     print_numbered(x)  # OK
     print_numbered([4, 5])  # Also OK

*note Predefined protocol reference: 91. lists all protocols defined in
typing(5) and the signatures of the corresponding methods you need to
define to implement each protocol (the signatures can be left out, as
always, but mypy won’t type check unannotated methods).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing

   (2) https://docs.python.org/3/library/typing.html#typing.Iterable

   (3) 
https://docs.python.org/3/reference/datamodel.html#object.__iter__

   (4) https://docs.python.org/3/library/typing.html#typing.Iterable

   (5) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Simple user-defined protocols,  Next: Defining subprotocols and subclassing protocols,  Prev: Predefined protocols,  Up: Protocols and structural subtyping

1.9.2 Simple user-defined protocols
-----------------------------------

You can define your own protocol class by inheriting the special
‘Protocol’ class:

     from typing import Iterable
     from typing_extensions import Protocol

     class SupportsClose(Protocol):
         def close(self) -> None:
            ...  # Empty method body (explicit '...')

     class Resource:  # No SupportsClose base class!
         # ... some methods ...

         def close(self) -> None:
            self.resource.release()

     def close_all(items: Iterable[SupportsClose]) -> None:
         for item in items:
             item.close()

     close_all([Resource(), open('some/file')])  # Okay!

‘Resource’ is a subtype of the ‘SupportsClose’ protocol since it defines
a compatible ‘close’ method.  Regular file objects returned by open()(1)
are similarly compatible with the protocol, as they support ‘close()’.

     Note: The ‘Protocol’ base class is provided in the
     ‘typing_extensions’ package for Python 3.4-3.7.  Starting with
     Python 3.8, ‘Protocol’ is included in the ‘typing’ module.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#open


File: Mypy.info,  Node: Defining subprotocols and subclassing protocols,  Next: Recursive protocols,  Prev: Simple user-defined protocols,  Up: Protocols and structural subtyping

1.9.3 Defining subprotocols and subclassing protocols
-----------------------------------------------------

You can also define subprotocols.  Existing protocols can be extended
and merged using multiple inheritance.  Example:

     # ... continuing from the previous example

     class SupportsRead(Protocol):
         def read(self, amount: int) -> bytes: ...

     class TaggedReadableResource(SupportsClose, SupportsRead, Protocol):
         label: str

     class AdvancedResource(Resource):
         def __init__(self, label: str) -> None:
             self.label = label

         def read(self, amount: int) -> bytes:
             # some implementation
             ...

     resource: TaggedReadableResource
     resource = AdvancedResource('handle with care')  # OK

Note that inheriting from an existing protocol does not automatically
turn the subclass into a protocol – it just creates a regular
(non-protocol) class or ABC that implements the given protocol (or
protocols).  The ‘Protocol’ base class must always be explicitly present
if you are defining a protocol:

     class NotAProtocol(SupportsClose):  # This is NOT a protocol
         new_attr: int

     class Concrete:
        new_attr: int = 0

        def close(self) -> None:
            ...

     # Error: nominal subtyping used by default
     x: NotAProtocol = Concrete()  # Error!

You can also include default implementations of methods in protocols.
If you explicitly subclass these protocols you can inherit these default
implementations.  Explicitly including a protocol as a base class is
also a way of documenting that your class implements a particular
protocol, and it forces mypy to verify that your class implementation is
actually compatible with the protocol.  In particular, omitting a value
for an attribute or a method body will make it implicitly abstract:

     class SomeProto(Protocol):
         attr: int  # Note, no right hand side
         def method(self) -> str: ...  # Literal ... here
     class ExplicitSubclass(SomeProto):
         pass
     ExplicitSubclass()  # error: Cannot instantiate abstract class 'ExplicitSubclass'
                         # with abstract attributes 'attr' and 'method'


File: Mypy.info,  Node: Recursive protocols,  Next: Using isinstance with protocols,  Prev: Defining subprotocols and subclassing protocols,  Up: Protocols and structural subtyping

1.9.4 Recursive protocols
-------------------------

Protocols can be recursive (self-referential) and mutually recursive.
This is useful for declaring abstract recursive collections such as
trees and linked lists:

     from typing import TypeVar, Optional
     from typing_extensions import Protocol

     class TreeLike(Protocol):
         value: int

         @property
         def left(self) -> Optional['TreeLike']: ...

         @property
         def right(self) -> Optional['TreeLike']: ...

     class SimpleTree:
         def __init__(self, value: int) -> None:
             self.value = value
             self.left: Optional['SimpleTree'] = None
             self.right: Optional['SimpleTree'] = None

     root: TreeLike = SimpleTree(0)  # OK


File: Mypy.info,  Node: Using isinstance with protocols,  Next: Callback protocols,  Prev: Recursive protocols,  Up: Protocols and structural subtyping

1.9.5 Using isinstance() with protocols
---------------------------------------

You can use a protocol class with isinstance()(1) if you decorate it
with the ‘@runtime_checkable’ class decorator.  The decorator adds
support for basic runtime structural checks:

     from typing_extensions import Protocol, runtime_checkable

     @runtime_checkable
     class Portable(Protocol):
         handles: int

     class Mug:
         def __init__(self) -> None:
             self.handles = 1

     def use(handles: int) -> None: ...

     mug = Mug()
     if isinstance(mug, Portable):
        use(mug.handles)  # Works statically and at runtime

isinstance()(2) also works with the *note predefined protocols: 90. in
typing(3) such as Iterable(4).

     Note: isinstance()(5) with protocols is not completely safe at
     runtime.  For example, signatures of methods are not checked.  The
     runtime implementation only checks that all protocol members are
     defined.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance

   (2) https://docs.python.org/3/library/functions.html#isinstance

   (3) https://docs.python.org/3/library/typing.html#module-typing

   (4) https://docs.python.org/3/library/typing.html#typing.Iterable

   (5) https://docs.python.org/3/library/functions.html#isinstance


File: Mypy.info,  Node: Callback protocols,  Next: Predefined protocol reference,  Prev: Using isinstance with protocols,  Up: Protocols and structural subtyping

1.9.6 Callback protocols
------------------------

Protocols can be used to define flexible callback types that are hard
(or even impossible) to express using the Callable[...](1)  syntax, such
as variadic, overloaded, and complex generic callbacks.  They are
defined with a special __call__(2) member:

     from typing import Optional, Iterable
     from typing_extensions import Protocol

     class Combiner(Protocol):
         def __call__(self, *vals: bytes, maxlen: Optional[int] = None) -> list[bytes]: ...

     def batch_proc(data: Iterable[bytes], cb_results: Combiner) -> bytes:
         for item in data:
             ...

     def good_cb(*vals: bytes, maxlen: Optional[int] = None) -> list[bytes]:
         ...
     def bad_cb(*vals: bytes, maxitems: Optional[int]) -> list[bytes]:
         ...

     batch_proc([], good_cb)  # OK
     batch_proc([], bad_cb)   # Error! Argument 2 has incompatible type because of
                              # different name and kind in the callback

Callback protocols and Callable(3) types can be used interchangeably.
Argument names in __call__(4) methods must be identical, unless a double
underscore prefix is used.  For example:

     from typing import Callable, TypeVar
     from typing_extensions import Protocol

     T = TypeVar('T')

     class Copy(Protocol):
         def __call__(self, __origin: T) -> T: ...

     copy_a: Callable[[T], T]
     copy_b: Copy

     copy_a = copy_b  # OK
     copy_b = copy_a  # Also OK

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Callable

   (2) 
https://docs.python.org/3/reference/datamodel.html#object.__call__

   (3) https://docs.python.org/3/library/typing.html#typing.Callable

   (4) 
https://docs.python.org/3/reference/datamodel.html#object.__call__


File: Mypy.info,  Node: Predefined protocol reference,  Prev: Callback protocols,  Up: Protocols and structural subtyping

1.9.7 Predefined protocol reference
-----------------------------------

* Menu:

* Iteration protocols::
* Collection protocols::
* One-off protocols::
* Async protocols::
* Context manager protocols::


File: Mypy.info,  Node: Iteration protocols,  Next: Collection protocols,  Up: Predefined protocol reference

1.9.7.1 Iteration protocols
...........................

The iteration protocols are useful in many contexts.  For example, they
allow iteration of objects in for loops.

* Menu:

* Iterable[T]::
* Iterator[T]::


File: Mypy.info,  Node: Iterable[T],  Next: Iterator[T],  Up: Iteration protocols

1.9.7.2 Iterable[T]
...................

The *note example above: 90. has a simple implementation of an
__iter__(1) method.

     def __iter__(self) -> Iterator[T]

See also Iterable(2).

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__iter__

   (2) https://docs.python.org/3/library/typing.html#typing.Iterable


File: Mypy.info,  Node: Iterator[T],  Prev: Iterable[T],  Up: Iteration protocols

1.9.7.3 Iterator[T]
...................

     def __next__(self) -> T
     def __iter__(self) -> Iterator[T]

See also Iterator(1).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Iterator


File: Mypy.info,  Node: Collection protocols,  Next: One-off protocols,  Prev: Iteration protocols,  Up: Predefined protocol reference

1.9.7.4 Collection protocols
............................

Many of these are implemented by built-in container types such as
list(1) and dict(2), and these are also useful for user-defined
collection objects.

* Menu:

* Sized::
* Container[T]::
* Collection[T]::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#list

   (2) https://docs.python.org/3/library/stdtypes.html#dict


File: Mypy.info,  Node: Sized,  Next: Container[T],  Up: Collection protocols

1.9.7.5 Sized
.............

This is a type for objects that support len(x)(1).

     def __len__(self) -> int

See also Sized(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#len

   (2) https://docs.python.org/3/library/typing.html#typing.Sized


File: Mypy.info,  Node: Container[T],  Next: Collection[T],  Prev: Sized,  Up: Collection protocols

1.9.7.6 Container[T]
....................

This is a type for objects that support the ‘in’ operator.

     def __contains__(self, x: object) -> bool

See also Container(1).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Container


File: Mypy.info,  Node: Collection[T],  Prev: Container[T],  Up: Collection protocols

1.9.7.7 Collection[T]
.....................

     def __len__(self) -> int
     def __iter__(self) -> Iterator[T]
     def __contains__(self, x: object) -> bool

See also Collection(1).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Collection


File: Mypy.info,  Node: One-off protocols,  Next: Async protocols,  Prev: Collection protocols,  Up: Predefined protocol reference

1.9.7.8 One-off protocols
.........................

These protocols are typically only useful with a single standard library
function or class.

* Menu:

* Reversible[T]::
* SupportsAbs[T]::
* SupportsBytes::
* SupportsComplex::
* SupportsFloat::
* SupportsInt::
* SupportsRound[T]::


File: Mypy.info,  Node: Reversible[T],  Next: SupportsAbs[T],  Up: One-off protocols

1.9.7.9 Reversible[T]
.....................

This is a type for objects that support reversed(x)(1).

     def __reversed__(self) -> Iterator[T]

See also Reversible(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#reversed

   (2) https://docs.python.org/3/library/typing.html#typing.Reversible


File: Mypy.info,  Node: SupportsAbs[T],  Next: SupportsBytes,  Prev: Reversible[T],  Up: One-off protocols

1.9.7.10 SupportsAbs[T]
.......................

This is a type for objects that support abs(x)(1).  ‘T’ is the type of
value returned by abs(x)(2).

     def __abs__(self) -> T

See also SupportsAbs(3).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#abs

   (2) https://docs.python.org/3/library/functions.html#abs

   (3) https://docs.python.org/3/library/typing.html#typing.SupportsAbs


File: Mypy.info,  Node: SupportsBytes,  Next: SupportsComplex,  Prev: SupportsAbs[T],  Up: One-off protocols

1.9.7.11 SupportsBytes
......................

This is a type for objects that support bytes(x)(1).

     def __bytes__(self) -> bytes

See also SupportsBytes(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#bytes

   (2) 
https://docs.python.org/3/library/typing.html#typing.SupportsBytes


File: Mypy.info,  Node: SupportsComplex,  Next: SupportsFloat,  Prev: SupportsBytes,  Up: One-off protocols

1.9.7.12 SupportsComplex
........................

This is a type for objects that support complex(x)(1).  Note that no
arithmetic operations are supported.

     def __complex__(self) -> complex

See also SupportsComplex(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#complex

   (2) 
https://docs.python.org/3/library/typing.html#typing.SupportsComplex


File: Mypy.info,  Node: SupportsFloat,  Next: SupportsInt,  Prev: SupportsComplex,  Up: One-off protocols

1.9.7.13 SupportsFloat
......................

This is a type for objects that support float(x)(1).  Note that no
arithmetic operations are supported.

     def __float__(self) -> float

See also SupportsFloat(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#float

   (2) 
https://docs.python.org/3/library/typing.html#typing.SupportsFloat


File: Mypy.info,  Node: SupportsInt,  Next: SupportsRound[T],  Prev: SupportsFloat,  Up: One-off protocols

1.9.7.14 SupportsInt
....................

This is a type for objects that support int(x)(1).  Note that no
arithmetic operations are supported.

     def __int__(self) -> int

See also SupportsInt(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#int

   (2) https://docs.python.org/3/library/typing.html#typing.SupportsInt


File: Mypy.info,  Node: SupportsRound[T],  Prev: SupportsInt,  Up: One-off protocols

1.9.7.15 SupportsRound[T]
.........................

This is a type for objects that support round(x)(1).

     def __round__(self) -> T

See also SupportsRound(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#round

   (2) 
https://docs.python.org/3/library/typing.html#typing.SupportsRound


File: Mypy.info,  Node: Async protocols,  Next: Context manager protocols,  Prev: One-off protocols,  Up: Predefined protocol reference

1.9.7.16 Async protocols
........................

These protocols can be useful in async code.  See *note Typing
async/await: 3d. for more information.

* Menu:

* Awaitable[T]::
* AsyncIterable[T]::
* AsyncIterator[T]::


File: Mypy.info,  Node: Awaitable[T],  Next: AsyncIterable[T],  Up: Async protocols

1.9.7.17 Awaitable[T]
.....................

     def __await__(self) -> Generator[Any, None, T]

See also Awaitable(1).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Awaitable


File: Mypy.info,  Node: AsyncIterable[T],  Next: AsyncIterator[T],  Prev: Awaitable[T],  Up: Async protocols

1.9.7.18 AsyncIterable[T]
.........................

     def __aiter__(self) -> AsyncIterator[T]

See also AsyncIterable(1).

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/typing.html#typing.AsyncIterable


File: Mypy.info,  Node: AsyncIterator[T],  Prev: AsyncIterable[T],  Up: Async protocols

1.9.7.19 AsyncIterator[T]
.........................

     def __anext__(self) -> Awaitable[T]
     def __aiter__(self) -> AsyncIterator[T]

See also AsyncIterator(1).

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/typing.html#typing.AsyncIterator


File: Mypy.info,  Node: Context manager protocols,  Prev: Async protocols,  Up: Predefined protocol reference

1.9.7.20 Context manager protocols
..................................

There are two protocols for context managers – one for regular context
managers and one for async ones.  These allow defining objects that can
be used in ‘with’ and ‘async with’ statements.

* Menu:

* ContextManager[T]::
* AsyncContextManager[T]::


File: Mypy.info,  Node: ContextManager[T],  Next: AsyncContextManager[T],  Up: Context manager protocols

1.9.7.21 ContextManager[T]
..........................

     def __enter__(self) -> T
     def __exit__(self,
                  exc_type: Optional[Type[BaseException]],
                  exc_value: Optional[BaseException],
                  traceback: Optional[TracebackType]) -> Optional[bool]

See also ContextManager(1).

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/typing.html#typing.ContextManager


File: Mypy.info,  Node: AsyncContextManager[T],  Prev: ContextManager[T],  Up: Context manager protocols

1.9.7.22 AsyncContextManager[T]
...............................

     def __aenter__(self) -> Awaitable[T]
     def __aexit__(self,
                   exc_type: Optional[Type[BaseException]],
                   exc_value: Optional[BaseException],
                   traceback: Optional[TracebackType]) -> Awaitable[Optional[bool]]

See also AsyncContextManager(1).

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/typing.html#typing.AsyncContextManager


File: Mypy.info,  Node: Dynamically typed code,  Next: Type narrowing,  Prev: Protocols and structural subtyping,  Up: Contents

1.10 Dynamically typed code
===========================

As mentioned earlier, bodies of functions that don’t have any explicit
types in their function annotation are dynamically typed (operations are
checked at runtime).  Code outside functions is statically typed by
default, and types of variables are inferred.  This does usually the
right thing, but you can also make any variable dynamically typed by
defining it explicitly with the type ‘Any’:

     from typing import Any

     s = 1         # Statically typed (type int)
     d: Any = 1    # Dynamically typed (type Any)
     s = 'x'       # Type check error
     d = 'x'       # OK

* Menu:

* Operations on Any values::
* Any vs. object: Any vs object.


File: Mypy.info,  Node: Operations on Any values,  Next: Any vs object,  Up: Dynamically typed code

1.10.1 Operations on Any values
-------------------------------

You can do anything using a value with type ‘Any’, and type checker does
not complain:

     def f(x: Any) -> int:
         # All of these are valid!
         x.foobar(1, y=2)
         print(x[3] + 'f')
         if x:
             x.z = x(2)
         open(x).read()
         return x

Values derived from an ‘Any’ value also often have the type ‘Any’
implicitly, as mypy can’t infer a more precise result type.  For
example, if you get the attribute of an ‘Any’ value or call a ‘Any’
value the result is ‘Any’:

     def f(x: Any) -> None:
         y = x.foo()  # y has type Any
         y.bar()      # Okay as well!

‘Any’ types may propagate through your program, making type checking
less effective, unless you are careful.


File: Mypy.info,  Node: Any vs object,  Prev: Operations on Any values,  Up: Dynamically typed code

1.10.2 Any vs. object
---------------------

The type object(1) is another type that can have an instance of
arbitrary type as a value.  Unlike ‘Any’, object(2) is an ordinary
static type (it is similar to ‘Object’ in Java), and only operations
valid for ‘all’ types are accepted for object(3) values.  These are all
valid:

     def f(o: object) -> None:
         if o:
             print(o)
         print(isinstance(o, int))
         o = 2
         o = 'foo'

These are, however, flagged as errors, since not all objects support
these operations:

     def f(o: object) -> None:
         o.foo()       # Error!
         o + 2         # Error!
         open(o)       # Error!
         n: int = 1
         n = o         # Error!

You can use different *note type narrowing: 82. techniques to narrow
object(4) to a more specific type (subtype) such as ‘int’.  Type
narrowing is not needed with dynamically typed values (values with type
‘Any’).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#object

   (2) https://docs.python.org/3/library/functions.html#object

   (3) https://docs.python.org/3/library/functions.html#object

   (4) https://docs.python.org/3/library/functions.html#object


File: Mypy.info,  Node: Type narrowing,  Next: Duck type compatibility,  Prev: Dynamically typed code,  Up: Contents

1.11 Type narrowing
===================

This section is dedicated to several type narrowing techniques which are
supported by mypy.

Type narrowing is when you convince a type checker that a broader type
is actually more specific, for instance, that an object of type ‘Shape’
is actually of the narrower type ‘Square’.

* Menu:

* Type narrowing expressions::
* Casts::
* User-Defined Type Guards::


File: Mypy.info,  Node: Type narrowing expressions,  Next: Casts,  Up: Type narrowing

1.11.1 Type narrowing expressions
---------------------------------

The simplest way to narrow a type is to use one of the supported
expressions:

   - isinstance()(1) like in ‘isinstance(obj, float)’ will narrow ‘obj’
     to have ‘float’ type

   - issubclass()(2) like in ‘issubclass(cls, MyClass)’ will narrow
     ‘cls’ to be ‘Type[MyClass]’

   - ‘type()’ like in ‘type(obj) is int’ will narrow ‘obj’ to have ‘int’
     type

   - callable()(3) like in ‘callable(obj)’ will narrow object to
     callable type

Type narrowing is contextual.  For example, based on the condition, mypy
will narrow an expression only within an ‘if’ branch:

     def function(arg: object):
         if isinstance(arg, int):
             # Type is narrowed within the ``if`` branch only
             reveal_type(arg)  # Revealed type: "builtins.int"
         elif isinstance(arg, str) or isinstance(arg, bool):
             # Type is narrowed differently within this ``elif`` branch:
             reveal_type(arg)  # Revealed type: "builtins.str | builtins.bool"

             # Subsequent narrowing operations will narrow the type further
             if isinstance(arg, bool):
                 reveal_type(arg)  # Revealed type: "builtins.bool"

         # Back outside of the ``if`` statement, the type isn't narrowed:
         reveal_type(arg)  # Revealed type: "builtins.object"

Mypy understands the implications ‘return’ or exception raising can have
for what type an object could be:

     def function(arg: int | str):
         if isinstance(arg, int):
             return

         # `arg` can't be `int` at this point:
         reveal_type(arg)  # Revealed type: "builtins.str"

We can also use ‘assert’ to narrow types in the same context:

     def function(arg: Any):
         assert isinstance(arg, int)
         reveal_type(arg)  # Revealed type: "builtins.int"

     Note: With *note –warn-unreachable: b6. narrowing types to some
     impossible state will be treated as an error.

          def function(arg: int):
              # error: Subclass of "int" and "str" cannot exist:
              # would have incompatible method signatures
              assert isinstance(arg, str)

              # error: Statement is unreachable
              print("so mypy concludes the assert will always trigger")

     Without ‘--warn-unreachable’ mypy will simply not check code it
     deems to be unreachable.  See *note Unreachable code: b7. for more
     information.

          x: int = 1
          assert isinstance(x, str)
          reveal_type(x)  # Revealed type is "builtins.int"
          print(x + '!')  # Typechecks with `mypy`, but fails in runtime.

* Menu:

* issubclass::
* callable::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance

   (2) https://docs.python.org/3/library/functions.html#issubclass

   (3) https://docs.python.org/3/library/functions.html#callable


File: Mypy.info,  Node: issubclass,  Next: callable,  Up: Type narrowing expressions

1.11.1.1 issubclass
...................

Mypy can also use issubclass()(1) for better type inference when working
with types and metaclasses:

     class MyCalcMeta(type):
         @classmethod
         def calc(cls) -> int:
             ...

     def f(o: object) -> None:
         t = type(o)  # We must use a variable here
         reveal_type(t)  # Revealed type is "builtins.type"

         if issubclass(t, MyCalcMeta):  # `issubclass(type(o), MyCalcMeta)` won't work
             reveal_type(t)  # Revealed type is "Type[MyCalcMeta]"
             t.calc()  # Okay

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#issubclass


File: Mypy.info,  Node: callable,  Prev: issubclass,  Up: Type narrowing expressions

1.11.1.2 callable
.................

Mypy knows what types are callable and which ones are not during type
checking.  So, we know what ‘callable()’ will return.  For example:

     from typing import Callable

     x: Callable[[], int]

     if callable(x):
         reveal_type(x)  # N: Revealed type is "def () -> builtins.int"
     else:
         ...  # Will never be executed and will raise error with `--warn-unreachable`

‘callable’ function can even split ‘Union’ type for callable and
non-callable parts:

     from typing import Callable, Union

     x: Union[int, Callable[[], int]]

     if callable(x):
         reveal_type(x)  # N: Revealed type is "def () -> builtins.int"
     else:
         reveal_type(x)  # N: Revealed type is "builtins.int"


File: Mypy.info,  Node: Casts,  Next: User-Defined Type Guards,  Prev: Type narrowing expressions,  Up: Type narrowing

1.11.2 Casts
------------

Mypy supports type casts that are usually used to coerce a statically
typed value to a subtype.  Unlike languages such as Java or C#, however,
mypy casts are only used as hints for the type checker, and they don’t
perform a runtime type check.  Use the function cast()(1) to perform a
cast:

     from typing import cast

     o: object = [1]
     x = cast(list[int], o)  # OK
     y = cast(list[str], o)  # OK (cast performs no actual runtime check)

To support runtime checking of casts such as the above, we’d have to
check the types of all list items, which would be very inefficient for
large lists.  Casts are used to silence spurious type checker warnings
and give the type checker a little help when it can’t quite understand
what is going on.

     Note: You can use an assertion if you want to perform an actual
     runtime check:

          def foo(o: object) -> None:
              print(o + 5)  # Error: can't add 'object' and 'int'
              assert isinstance(o, int)
              print(o + 5)  # OK: type of 'o' is 'int' here

You don’t need a cast for expressions with type ‘Any’, or when assigning
to a variable with type ‘Any’, as was explained earlier.  You can also
use ‘Any’ as the cast target type – this lets you perform any operations
on the result.  For example:

     from typing import cast, Any

     x = 1
     x.whatever()  # Type check error
     y = cast(Any, x)
     y.whatever()  # Type check OK (runtime error)

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.cast


File: Mypy.info,  Node: User-Defined Type Guards,  Prev: Casts,  Up: Type narrowing

1.11.3 User-Defined Type Guards
-------------------------------

Mypy supports User-Defined Type Guards ( PEP 647(1)).

A type guard is a way for programs to influence conditional type
narrowing employed by a type checker based on runtime checks.

Basically, a ‘TypeGuard’ is a “smart” alias for a ‘bool’ type.  Let’s
have a look at the regular ‘bool’ example:

     def is_str_list(val: list[object]) -> bool:
       """Determines whether all objects in the list are strings"""
       return all(isinstance(x, str) for x in val)

     def func1(val: list[object]) -> None:
         if is_str_list(val):
             reveal_type(val)  # Reveals list[object]
             print(" ".join(val)) # Error: incompatible type

The same example with ‘TypeGuard’:

     from typing import TypeGuard  # use `typing_extensions` for Python 3.9 and below

     def is_str_list(val: list[object]) -> TypeGuard[list[str]]:
         """Determines whether all objects in the list are strings"""
         return all(isinstance(x, str) for x in val)

     def func1(val: list[object]) -> None:
         if is_str_list(val):
             reveal_type(val)  # list[str]
             print(" ".join(val)) # ok

How does it work?  ‘TypeGuard’ narrows the first function argument
(‘val’) to the type specified as the first type parameter (‘list[str]’).

     Note: Narrowing is not strict(2).  For example, you can narrow
     ‘str’ to ‘int’:

          def f(value: str) -> TypeGuard[int]:
              return True

     Note: since strict narrowing is not enforced, it’s easy to break
     type safety.

     However, there are many ways a determined or uninformed developer
     can subvert type safety – most commonly by using cast or Any.  If a
     Python developer takes the time to learn about and implement
     user-defined type guards within their code, it is safe to assume
     that they are interested in type safety and will not write their
     type guard functions in a way that will undermine type safety or
     produce nonsensical results.

* Menu:

* Generic TypeGuards::
* Typeguards with parameters::
* TypeGuards as methods::
* Assignment expressions as TypeGuards::

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0647/

   (2) 
https://www.python.org/dev/peps/pep-0647/#enforcing-strict-narrowing


File: Mypy.info,  Node: Generic TypeGuards,  Next: Typeguards with parameters,  Up: User-Defined Type Guards

1.11.3.1 Generic TypeGuards
...........................

‘TypeGuard’ can also work with generic types:

     from typing import TypeVar
     from typing import TypeGuard  # use `typing_extensions` for `python<3.10`

     _T = TypeVar("_T")

     def is_two_element_tuple(val: tuple[_T, ...]) -> TypeGuard[tuple[_T, _T]]:
         return len(val) == 2

     def func(names: tuple[str, ...]):
         if is_two_element_tuple(names):
             reveal_type(names)  # tuple[str, str]
         else:
             reveal_type(names)  # tuple[str, ...]


File: Mypy.info,  Node: Typeguards with parameters,  Next: TypeGuards as methods,  Prev: Generic TypeGuards,  Up: User-Defined Type Guards

1.11.3.2 Typeguards with parameters
...................................

Type guard functions can accept extra arguments:

     from typing import Type, TypeVar
     from typing import TypeGuard  # use `typing_extensions` for `python<3.10`

     _T = TypeVar("_T")

     def is_set_of(val: set[Any], type: Type[_T]) -> TypeGuard[set[_T]]:
         return all(isinstance(x, type) for x in val)

     items: set[Any]
     if is_set_of(items, str):
         reveal_type(items)  # set[str]


File: Mypy.info,  Node: TypeGuards as methods,  Next: Assignment expressions as TypeGuards,  Prev: Typeguards with parameters,  Up: User-Defined Type Guards

1.11.3.3 TypeGuards as methods
..............................

     A method can also serve as the ‘TypeGuard’:

     class StrValidator:
         def is_valid(self, instance: object) -> TypeGuard[str]:
             return isinstance(instance, str)

     def func(to_validate: object) -> None:
         if StrValidator().is_valid(to_validate):
             reveal_type(to_validate)  # Revealed type is "builtins.str"

     Note: Note, that ‘TypeGuard’ does not narrow(1) types of ‘self’ or
     ‘cls’ implicit arguments.

     If narrowing of ‘self’ or ‘cls’ is required, the value can be
     passed as an explicit argument to a type guard function:

          class Parent:
              def method(self) -> None:
                  reveal_type(self)  # Revealed type is "Parent"
                  if is_child(self):
                      reveal_type(self)  # Revealed type is "Child"

          class Child(Parent):
              ...

          def is_child(instance: Parent) -> TypeGuard[Child]:
              return isinstance(instance, Child)

   ---------- Footnotes ----------

   (1) 
https://www.python.org/dev/peps/pep-0647/#narrowing-of-implicit-self-and-cls-parameters


File: Mypy.info,  Node: Assignment expressions as TypeGuards,  Prev: TypeGuards as methods,  Up: User-Defined Type Guards

1.11.3.4 Assignment expressions as TypeGuards
.............................................

Sometimes you might need to create a new variable and narrow it to some
specific type at the same time.  This can be achieved by using
‘TypeGuard’ together with := operator(1).

     from typing import TypeGuard  # use `typing_extensions` for `python<3.10`

     def is_float(a: object) -> TypeGuard[float]:
         return isinstance(a, float)

     def main(a: object) -> None:
         if is_float(x := a):
             reveal_type(x)  # N: Revealed type is 'builtins.float'
             reveal_type(a)  # N: Revealed type is 'builtins.object'
         reveal_type(x)  # N: Revealed type is 'builtins.object'
         reveal_type(a)  # N: Revealed type is 'builtins.object'

What happens here?

  1. We create a new variable ‘x’ and assign a value of ‘a’ to it

  2. We run ‘is_float()’ type guard on ‘x’

  3. It narrows ‘x’ to be ‘float’ in the ‘if’ context and does not touch
     ‘a’

     Note: The same will work with ‘isinstance(x := a, float)’ as well.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/whatsnew/3.8.html#assignment-expressions


File: Mypy.info,  Node: Duck type compatibility,  Next: Stub files,  Prev: Type narrowing,  Up: Contents

1.12 Duck type compatibility
============================

In Python, certain types are compatible even though they aren’t
subclasses of each other.  For example, ‘int’ objects are valid whenever
‘float’ objects are expected.  Mypy supports this idiom via ‘duck type
compatibility’.  This is supported for a small set of built-in types:

   * ‘int’ is duck type compatible with ‘float’ and ‘complex’.

   * ‘float’ is duck type compatible with ‘complex’.

   * ‘bytearray’ and ‘memoryview’ are duck type compatible with ‘bytes’.

For example, mypy considers an ‘int’ object to be valid whenever a
‘float’ object is expected.  Thus code like this is nice and clean and
also behaves as expected:

     import math

     def degrees_to_radians(degrees: float) -> float:
         return math.pi * degrees / 180

     n = 90  # Inferred type 'int'
     print(degrees_to_radians(n))  # Okay!

You can also often use *note Protocols and structural subtyping: 3a. to
achieve a similar effect in a more principled and extensible fashion.
Protocols don’t apply to cases like ‘int’ being compatible with ‘float’,
since ‘float’ is not a protocol class but a regular, concrete class, and
many standard library functions expect concrete instances of ‘float’ (or
‘int’).


File: Mypy.info,  Node: Stub files,  Next: Generics,  Prev: Duck type compatibility,  Up: Contents

1.13 Stub files
===============

Mypy uses stub files stored in the typeshed(1) repository to determine
the types of standard library and third-party library functions,
classes, and other definitions.  You can also create your own stubs that
will be used to type check your code.  The basic properties of stubs
were introduced back in *note Stubs files and typeshed: 12.

* Menu:

* Creating a stub::
* Stub file syntax::
* Using stub file syntax at runtime::

   ---------- Footnotes ----------

   (1) https://github.com/python/typeshed


File: Mypy.info,  Node: Creating a stub,  Next: Stub file syntax,  Up: Stub files

1.13.1 Creating a stub
----------------------

Here is an overview of how to create a stub file:

   * Write a stub file for the library (or an arbitrary module) and
     store it as a ‘.pyi’ file in the same directory as the library
     module.

   * Alternatively, put your stubs (‘.pyi’ files) in a directory
     reserved for stubs (e.g., ‘myproject/stubs’).  In this case you
     have to set the environment variable ‘MYPYPATH’ to refer to the
     directory.  For example:

          $ export MYPYPATH=~/work/myproject/stubs

Use the normal Python file name conventions for modules, e.g.  ‘csv.pyi’
for module ‘csv’.  Use a subdirectory with ‘__init__.pyi’ for packages.
Note that PEP 561(1) stub-only packages must be installed, and may not
be pointed at through the ‘MYPYPATH’ (see *note PEP 561 support: 14.).

If a directory contains both a ‘.py’ and a ‘.pyi’ file for the same
module, the ‘.pyi’ file takes precedence.  This way you can easily add
annotations for a module even if you don’t want to modify the source
code.  This can be useful, for example, if you use 3rd party open source
libraries in your program (and there are no stubs in typeshed yet).

That’s it!

Now you can access the module in mypy programs and type check code that
uses the library.  If you write a stub for a library module, consider
making it available for other programmers that use mypy by contributing
it back to the typeshed repo.

Mypy also ships with two tools for making it easier to create and
maintain stubs: *note Automatic stub generation (stubgen): c6. and *note
Automatic stub testing (stubtest): c7.

The following sections explain the kinds of type annotations you can use
in your programs and stub files.

     Note: You may be tempted to point ‘MYPYPATH’ to the standard
     library or to the ‘site-packages’ directory where your 3rd party
     packages are installed.  This is almost always a bad idea – you
     will likely get tons of error messages about code you didn’t write
     and that mypy can’t analyze all that well yet, and in the worst
     case scenario mypy may crash due to some construct in a 3rd party
     package that it didn’t expect.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0561/


File: Mypy.info,  Node: Stub file syntax,  Next: Using stub file syntax at runtime,  Prev: Creating a stub,  Up: Stub files

1.13.2 Stub file syntax
-----------------------

Stub files are written in normal Python syntax, but generally leaving
out runtime logic like variable initializers, function bodies, and
default arguments.

If it is not possible to completely leave out some piece of runtime
logic, the recommended convention is to replace or elide them with
ellipsis expressions (‘...’).  Each ellipsis below is literally written
in the stub file as three dots:

     # Variables with annotations do not need to be assigned a value.
     # So by convention, we omit them in the stub file.
     x: int

     # Function bodies cannot be completely removed. By convention,
     # we replace them with `...` instead of the `pass` statement.
     def func_1(code: str) -> int: ...

     # We can do the same with default arguments.
     def func_2(a: int, b: int = ...) -> int: ...

     Note: The ellipsis ‘...’ is also used with a different meaning in
     *note callable types: 5b. and *note tuple types: 59.


File: Mypy.info,  Node: Using stub file syntax at runtime,  Prev: Stub file syntax,  Up: Stub files

1.13.3 Using stub file syntax at runtime
----------------------------------------

You may also occasionally need to elide actual logic in regular Python
code – for example, when writing methods in *note overload variants: 60.
or *note custom protocols: 3a.

The recommended style is to use ellipses to do so, just like in stub
files.  It is also considered stylistically acceptable to throw a
NotImplementedError(1) in cases where the user of the code may
accidentally call functions with no actual logic.

You can also elide default arguments as long as the function body also
contains no runtime logic: the function body only contains a single
ellipsis, the pass statement, or a ‘raise NotImplementedError()’.  It is
also acceptable for the function body to contain a docstring.  For
example:

     from typing_extensions import Protocol

     class Resource(Protocol):
         def ok_1(self, foo: list[str] = ...) -> None: ...

         def ok_2(self, foo: list[str] = ...) -> None:
             raise NotImplementedError()

         def ok_3(self, foo: list[str] = ...) -> None:
             """Some docstring"""
             pass

         # Error: Incompatible default for argument "foo" (default has
         # type "ellipsis", argument has type "list[str]")
         def not_ok(self, foo: list[str] = ...) -> None:
             print(foo)

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/exceptions.html#NotImplementedError


File: Mypy.info,  Node: Generics,  Next: More types,  Prev: Stub files,  Up: Contents

1.14 Generics
=============

This section explains how you can define your own generic classes that
take one or more type parameters, similar to built-in types such as
‘list[X]’.  User-defined generics are a moderately advanced feature and
you can get far without ever using them – feel free to skip this section
and come back later.

* Menu:

* Defining generic classes::
* Generic class internals::
* Defining sub-classes of generic classes::
* Generic functions::
* Generic methods and generic self::
* Variance of generic types::
* Type variables with value restriction::
* Type variables with upper bounds::
* Declaring decorators::
* Generic protocols::
* Generic type aliases::


File: Mypy.info,  Node: Defining generic classes,  Next: Generic class internals,  Up: Generics

1.14.1 Defining generic classes
-------------------------------

The built-in collection classes are generic classes.  Generic types have
one or more type parameters, which can be arbitrary types.  For example,
‘dict[int, str]’ has the type parameters ‘int’ and ‘str’, and
‘list[int]’ has a type parameter ‘int’.

Programs can also define new generic classes.  Here is a very simple
generic class that represents a stack:

     from typing import TypeVar, Generic

     T = TypeVar('T')

     class Stack(Generic[T]):
         def __init__(self) -> None:
             # Create an empty list with items of type T
             self.items: list[T] = []

         def push(self, item: T) -> None:
             self.items.append(item)

         def pop(self) -> T:
             return self.items.pop()

         def empty(self) -> bool:
             return not self.items

The ‘Stack’ class can be used to represent a stack of any type:
‘Stack[int]’, ‘Stack[tuple[int, str]]’, etc.

Using ‘Stack’ is similar to built-in container types:

     # Construct an empty Stack[int] instance
     stack = Stack[int]()
     stack.push(2)
     stack.pop()
     stack.push('x')        # Type error

Type inference works for user-defined generic types as well:

     def process(stack: Stack[int]) -> None: ...

     process(Stack())   # Argument has inferred type Stack[int]

Construction of instances of generic types is also type checked:

     class Box(Generic[T]):
         def __init__(self, content: T) -> None:
             self.content = content

     Box(1)  # OK, inferred type is Box[int]
     Box[int](1)  # Also OK
     s = 'some string'
     Box[int](s)  # Type error


File: Mypy.info,  Node: Generic class internals,  Next: Defining sub-classes of generic classes,  Prev: Defining generic classes,  Up: Generics

1.14.2 Generic class internals
------------------------------

You may wonder what happens at runtime when you index ‘Stack’.  Indexing
‘Stack’ returns a ‘generic alias’ to ‘Stack’ that returns instances of
the original class on instantiation:

     >>> print(Stack)
     __main__.Stack
     >>> print(Stack[int])
     __main__.Stack[int]
     >>> print(Stack[int]().__class__)
     __main__.Stack

Generic aliases can be instantiated or subclassed, similar to real
classes, but the above examples illustrate that type variables are
erased at runtime.  Generic ‘Stack’ instances are just ordinary Python
objects, and they have no extra runtime overhead or magic due to being
generic, other than a metaclass that overloads the indexing operator.

Note that in Python 3.8 and lower, the built-in types list(1), dict(2)
and others do not support indexing.  This is why we have the aliases
List(3), Dict(4) and so on in the typing(5) module.  Indexing these
aliases gives you a generic alias that resembles generic aliases
constructed by directly indexing the target class in more recent
versions of Python:

     >>> # Only relevant for Python 3.8 and below
     >>> # For Python 3.9 onwards, prefer `list[int]` syntax
     >>> from typing import List
     >>> List[int]
     typing.List[int]

Note that the generic aliases in ‘typing’ don’t support constructing
instances:

     >>> from typing import List
     >>> List[int]()
     Traceback (most recent call last):
     ...
     TypeError: Type List cannot be instantiated; use list() instead

     Note: In Python 3.6 indexing generic types or type aliases results
     in actual type objects.  This means that generic types in type
     annotations can have a significant runtime cost.  This was changed
     in Python 3.7, and indexing generic types became a cheap operation.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#list

   (2) https://docs.python.org/3/library/stdtypes.html#dict

   (3) https://docs.python.org/3/library/typing.html#typing.List

   (4) https://docs.python.org/3/library/typing.html#typing.Dict

   (5) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Defining sub-classes of generic classes,  Next: Generic functions,  Prev: Generic class internals,  Up: Generics

1.14.3 Defining sub-classes of generic classes
----------------------------------------------

User-defined generic classes and generic classes defined in typing(1)
can be used as base classes for another classes, both generic and
non-generic.  For example:

     from typing import Generic, TypeVar, Mapping, Iterator

     KT = TypeVar('KT')
     VT = TypeVar('VT')

     class MyMap(Mapping[KT, VT]):  # This is a generic subclass of Mapping
         def __getitem__(self, k: KT) -> VT:
             ...  # Implementations omitted
         def __iter__(self) -> Iterator[KT]:
             ...
         def __len__(self) -> int:
             ...

     items: MyMap[str, int]  # Okay

     class StrDict(dict[str, str]):  # This is a non-generic subclass of dict
         def __str__(self) -> str:
             return f'StrDict({super().__str__()})'

     data: StrDict[int, int]  # Error! StrDict is not generic
     data2: StrDict  # OK

     class Receiver(Generic[T]):
         def accept(self, value: T) -> None:
             ...

     class AdvancedReceiver(Receiver[T]):
         ...

     Note: You have to add an explicit Mapping(2) base class if you want
     mypy to consider a user-defined class as a mapping (and Sequence(3)
     for sequences, etc.).  This is because mypy doesn’t use ‘structural
     subtyping’ for these ABCs, unlike simpler protocols like
     Iterable(4), which use *note structural subtyping: 3a.

Generic(5) can be omitted from bases if there are other base classes
that include type variables, such as ‘Mapping[KT, VT]’ in the above
example.  If you include ‘Generic[...]’ in bases, then it should list
all type variables present in other bases (or more, if needed).  The
order of type variables is defined by the following rules:

   * If ‘Generic[...]’ is present, then the order of variables is always
     determined by their order in ‘Generic[...]’.

   * If there are no ‘Generic[...]’ in bases, then all type variables
     are collected in the lexicographic order (i.e.  by first
     appearance).

For example:

     from typing import Generic, TypeVar, Any

     T = TypeVar('T')
     S = TypeVar('S')
     U = TypeVar('U')

     class One(Generic[T]): ...
     class Another(Generic[T]): ...

     class First(One[T], Another[S]): ...
     class Second(One[T], Another[S], Generic[S, U, T]): ...

     x: First[int, str]        # Here T is bound to int, S is bound to str
     y: Second[int, str, Any]  # Here T is Any, S is int, and U is str

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing

   (2) https://docs.python.org/3/library/typing.html#typing.Mapping

   (3) https://docs.python.org/3/library/typing.html#typing.Sequence

   (4) https://docs.python.org/3/library/typing.html#typing.Iterable

   (5) https://docs.python.org/3/library/typing.html#typing.Generic


File: Mypy.info,  Node: Generic functions,  Next: Generic methods and generic self,  Prev: Defining sub-classes of generic classes,  Up: Generics

1.14.4 Generic functions
------------------------

Generic type variables can also be used to define generic functions:

     from typing import TypeVar, Sequence

     T = TypeVar('T')      # Declare type variable

     def first(seq: Sequence[T]) -> T:   # Generic function
         return seq[0]

As with generic classes, the type variable can be replaced with any
type.  That means ‘first’ can be used with any sequence type, and the
return type is derived from the sequence item type.  For example:

     # Assume first defined as above.

     s = first('foo')      # s has type str.
     n = first([1, 2, 3])  # n has type int.

Note also that a single definition of a type variable (such as ‘T’
above) can be used in multiple generic functions or classes.  In this
example we use the same type variable in two generic functions:

     from typing import TypeVar, Sequence

     T = TypeVar('T')      # Declare type variable

     def first(seq: Sequence[T]) -> T:
         return seq[0]

     def last(seq: Sequence[T]) -> T:
         return seq[-1]

A variable cannot have a type variable in its type unless the type
variable is bound in a containing generic class or function.


File: Mypy.info,  Node: Generic methods and generic self,  Next: Variance of generic types,  Prev: Generic functions,  Up: Generics

1.14.5 Generic methods and generic self
---------------------------------------

You can also define generic methods — just use a type variable in the
method signature that is different from class type variables.  In
particular, ‘self’ may also be generic, allowing a method to return the
most precise type known at the point of access.

     Note: This feature is experimental.  Checking code with type
     annotations for self arguments is still not fully implemented.
     Mypy may disallow valid code or allow unsafe code.

In this way, for example, you can typecheck chaining of setter methods:

     from typing import TypeVar

     T = TypeVar('T', bound='Shape')

     class Shape:
         def set_scale(self: T, scale: float) -> T:
             self.scale = scale
             return self

     class Circle(Shape):
         def set_radius(self, r: float) -> 'Circle':
             self.radius = r
             return self

     class Square(Shape):
         def set_width(self, w: float) -> 'Square':
             self.width = w
             return self

     circle: Circle = Circle().set_scale(0.5).set_radius(2.7)
     square: Square = Square().set_scale(0.5).set_width(3.2)

Without using generic ‘self’, the last two lines could not be
type-checked properly.

Other uses are factory methods, such as copy and deserialization.  For
class methods, you can also define generic ‘cls’, using Type[T](1):

     from typing import TypeVar, Type

     T = TypeVar('T', bound='Friend')

     class Friend:
         other: "Friend" = None

         @classmethod
         def make_pair(cls: Type[T]) -> tuple[T, T]:
             a, b = cls(), cls()
             a.other = b
             b.other = a
             return a, b

     class SuperFriend(Friend):
         pass

     a, b = SuperFriend.make_pair()

Note that when overriding a method with generic ‘self’, you must either
return a generic ‘self’ too, or return an instance of the current class.
In the latter case, you must implement this method in all future
subclasses.

Note also that mypy cannot always verify that the implementation of a
copy or a deserialization method returns the actual type of self.
Therefore you may need to silence mypy inside these methods (but not at
the call site), possibly by making use of the ‘Any’ type.

For some advanced uses of self-types see *note additional examples: d4.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Type


File: Mypy.info,  Node: Variance of generic types,  Next: Type variables with value restriction,  Prev: Generic methods and generic self,  Up: Generics

1.14.6 Variance of generic types
--------------------------------

There are three main kinds of generic types with respect to subtype
relations between them: invariant, covariant, and contravariant.
Assuming that we have a pair of types ‘A’ and ‘B’, and ‘B’ is a subtype
of ‘A’, these are defined as follows:

   * A generic class ‘MyCovGen[T, ...]’ is called covariant in type
     variable ‘T’ if ‘MyCovGen[B, ...]’ is always a subtype of
     ‘MyCovGen[A, ...]’.

   * A generic class ‘MyContraGen[T, ...]’ is called contravariant in
     type variable ‘T’ if ‘MyContraGen[A, ...]’ is always a subtype of
     ‘MyContraGen[B, ...]’.

   * A generic class ‘MyInvGen[T, ...]’ is called invariant in ‘T’ if
     neither of the above is true.

Let us illustrate this by few simple examples:

   * Union(1) is covariant in all variables: ‘Union[Cat, int]’ is a
     subtype of ‘Union[Animal, int]’, ‘Union[Dog, int]’ is also a
     subtype of ‘Union[Animal, int]’, etc.  Most immutable containers
     such as Sequence(2) and FrozenSet(3) are also covariant.

   * Callable(4) is an example of type that behaves contravariant in
     types of arguments, namely ‘Callable[[Employee], int]’ is a subtype
     of ‘Callable[[Manager], int]’.  To understand this, consider a
     function:

          def salaries(staff: list[Manager],
                       accountant: Callable[[Manager], int]) -> list[int]: ...

     This function needs a callable that can calculate a salary for
     managers, and if we give it a callable that can calculate a salary
     for an arbitrary employee, it’s still safe.

   * List(5) is an invariant generic type.  Naively, one would think
     that it is covariant, but let us consider this code:

          class Shape:
              pass

          class Circle(Shape):
              def rotate(self):
                  ...

          def add_one(things: list[Shape]) -> None:
              things.append(Shape())

          my_things: list[Circle] = []
          add_one(my_things)     # This may appear safe, but...
          my_things[0].rotate()  # ...this will fail

     Another example of invariant type is Dict(6).  Most mutable
     containers are invariant.

By default, mypy assumes that all user-defined generics are invariant.
To declare a given generic class as covariant or contravariant use type
variables defined with special keyword arguments ‘covariant’ or
‘contravariant’.  For example:

     from typing import Generic, TypeVar

     T_co = TypeVar('T_co', covariant=True)

     class Box(Generic[T_co]):  # this type is declared covariant
         def __init__(self, content: T_co) -> None:
             self._content = content

         def get_content(self) -> T_co:
             return self._content

     def look_into(box: Box[Animal]): ...

     my_box = Box(Cat())
     look_into(my_box)  # OK, but mypy would complain here for an invariant type

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Union

   (2) https://docs.python.org/3/library/typing.html#typing.Sequence

   (3) https://docs.python.org/3/library/typing.html#typing.FrozenSet

   (4) https://docs.python.org/3/library/typing.html#typing.Callable

   (5) https://docs.python.org/3/library/typing.html#typing.List

   (6) https://docs.python.org/3/library/typing.html#typing.Dict


File: Mypy.info,  Node: Type variables with value restriction,  Next: Type variables with upper bounds,  Prev: Variance of generic types,  Up: Generics

1.14.7 Type variables with value restriction
--------------------------------------------

By default, a type variable can be replaced with any type.  However,
sometimes it’s useful to have a type variable that can only have some
specific types as its value.  A typical example is a type variable that
can only have values ‘str’ and ‘bytes’:

     from typing import TypeVar

     AnyStr = TypeVar('AnyStr', str, bytes)

This is actually such a common type variable that AnyStr(1) is defined
in typing(2) and we don’t need to define it ourselves.

We can use AnyStr(3) to define a function that can concatenate two
strings or bytes objects, but it can’t be called with other argument
types:

     from typing import AnyStr

     def concat(x: AnyStr, y: AnyStr) -> AnyStr:
         return x + y

     concat('a', 'b')    # Okay
     concat(b'a', b'b')  # Okay
     concat(1, 2)        # Error!

Note that this is different from a union type, since combinations of
‘str’ and ‘bytes’ are not accepted:

     concat('string', b'bytes')   # Error!

In this case, this is exactly what we want, since it’s not possible to
concatenate a string and a bytes object!  The type checker will reject
this function:

     def union_concat(x: Union[str, bytes], y: Union[str, bytes]) -> Union[str, bytes]:
         return x + y  # Error: can't concatenate str and bytes

Another interesting special case is calling ‘concat()’ with a subtype of
‘str’:

     class S(str): pass

     ss = concat(S('foo'), S('bar'))

You may expect that the type of ‘ss’ is ‘S’, but the type is actually
‘str’: a subtype gets promoted to one of the valid values for the type
variable, which in this case is ‘str’.  This is thus subtly different
from ‘bounded quantification’ in languages such as Java, where the
return type would be ‘S’.  The way mypy implements this is correct for
‘concat’, since ‘concat’ actually returns a ‘str’ instance in the above
example:

     >>> print(type(ss))
     <class 'str'>

You can also use a TypeVar(4) with a restricted set of possible values
when defining a generic class.  For example, mypy uses the type
Pattern[AnyStr](5) for the return value of re.compile()(6), since
regular expressions can be based on a string or a bytes pattern.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.AnyStr

   (2) https://docs.python.org/3/library/typing.html#module-typing

   (3) https://docs.python.org/3/library/typing.html#typing.AnyStr

   (4) https://docs.python.org/3/library/typing.html#typing.TypeVar

   (5) https://docs.python.org/3/library/typing.html#typing.Pattern

   (6) https://docs.python.org/3/library/re.html#re.compile


File: Mypy.info,  Node: Type variables with upper bounds,  Next: Declaring decorators,  Prev: Type variables with value restriction,  Up: Generics

1.14.8 Type variables with upper bounds
---------------------------------------

A type variable can also be restricted to having values that are
subtypes of a specific type.  This type is called the upper bound of the
type variable, and is specified with the ‘bound=...’ keyword argument to
TypeVar(1).

     from typing import TypeVar, SupportsAbs

     T = TypeVar('T', bound=SupportsAbs[float])

In the definition of a generic function that uses such a type variable
‘T’, the type represented by ‘T’ is assumed to be a subtype of its upper
bound, so the function can use methods of the upper bound on values of
type ‘T’.

     def largest_in_absolute_value(*xs: T) -> T:
         return max(xs, key=abs)  # Okay, because T is a subtype of SupportsAbs[float].

In a call to such a function, the type ‘T’ must be replaced by a type
that is a subtype of its upper bound.  Continuing the example above,

     largest_in_absolute_value(-3.5, 2)   # Okay, has type float.
     largest_in_absolute_value(5+6j, 7)   # Okay, has type complex.
     largest_in_absolute_value('a', 'b')  # Error: 'str' is not a subtype of SupportsAbs[float].

Type parameters of generic classes may also have upper bounds, which
restrict the valid values for the type parameter in the same way.

A type variable may not have both a value restriction (see *note Type
variables with value restriction: d7.) and an upper bound.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.TypeVar


File: Mypy.info,  Node: Declaring decorators,  Next: Generic protocols,  Prev: Type variables with upper bounds,  Up: Generics

1.14.9 Declaring decorators
---------------------------

One common application of type variables along with parameter
specifications is in declaring a decorator that preserves the signature
of the function it decorates.

Note that class decorators are handled differently than function
decorators in mypy: decorating a class does not erase its type, even if
the decorator has incomplete type annotations.

Suppose we have the following decorator, not type annotated yet, that
preserves the original function’s signature and merely prints the
decorated function’s name:

     def my_decorator(func):
         def wrapper(*args, **kwds):
             print("Calling", func)
             return func(*args, **kwds)
         return wrapper

and we use it to decorate function ‘add_forty_two’:

     # A decorated function.
     @my_decorator
     def add_forty_two(value: int) -> int:
         return value + 42

     a = add_forty_two(3)

Since ‘my_decorator’ is not type-annotated, the following won’t get
type-checked:

     reveal_type(a)  # revealed type: Any
     add_forty_two('foo')  # no type-checker error :(

Before parameter specifications, here’s how one might have annotated the
decorator:

     from typing import Callable, TypeVar

     F = TypeVar('F', bound=Callable[..., Any])

     # A decorator that preserves the signature.
     def my_decorator(func: F) -> F:
         def wrapper(*args, **kwds):
             print("Calling", func)
             return func(*args, **kwds)
         return cast(F, wrapper)

and that would enable the following type checks:

     reveal_type(a)  # str
     add_forty_two('x')    # Type check error: incompatible type "str"; expected "int"

Note that the ‘wrapper()’ function is not type-checked.  Wrapper
functions are typically small enough that this is not a big problem.
This is also the reason for the cast()(1) call in the ‘return’ statement
in ‘my_decorator()’.  See *note casts: 4d.  However, with the
introduction of parameter specifications in mypy 0.940, we can now have
a more faithful type annotation:

     from typing import Callable, ParamSpec, TypeVar

     P = ParamSpec('P')
     T = TypeVar('T')

     def my_decorator(func: Callable[P, T]) -> Callable[P, T]:
         def wrapper(*args: P.args, **kwds: P.kwargs) -> T:
             print("Calling", func)
             return func(*args, **kwds)
         return wrapper

When the decorator alters the signature, parameter specifications truly
show their potential:

     from typing import Callable, ParamSpec, TypeVar

     P = ParamSpec('P')
     T = TypeVar('T')

      # Note: We reuse 'P' in the return type, but replace 'T' with 'str'
     def stringify(func: Callable[P, T]) -> Callable[P, str]:
         def wrapper(*args: P.args, **kwds: P.kwargs) -> str:
             return str(func(*args, **kwds))
         return wrapper

      @stringify
      def add_forty_two(value: int) -> int:
          return value + 42

      a = add_forty_two(3)
      reveal_type(a)  # str
      foo('x')    # Type check error: incompatible type "str"; expected "int"

* Menu:

* Decorator factories::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.cast


File: Mypy.info,  Node: Decorator factories,  Up: Declaring decorators

1.14.9.1 Decorator factories
............................

Functions that take arguments and return a decorator (also called
second-order decorators), are similarly supported via generics:

     from typing import Any, Callable, TypeVar

     F = TypeVar('F', bound=Callable[..., Any])

     def route(url: str) -> Callable[[F], F]:
         ...

     @route(url='/')
     def index(request: Any) -> str:
         return 'Hello world'

Sometimes the same decorator supports both bare calls and calls with
arguments.  This can be achieved by combining with @overload(1):

     from typing import Any, Callable, TypeVar, overload

     F = TypeVar('F', bound=Callable[..., Any])

     # Bare decorator usage
     @overload
     def atomic(__func: F) -> F: ...
     # Decorator with arguments
     @overload
     def atomic(*, savepoint: bool = True) -> Callable[[F], F]: ...

     # Implementation
     def atomic(__func: Callable[..., Any] = None, *, savepoint: bool = True):
         def decorator(func: Callable[..., Any]):
             ...  # Code goes here
         if __func is not None:
             return decorator(__func)
         else:
             return decorator

     # Usage
     @atomic
     def func1() -> None: ...

     @atomic(savepoint=False)
     def func2() -> None: ...

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.overload


File: Mypy.info,  Node: Generic protocols,  Next: Generic type aliases,  Prev: Declaring decorators,  Up: Generics

1.14.10 Generic protocols
-------------------------

Mypy supports generic protocols (see also *note Protocols and structural
subtyping: 3a.).  Several *note predefined protocols: 90. are generic,
such as Iterable[T](1), and you can define additional generic protocols.
Generic protocols mostly follow the normal rules for generic classes.
Example:

     from typing import TypeVar
     from typing_extensions import Protocol

     T = TypeVar('T')

     class Box(Protocol[T]):
         content: T

     def do_stuff(one: Box[str], other: Box[bytes]) -> None:
         ...

     class StringWrapper:
         def __init__(self, content: str) -> None:
             self.content = content

     class BytesWrapper:
         def __init__(self, content: bytes) -> None:
             self.content = content

     do_stuff(StringWrapper('one'), BytesWrapper(b'other'))  # OK

     x: Box[float] = ...
     y: Box[int] = ...
     x = y  # Error -- Box is invariant

Per PEP 544: Generic protocols(2), ‘class ClassName(Protocol[T])’ is
allowed as a shorthand for ‘class ClassName(Protocol, Generic[T])’.

The main difference between generic protocols and ordinary generic
classes is that mypy checks that the declared variances of generic type
variables in a protocol match how they are used in the protocol
definition.  The protocol in this example is rejected, since the type
variable ‘T’ is used covariantly as a return type, but the type variable
is invariant:

     from typing import TypeVar
     from typing_extensions import Protocol

     T = TypeVar('T')

     class ReadOnlyBox(Protocol[T]):  # Error: covariant type variable expected
         def content(self) -> T: ...

This example correctly uses a covariant type variable:

     from typing import TypeVar
     from typing_extensions import Protocol

     T_co = TypeVar('T_co', covariant=True)

     class ReadOnlyBox(Protocol[T_co]):  # OK
         def content(self) -> T_co: ...

     ax: ReadOnlyBox[float] = ...
     ay: ReadOnlyBox[int] = ...
     ax = ay  # OK -- ReadOnlyBox is covariant

See *note Variance of generic types: d6. for more about variance.

Generic protocols can also be recursive.  Example:

     T = TypeVar('T')

     class Linked(Protocol[T]):
         val: T
         def next(self) -> 'Linked[T]': ...

     class L:
         val: int

         ...  # details omitted

         def next(self) -> 'L':
             ...  # details omitted

     def last(seq: Linked[T]) -> T:
         ...  # implementation omitted

     result = last(L())  # Inferred type of 'result' is 'int'

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Iterable

   (2) https://peps.python.org/pep-0544/#generic-protocols


File: Mypy.info,  Node: Generic type aliases,  Prev: Generic protocols,  Up: Generics

1.14.11 Generic type aliases
----------------------------

Type aliases can be generic.  In this case they can be used in two ways:
Subscripted aliases are equivalent to original types with substituted
type variables, so the number of type arguments must match the number of
free type variables in the generic type alias.  Unsubscripted aliases
are treated as original types with free variables replaced with ‘Any’.
Examples (following PEP 484: Type aliases(1)):

     from typing import TypeVar, Iterable, Union, Callable

     S = TypeVar('S')

     TInt = tuple[int, S]
     UInt = Union[S, int]
     CBack = Callable[..., S]

     def response(query: str) -> UInt[str]:  # Same as Union[str, int]
         ...
     def activate(cb: CBack[S]) -> S:        # Same as Callable[..., S]
         ...
     table_entry: TInt  # Same as tuple[int, Any]

     T = TypeVar('T', int, float, complex)

     Vec = Iterable[tuple[T, T]]

     def inproduct(v: Vec[T]) -> T:
         return sum(x*y for x, y in v)

     def dilate(v: Vec[T], scale: T) -> Vec[T]:
         return ((x * scale, y * scale) for x, y in v)

     v1: Vec[int] = []      # Same as Iterable[tuple[int, int]]
     v2: Vec = []           # Same as Iterable[tuple[Any, Any]]
     v3: Vec[int, int] = [] # Error: Invalid alias, too many type arguments!

Type aliases can be imported from modules just like other names.  An
alias can also target another alias, although building complex chains of
aliases is not recommended – this impedes code readability, thus
defeating the purpose of using aliases.  Example:

     from typing import TypeVar, Generic, Optional
     from example1 import AliasType
     from example2 import Vec

     # AliasType and Vec are type aliases (Vec as defined above)

     def fun() -> AliasType:
         ...

     T = TypeVar('T')

     class NewVec(Vec[T]):
         ...

     for i, j in NewVec[int]():
         ...

     OIntVec = Optional[Vec[int]]

     Note: A type alias does not define a new type.  For generic type
     aliases this means that variance of type variables used for alias
     definition does not apply to aliases.  A parameterized generic
     alias is treated simply as an original type with the corresponding
     type variables substituted.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/#type-aliases


File: Mypy.info,  Node: More types,  Next: Literal types and Enums,  Prev: Generics,  Up: Contents

1.15 More types
===============

This section introduces a few additional kinds of types, including
NoReturn(1), ‘NewType’, ‘TypedDict’, and types for async code.  It also
discusses how to give functions more precise types using overloads.  All
of these are only situationally useful, so feel free to skip this
section and come back when you have a need for some of them.

Here’s a quick summary of what’s covered here:

   * NoReturn(2) lets you tell mypy that a function never returns
     normally.

   * ‘NewType’ lets you define a variant of a type that is treated as a
     separate type by mypy but is identical to the original type at
     runtime.  For example, you can have ‘UserId’ as a variant of ‘int’
     that is just an ‘int’ at runtime.

   * @overload(3) lets you define a function that can accept multiple
     distinct signatures.  This is useful if you need to encode a
     relationship between the arguments and the return type that would
     be difficult to express normally.

   * ‘TypedDict’ lets you give precise types for dictionaries that
     represent objects with a fixed schema, such as ‘{'id': 1, 'items':
     ['x']}’.

   * Async types let you type check programs using ‘async’ and ‘await’.

* Menu:

* The NoReturn type::
* NewTypes::
* Function overloading::
* Advanced uses of self-types::
* Typing async/await::
* TypedDict::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.NoReturn

   (2) https://docs.python.org/3/library/typing.html#typing.NoReturn

   (3) https://docs.python.org/3/library/typing.html#typing.overload


File: Mypy.info,  Node: The NoReturn type,  Next: NewTypes,  Up: More types

1.15.1 The NoReturn type
------------------------

Mypy provides support for functions that never return.  For example, a
function that unconditionally raises an exception:

     from typing import NoReturn

     def stop() -> NoReturn:
         raise Exception('no way')

Mypy will ensure that functions annotated as returning NoReturn(1) truly
never return, either implicitly or explicitly.  Mypy will also recognize
that the code after calls to such functions is unreachable and will
behave accordingly:

     def f(x: int) -> int:
         if x == 0:
             return x
         stop()
         return 'whatever works'  # No error in an unreachable block

In earlier Python versions you need to install ‘typing_extensions’ using
pip to use NoReturn(2) in your code.  Python 3 command line:

     python3 -m pip install --upgrade typing-extensions

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.NoReturn

   (2) https://docs.python.org/3/library/typing.html#typing.NoReturn


File: Mypy.info,  Node: NewTypes,  Next: Function overloading,  Prev: The NoReturn type,  Up: More types

1.15.2 NewTypes
---------------

There are situations where you may want to avoid programming errors by
creating simple derived classes that are only used to distinguish
certain values from base class instances.  Example:

     class UserId(int):
         pass

     def get_by_user_id(user_id: UserId):
         ...

However, this approach introduces some runtime overhead.  To avoid this,
the typing module provides a helper object ‘NewType’ that creates simple
unique types with almost zero runtime overhead.  Mypy will treat the
statement ‘Derived = NewType('Derived', Base)’ as being roughly
equivalent to the following definition:

     class Derived(Base):
         def __init__(self, _x: Base) -> None:
             ...

However, at runtime, ‘NewType('Derived', Base)’ will return a dummy
callable that simply returns its argument:

     def Derived(_x):
         return _x

Mypy will require explicit casts from ‘int’ where ‘UserId’ is expected,
while implicitly casting from ‘UserId’ where ‘int’ is expected.
Examples:

     from typing import NewType

     UserId = NewType('UserId', int)

     def name_by_id(user_id: UserId) -> str:
         ...

     UserId('user')          # Fails type check

     name_by_id(42)          # Fails type check
     name_by_id(UserId(42))  # OK

     num: int = UserId(5) + 1

‘NewType’ accepts exactly two arguments.  The first argument must be a
string literal containing the name of the new type and must equal the
name of the variable to which the new type is assigned.  The second
argument must be a properly subclassable class, i.e., not a type
construct like Union(1), etc.

The callable returned by ‘NewType’ accepts only one argument; this is
equivalent to supporting only one constructor accepting an instance of
the base class (see above).  Example:

     from typing import NewType

     class PacketId:
         def __init__(self, major: int, minor: int) -> None:
             self._major = major
             self._minor = minor

     TcpPacketId = NewType('TcpPacketId', PacketId)

     packet = PacketId(100, 100)
     tcp_packet = TcpPacketId(packet)  # OK

     tcp_packet = TcpPacketId(127, 0)  # Fails in type checker and at runtime

You cannot use isinstance()(2) or issubclass()(3) on the object returned
by ‘NewType()’, nor can you subclass an object returned by ‘NewType()’.

     Note: Unlike type aliases, ‘NewType’ will create an entirely new
     and unique type when used.  The intended purpose of ‘NewType’ is to
     help you detect cases where you accidentally mixed together the old
     base type and the new derived type.

     For example, the following will successfully typecheck when using
     type aliases:

          UserId = int

          def name_by_id(user_id: UserId) -> str:
              ...

          name_by_id(3)  # ints and UserId are synonymous

     But a similar example using ‘NewType’ will not typecheck:

          from typing import NewType

          UserId = NewType('UserId', int)

          def name_by_id(user_id: UserId) -> str:
              ...

          name_by_id(3)  # int is not the same as UserId

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Union

   (2) https://docs.python.org/3/library/functions.html#isinstance

   (3) https://docs.python.org/3/library/functions.html#issubclass


File: Mypy.info,  Node: Function overloading,  Next: Advanced uses of self-types,  Prev: NewTypes,  Up: More types

1.15.3 Function overloading
---------------------------

Sometimes the arguments and types in a function depend on each other in
ways that can’t be captured with a Union(1).  For example, suppose we
want to write a function that can accept x-y coordinates.  If we pass in
just a single x-y coordinate, we return a ‘ClickEvent’ object.  However,
if we pass in two x-y coordinates, we return a ‘DragEvent’ object.

Our first attempt at writing this function might look like this:

     from typing import Union, Optional

     def mouse_event(x1: int,
                     y1: int,
                     x2: Optional[int] = None,
                     y2: Optional[int] = None) -> Union[ClickEvent, DragEvent]:
         if x2 is None and y2 is None:
             return ClickEvent(x1, y1)
         elif x2 is not None and y2 is not None:
             return DragEvent(x1, y1, x2, y2)
         else:
             raise TypeError("Bad arguments")

While this function signature works, it’s too loose: it implies
‘mouse_event’ could return either object regardless of the number of
arguments we pass in.  It also does not prohibit a caller from passing
in the wrong number of ints: mypy would treat calls like ‘mouse_event(1,
2, 20)’ as being valid, for example.

We can do better by using overloading(2) which lets us give the same
function multiple type annotations (signatures) to more accurately
describe the function’s behavior:

     from typing import Union, overload

     # Overload *variants* for 'mouse_event'.
     # These variants give extra information to the type checker.
     # They are ignored at runtime.

     @overload
     def mouse_event(x1: int, y1: int) -> ClickEvent: ...
     @overload
     def mouse_event(x1: int, y1: int, x2: int, y2: int) -> DragEvent: ...

     # The actual *implementation* of 'mouse_event'.
     # The implementation contains the actual runtime logic.
     #
     # It may or may not have type hints. If it does, mypy
     # will check the body of the implementation against the
     # type hints.
     #
     # Mypy will also check and make sure the signature is
     # consistent with the provided variants.

     def mouse_event(x1: int,
                     y1: int,
                     x2: Optional[int] = None,
                     y2: Optional[int] = None) -> Union[ClickEvent, DragEvent]:
         if x2 is None and y2 is None:
             return ClickEvent(x1, y1)
         elif x2 is not None and y2 is not None:
             return DragEvent(x1, y1, x2, y2)
         else:
             raise TypeError("Bad arguments")

This allows mypy to understand calls to ‘mouse_event’ much more
precisely.  For example, mypy will understand that ‘mouse_event(5, 25)’
will always have a return type of ‘ClickEvent’ and will report errors
for calls like ‘mouse_event(5, 25, 2)’.

As another example, suppose we want to write a custom container class
that implements the __getitem__(3) method (‘[]’ bracket indexing).  If
this method receives an integer we return a single item.  If it receives
a ‘slice’, we return a Sequence(4) of items.

We can precisely encode this relationship between the argument and the
return type by using overloads like so:

     from typing import Sequence, TypeVar, Union, overload

     T = TypeVar('T')

     class MyList(Sequence[T]):
         @overload
         def __getitem__(self, index: int) -> T: ...

         @overload
         def __getitem__(self, index: slice) -> Sequence[T]: ...

         def __getitem__(self, index: Union[int, slice]) -> Union[T, Sequence[T]]:
             if isinstance(index, int):
                 # Return a T here
             elif isinstance(index, slice):
                 # Return a sequence of Ts here
             else:
                 raise TypeError(...)

     Note: If you just need to constrain a type variable to certain
     types or subtypes, you can use a *note value restriction: d7.

The default values of a function’s arguments don’t affect its signature
– only the absence or presence of a default value does.  So in order to
reduce redundancy, it’s possible to replace default values in overload
definitions with ‘...’ as a placeholder:

     from typing import overload

     class M: ...

     @overload
     def get_model(model_or_pk: M, flag: bool = ...) -> M: ...
     @overload
     def get_model(model_or_pk: int, flag: bool = ...) -> M | None: ...

     def get_model(model_or_pk: int | M, flag: bool = True) -> M | None:
         ...

* Menu:

* Runtime behavior::
* Type checking calls to overloads::
* Type checking the variants::
* Type checking the implementation::
* Conditional overloads::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Union

   (2) https://peps.python.org/pep-0484/#function-method-overloading

   (3) 
https://docs.python.org/3/reference/datamodel.html#object.__getitem__

   (4) https://docs.python.org/3/library/typing.html#typing.Sequence


File: Mypy.info,  Node: Runtime behavior,  Next: Type checking calls to overloads,  Up: Function overloading

1.15.3.1 Runtime behavior
.........................

An overloaded function must consist of two or more overload ‘variants’
followed by an ‘implementation’.  The variants and the implementations
must be adjacent in the code: think of them as one indivisible unit.

The variant bodies must all be empty; only the implementation is allowed
to contain code.  This is because at runtime, the variants are
completely ignored: they’re overridden by the final implementation
function.

This means that an overloaded function is still an ordinary Python
function!  There is no automatic dispatch handling and you must manually
handle the different types in the implementation (e.g.  by using ‘if’
statements and isinstance(1) checks).

If you are adding an overload within a stub file, the implementation
function should be omitted: stubs do not contain runtime logic.

     Note: While we can leave the variant body empty using the ‘pass’
     keyword, the more common convention is to instead use the ellipsis
     (‘...’) literal.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance


File: Mypy.info,  Node: Type checking calls to overloads,  Next: Type checking the variants,  Prev: Runtime behavior,  Up: Function overloading

1.15.3.2 Type checking calls to overloads
.........................................

When you call an overloaded function, mypy will infer the correct return
type by picking the best matching variant, after taking into
consideration both the argument types and arity.  However, a call is
never type checked against the implementation.  This is why mypy will
report calls like ‘mouse_event(5, 25, 3)’ as being invalid even though
it matches the implementation signature.

If there are multiple equally good matching variants, mypy will select
the variant that was defined first.  For example, consider the following
program:

     # For Python 3.8 and below you must use `typing.List` instead of `list`. e.g.
     # from typing import List
     from typing import overload

     @overload
     def summarize(data: list[int]) -> float: ...

     @overload
     def summarize(data: list[str]) -> str: ...

     def summarize(data):
         if not data:
             return 0.0
         elif isinstance(data[0], int):
             # Do int specific code
         else:
             # Do str-specific code

     # What is the type of 'output'? float or str?
     output = summarize([])

The ‘summarize([])’ call matches both variants: an empty list could be
either a ‘list[int]’ or a ‘list[str]’.  In this case, mypy will break
the tie by picking the first matching variant: ‘output’ will have an
inferred type of ‘float’.  The implementor is responsible for making
sure ‘summarize’ breaks ties in the same way at runtime.

However, there are two exceptions to the “pick the first match” rule.
First, if multiple variants match due to an argument being of type
‘Any’, mypy will make the inferred type also be ‘Any’:

     dynamic_var: Any = some_dynamic_function()

     # output2 is of type 'Any'
     output2 = summarize(dynamic_var)

Second, if multiple variants match due to one or more of the arguments
being a union, mypy will make the inferred type be the union of the
matching variant returns:

     some_list: Union[list[int], list[str]]

     # output3 is of type 'Union[float, str]'
     output3 = summarize(some_list)

     Note: Due to the “pick the first match” rule, changing the order of
     your overload variants can change how mypy type checks your
     program.

     To minimize potential issues, we recommend that you:

       1. Make sure your overload variants are listed in the same order
          as the runtime checks (e.g.  isinstance(1) checks) in your
          implementation.

       2. Order your variants and runtime checks from most to least
          specific.  (See the following section for an example).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance


File: Mypy.info,  Node: Type checking the variants,  Next: Type checking the implementation,  Prev: Type checking calls to overloads,  Up: Function overloading

1.15.3.3 Type checking the variants
...................................

Mypy will perform several checks on your overload variant definitions to
ensure they behave as expected.  First, mypy will check and make sure
that no overload variant is shadowing a subsequent one.  For example,
consider the following function which adds together two ‘Expression’
objects, and contains a special-case to handle receiving two ‘Literal’
types:

     from typing import overload, Union

     class Expression:
         # ...snip...

     class Literal(Expression):
         # ...snip...

     # Warning -- the first overload variant shadows the second!

     @overload
     def add(left: Expression, right: Expression) -> Expression: ...

     @overload
     def add(left: Literal, right: Literal) -> Literal: ...

     def add(left: Expression, right: Expression) -> Expression:
         # ...snip...

While this code snippet is technically type-safe, it does contain an
anti-pattern: the second variant will never be selected!  If we try
calling ‘add(Literal(3), Literal(4))’, mypy will always pick the first
variant and evaluate the function call to be of type ‘Expression’, not
‘Literal’.  This is because ‘Literal’ is a subtype of ‘Expression’,
which means the “pick the first match” rule will always halt after
considering the first overload.

Because having an overload variant that can never be matched is almost
certainly a mistake, mypy will report an error.  To fix the error, we
can either 1) delete the second overload or 2) swap the order of the
overloads:

     # Everything is ok now -- the variants are correctly ordered
     # from most to least specific.

     @overload
     def add(left: Literal, right: Literal) -> Literal: ...

     @overload
     def add(left: Expression, right: Expression) -> Expression: ...

     def add(left: Expression, right: Expression) -> Expression:
         # ...snip...

Mypy will also type check the different variants and flag any overloads
that have inherently unsafely overlapping variants.  For example,
consider the following unsafe overload definition:

     from typing import overload, Union

     @overload
     def unsafe_func(x: int) -> int: ...

     @overload
     def unsafe_func(x: object) -> str: ...

     def unsafe_func(x: object) -> Union[int, str]:
         if isinstance(x, int):
             return 42
         else:
             return "some string"

On the surface, this function definition appears to be fine.  However,
it will result in a discrepancy between the inferred type and the actual
runtime type when we try using it like so:

     some_obj: object = 42
     unsafe_func(some_obj) + " danger danger"  # Type checks, yet crashes at runtime!

Since ‘some_obj’ is of type object(1), mypy will decide that
‘unsafe_func’ must return something of type ‘str’ and concludes the
above will type check.  But in reality, ‘unsafe_func’ will return an
int, causing the code to crash at runtime!

To prevent these kinds of issues, mypy will detect and prohibit
inherently unsafely overlapping overloads on a best-effort basis.  Two
variants are considered unsafely overlapping when both of the following
are true:

  1. All of the arguments of the first variant are compatible with the
     second.

  2. The return type of the first variant is ‘not’ compatible with (e.g.
     is not a subtype of) the second.

So in this example, the ‘int’ argument in the first variant is a subtype
of the ‘object’ argument in the second, yet the ‘int’ return type is not
a subtype of ‘str’.  Both conditions are true, so mypy will correctly
flag ‘unsafe_func’ as being unsafe.

However, mypy will not detect ‘all’ unsafe uses of overloads.  For
example, suppose we modify the above snippet so it calls ‘summarize’
instead of ‘unsafe_func’:

     some_list: list[str] = []
     summarize(some_list) + "danger danger"  # Type safe, yet crashes at runtime!

We run into a similar issue here.  This program type checks if we look
just at the annotations on the overloads.  But since ‘summarize(...)’ is
designed to be biased towards returning a float when it receives an
empty list, this program will actually crash during runtime.

The reason mypy does not flag definitions like ‘summarize’ as being
potentially unsafe is because if it did, it would be extremely difficult
to write a safe overload.  For example, suppose we define an overload
with two variants that accept types ‘A’ and ‘B’ respectively.  Even if
those two types were completely unrelated, the user could still
potentially trigger a runtime error similar to the ones above by passing
in a value of some third type ‘C’ that inherits from both ‘A’ and ‘B’.

Thankfully, these types of situations are relatively rare.  What this
does mean, however, is that you should exercise caution when designing
or using an overloaded function that can potentially receive values that
are an instance of two seemingly unrelated types.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#object


File: Mypy.info,  Node: Type checking the implementation,  Next: Conditional overloads,  Prev: Type checking the variants,  Up: Function overloading

1.15.3.4 Type checking the implementation
.........................................

The body of an implementation is type-checked against the type hints
provided on the implementation.  For example, in the ‘MyList’ example up
above, the code in the body is checked with argument list ‘index:
Union[int, slice]’ and a return type of ‘Union[T, Sequence[T]]’.  If
there are no annotations on the implementation, then the body is not
type checked.  If you want to force mypy to check the body anyways, use
the *note –check-untyped-defs: ea. flag (*note more details here: eb.).

The variants must also also be compatible with the implementation type
hints.  In the ‘MyList’ example, mypy will check that the parameter type
‘int’ and the return type ‘T’ are compatible with ‘Union[int, slice]’
and ‘Union[T, Sequence]’ for the first variant.  For the second variant
it verifies the parameter type ‘slice’ and the return type ‘Sequence[T]’
are compatible with ‘Union[int, slice]’ and ‘Union[T, Sequence]’.

     Note: The overload semantics documented above are new as of mypy
     0.620.

     Previously, mypy used to perform type erasure on all overload
     variants.  For example, the ‘summarize’ example from the previous
     section used to be illegal because ‘list[str]’ and ‘list[int]’ both
     erased to just ‘list[Any]’.  This restriction was removed in mypy
     0.620.

     Mypy also previously used to select the best matching variant using
     a different algorithm.  If this algorithm failed to find a match,
     it would default to returning ‘Any’.  The new algorithm uses the
     “pick the first match” rule and will fall back to returning ‘Any’
     only if the input arguments also contain ‘Any’.


File: Mypy.info,  Node: Conditional overloads,  Prev: Type checking the implementation,  Up: Function overloading

1.15.3.5 Conditional overloads
..............................

Sometimes it is useful to define overloads conditionally.  Common use
cases include types that are unavailable at runtime or that only exist
in a certain Python version.  All existing overload rules still apply.
For example, there must be at least two overloads.

     Note: Mypy can only infer a limited number of conditions.
     Supported ones currently include TYPE_CHECKING(1), ‘MYPY’, *note
     Python version and system platform checks: ed, *note –always-true:
     ee, and *note –always-false: ef. values.

     from typing import TYPE_CHECKING, Any, overload

     if TYPE_CHECKING:
         class A: ...
         class B: ...


     if TYPE_CHECKING:
         @overload
         def func(var: A) -> A: ...

         @overload
         def func(var: B) -> B: ...

     def func(var: Any) -> Any:
         return var


     reveal_type(func(A()))  # Revealed type is "A"

     # flags: --python-version 3.10
     import sys
     from typing import Any, overload

     class A: ...
     class B: ...
     class C: ...
     class D: ...


     if sys.version_info < (3, 7):
         @overload
         def func(var: A) -> A: ...

     elif sys.version_info >= (3, 10):
         @overload
         def func(var: B) -> B: ...

     else:
         @overload
         def func(var: C) -> C: ...

     @overload
     def func(var: D) -> D: ...

     def func(var: Any) -> Any:
         return var


     reveal_type(func(B()))  # Revealed type is "B"
     reveal_type(func(C()))  # No overload variant of "func" matches argument type "C"
         # Possible overload variants:
         #     def func(var: B) -> B
         #     def func(var: D) -> D
         # Revealed type is "Any"

     Note: In the last example, mypy is executed with *note
     –python-version 3.10: f0.  Therefore, the condition
     ‘sys.version_info >= (3, 10)’ will match and the overload for ‘B’
     will be added.  The overloads for ‘A’ and ‘C’ are ignored!  The
     overload for ‘D’ is not defined conditionally and thus is also
     added.

When mypy cannot infer a condition to be always ‘True’ or always
‘False’, an error is emitted.

     from typing import Any, overload

     class A: ...
     class B: ...


     def g(bool_var: bool) -> None:
         if bool_var:  # Condition can't be inferred, unable to merge overloads
             @overload
             def func(var: A) -> A: ...

             @overload
             def func(var: B) -> B: ...

         def func(var: Any) -> Any: ...

         reveal_type(func(A()))  # Revealed type is "Any"

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/typing.html#typing.TYPE_CHECKING


File: Mypy.info,  Node: Advanced uses of self-types,  Next: Typing async/await,  Prev: Function overloading,  Up: More types

1.15.4 Advanced uses of self-types
----------------------------------

Normally, mypy doesn’t require annotations for the first arguments of
instance and class methods.  However, they may be needed to have more
precise static typing for certain programming patterns.

* Menu:

* Restricted methods in generic classes::
* Mixin classes::
* Precise typing of alternative constructors::


File: Mypy.info,  Node: Restricted methods in generic classes,  Next: Mixin classes,  Up: Advanced uses of self-types

1.15.4.1 Restricted methods in generic classes
..............................................

In generic classes some methods may be allowed to be called only for
certain values of type arguments:

     T = TypeVar('T')

     class Tag(Generic[T]):
         item: T
         def uppercase_item(self: Tag[str]) -> str:
             return self.item.upper()

     def label(ti: Tag[int], ts: Tag[str]) -> None:
         ti.uppercase_item()  # E: Invalid self argument "Tag[int]" to attribute function
                              # "uppercase_item" with type "Callable[[Tag[str]], str]"
         ts.uppercase_item()  # This is OK

This pattern also allows matching on nested types in situations where
the type argument is itself generic:

     T = TypeVar('T', covariant=True)
     S = TypeVar('S')

      class Storage(Generic[T]):
          def __init__(self, content: T) -> None:
              self.content = content
          def first_chunk(self: Storage[Sequence[S]]) -> S:
              return self.content[0]

      page: Storage[list[str]]
      page.first_chunk()  # OK, type is "str"

      Storage(0).first_chunk()  # Error: Invalid self argument "Storage[int]" to attribute function
                                # "first_chunk" with type "Callable[[Storage[Sequence[S]]], S]"

Finally, one can use overloads on self-type to express precise types of
some tricky methods:

     T = TypeVar('T')

     class Tag(Generic[T]):
         @overload
         def export(self: Tag[str]) -> str: ...
         @overload
         def export(self, converter: Callable[[T], str]) -> str: ...

         def export(self, converter=None):
             if isinstance(self.item, str):
                 return self.item
             return converter(self.item)

In particular, an __init__()(1) method overloaded on self-type may be
useful to annotate generic class constructors where type arguments
depend on constructor parameters in a non-trivial way, see e.g.
Popen(2).

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (2) 
https://docs.python.org/3/library/subprocess.html#subprocess.Popen


File: Mypy.info,  Node: Mixin classes,  Next: Precise typing of alternative constructors,  Prev: Restricted methods in generic classes,  Up: Advanced uses of self-types

1.15.4.2 Mixin classes
......................

Using host class protocol as a self-type in mixin methods allows more
code re-usability for static typing of mixin classes.  For example, one
can define a protocol that defines common functionality for host classes
instead of adding required abstract methods to every mixin:

     class Lockable(Protocol):
         @property
         def lock(self) -> Lock: ...

     class AtomicCloseMixin:
         def atomic_close(self: Lockable) -> int:
             with self.lock:
                 # perform actions

     class AtomicOpenMixin:
         def atomic_open(self: Lockable) -> int:
             with self.lock:
                 # perform actions

     class File(AtomicCloseMixin, AtomicOpenMixin):
         def __init__(self) -> None:
             self.lock = Lock()

     class Bad(AtomicCloseMixin):
         pass

     f = File()
     b: Bad
     f.atomic_close()  # OK
     b.atomic_close()  # Error: Invalid self type for "atomic_close"

Note that the explicit self-type is ‘required’ to be a protocol whenever
it is not a supertype of the current class.  In this case mypy will
check the validity of the self-type only at the call site.


File: Mypy.info,  Node: Precise typing of alternative constructors,  Prev: Mixin classes,  Up: Advanced uses of self-types

1.15.4.3 Precise typing of alternative constructors
...................................................

Some classes may define alternative constructors.  If these classes are
generic, self-type allows giving them precise signatures:

     T = TypeVar('T')

     class Base(Generic[T]):
         Q = TypeVar('Q', bound='Base[T]')

         def __init__(self, item: T) -> None:
             self.item = item

         @classmethod
         def make_pair(cls: Type[Q], item: T) -> tuple[Q, Q]:
             return cls(item), cls(item)

     class Sub(Base[T]):
         ...

     pair = Sub.make_pair('yes')  # Type is "tuple[Sub[str], Sub[str]]"
     bad = Sub[int].make_pair('no')  # Error: Argument 1 to "make_pair" of "Base"
                                     # has incompatible type "str"; expected "int"


File: Mypy.info,  Node: Typing async/await,  Next: TypedDict,  Prev: Advanced uses of self-types,  Up: More types

1.15.5 Typing async/await
-------------------------

Mypy supports the ability to type coroutines that use the ‘async/await’
syntax introduced in Python 3.5.  For more information regarding
coroutines and this new syntax, see PEP 492(1).

Functions defined using ‘async def’ are typed just like normal
functions.  The return type annotation should be the same as the type of
the value you expect to get back when ‘await’-ing the coroutine.

     import asyncio

     async def format_string(tag: str, count: int) -> str:
         return f'T-minus {count} ({tag})'

     async def countdown_1(tag: str, count: int) -> str:
         while count > 0:
             my_str = await format_string(tag, count)  # has type 'str'
             print(my_str)
             await asyncio.sleep(0.1)
             count -= 1
         return "Blastoff!"

     loop = asyncio.get_event_loop()
     loop.run_until_complete(countdown_1("Millennium Falcon", 5))
     loop.close()

The result of calling an ‘async def’ function ‘without awaiting’ will be
a value of type Coroutine[Any, Any, T](2), which is a subtype of
Awaitable[T](3):

     my_coroutine = countdown_1("Millennium Falcon", 5)
     reveal_type(my_coroutine)  # has type 'Coroutine[Any, Any, str]'

     Note: *note reveal_type(): f6. displays the inferred static type of
     an expression.

You may also choose to create a subclass of Awaitable(4) instead:

     from typing import Any, Awaitable, Generator
     import asyncio

     class MyAwaitable(Awaitable[str]):
         def __init__(self, tag: str, count: int) -> None:
             self.tag = tag
             self.count = count

         def __await__(self) -> Generator[Any, None, str]:
             for i in range(n, 0, -1):
                 print(f'T-minus {i} ({tag})')
                 yield from asyncio.sleep(0.1)
             return "Blastoff!"

     def countdown_3(tag: str, count: int) -> Awaitable[str]:
         return MyAwaitable(tag, count)

     loop = asyncio.get_event_loop()
     loop.run_until_complete(countdown_3("Heart of Gold", 5))
     loop.close()

To create an iterable coroutine, subclass AsyncIterator(5):

     from typing import Optional, AsyncIterator
     import asyncio

     class arange(AsyncIterator[int]):
         def __init__(self, start: int, stop: int, step: int) -> None:
             self.start = start
             self.stop = stop
             self.step = step
             self.count = start - step

         def __aiter__(self) -> AsyncIterator[int]:
             return self

         async def __anext__(self) -> int:
             self.count += self.step
             if self.count == self.stop:
                 raise StopAsyncIteration
             else:
                 return self.count

     async def countdown_4(tag: str, n: int) -> str:
         async for i in arange(n, 0, -1):
             print(f'T-minus {i} ({tag})')
             await asyncio.sleep(0.1)
         return "Blastoff!"

     loop = asyncio.get_event_loop()
     loop.run_until_complete(countdown_4("Serenity", 5))
     loop.close()

If you use coroutines in legacy code that was originally written for
Python 3.4, which did not support the ‘async def’ syntax, you would
instead use the @asyncio.coroutine(6) decorator to convert a generator
into a coroutine, and use a generator type as the return type:

     from typing import Any, Generator
     import asyncio

     @asyncio.coroutine
     def countdown_2(tag: str, count: int) -> Generator[Any, None, str]:
         while count > 0:
             print(f'T-minus {count} ({tag})')
             yield from asyncio.sleep(0.1)
             count -= 1
         return "Blastoff!"

     loop = asyncio.get_event_loop()
     loop.run_until_complete(countdown_2("USS Enterprise", 5))
     loop.close()

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0492/

   (2) https://docs.python.org/3/library/typing.html#typing.Coroutine

   (3) https://docs.python.org/3/library/typing.html#typing.Awaitable

   (4) https://docs.python.org/3/library/typing.html#typing.Awaitable

   (5) 
https://docs.python.org/3/library/typing.html#typing.AsyncIterator

   (6) 
https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine


File: Mypy.info,  Node: TypedDict,  Prev: Typing async/await,  Up: More types

1.15.6 TypedDict
----------------

Python programs often use dictionaries with string keys to represent
objects.  Here is a typical example:

     movie = {'name': 'Blade Runner', 'year': 1982}

Only a fixed set of string keys is expected (‘'name'’ and ‘'year'’
above), and each key has an independent value type (‘str’ for ‘'name'’
and ‘int’ for ‘'year'’ above).  We’ve previously seen the ‘dict[K, V]’
type, which lets you declare uniform dictionary types, where every value
has the same type, and arbitrary keys are supported.  This is clearly
not a good fit for ‘movie’ above.  Instead, you can use a ‘TypedDict’ to
give a precise type for objects like ‘movie’, where the type of each
dictionary value depends on the key:

     from typing_extensions import TypedDict

     Movie = TypedDict('Movie', {'name': str, 'year': int})

     movie: Movie = {'name': 'Blade Runner', 'year': 1982}

‘Movie’ is a ‘TypedDict’ type with two items: ‘'name'’ (with type ‘str’)
and ‘'year'’ (with type ‘int’).  Note that we used an explicit type
annotation for the ‘movie’ variable.  This type annotation is important
– without it, mypy will try to infer a regular, uniform dict(1) type for
‘movie’, which is not what we want here.

     Note: If you pass a ‘TypedDict’ object as an argument to a
     function, no type annotation is usually necessary since mypy can
     infer the desired type based on the declared argument type.  Also,
     if an assignment target has been previously defined, and it has a
     ‘TypedDict’ type, mypy will treat the assigned value as a
     ‘TypedDict’, not dict(2).

Now mypy will recognize these as valid:

     name = movie['name']  # Okay; type of name is str
     year = movie['year']  # Okay; type of year is int

Mypy will detect an invalid key as an error:

     director = movie['director']  # Error: 'director' is not a valid key

Mypy will also reject a runtime-computed expression as a key, as it
can’t verify that it’s a valid key.  You can only use string literals as
‘TypedDict’ keys.

The ‘TypedDict’ type object can also act as a constructor.  It returns a
normal dict(3) object at runtime – a ‘TypedDict’ does not define a new
runtime type:

     toy_story = Movie(name='Toy Story', year=1995)

This is equivalent to just constructing a dictionary directly using ‘{
... }’ or ‘dict(key=value, ...)’.  The constructor form is sometimes
convenient, since it can be used without a type annotation, and it also
makes the type of the object explicit.

Like all types, ‘TypedDict’s can be used as components to build
arbitrarily complex types.  For example, you can define nested
‘TypedDict’s and containers with ‘TypedDict’ items.  Unlike most other
types, mypy uses structural compatibility checking (or structural
subtyping) with ‘TypedDict’s.  A ‘TypedDict’ object with extra items is
compatible with (a subtype of) a narrower ‘TypedDict’, assuming item
types are compatible (‘totality’ also affects subtyping, as discussed
below).

A ‘TypedDict’ object is not a subtype of the regular ‘dict[...]’ type
(and vice versa), since dict(4) allows arbitrary keys to be added and
removed, unlike ‘TypedDict’.  However, any ‘TypedDict’ object is a
subtype of (that is, compatible with) ‘Mapping[str, object]’, since
Mapping(5) only provides read-only access to the dictionary items:

     def print_typed_dict(obj: Mapping[str, object]) -> None:
         for key, value in obj.items():
             print(f'{key}: {value}')

     print_typed_dict(Movie(name='Toy Story', year=1995))  # OK

     Note: Unless you are on Python 3.8 or newer (where ‘TypedDict’ is
     available in standard library typing(6) module) you need to install
     ‘typing_extensions’ using pip to use ‘TypedDict’:

          python3 -m pip install --upgrade typing-extensions

* Menu:

* Totality::
* Supported operations::
* Class-based syntax::
* Mixing required and non-required items::
* Unions of TypedDicts::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#dict

   (2) https://docs.python.org/3/library/stdtypes.html#dict

   (3) https://docs.python.org/3/library/stdtypes.html#dict

   (4) https://docs.python.org/3/library/stdtypes.html#dict

   (5) https://docs.python.org/3/library/typing.html#typing.Mapping

   (6) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Totality,  Next: Supported operations,  Up: TypedDict

1.15.6.1 Totality
.................

By default mypy ensures that a ‘TypedDict’ object has all the specified
keys.  This will be flagged as an error:

     # Error: 'year' missing
     toy_story: Movie = {'name': 'Toy Story'}

Sometimes you want to allow keys to be left out when creating a
‘TypedDict’ object.  You can provide the ‘total=False’ argument to
‘TypedDict(...)’ to achieve this:

     GuiOptions = TypedDict(
         'GuiOptions', {'language': str, 'color': str}, total=False)
     options: GuiOptions = {}  # Okay
     options['language'] = 'en'

You may need to use get()(1) to access items of a partial (non-total)
‘TypedDict’, since indexing using ‘[]’ could fail at runtime.  However,
mypy still lets use ‘[]’ with a partial ‘TypedDict’ – you just need to
be careful with it, as it could result in a KeyError(2).  Requiring
get()(3) everywhere would be too cumbersome.  (Note that you are free to
use get()(4) with total ‘TypedDict’s as well.)

Keys that aren’t required are shown with a ‘?’ in error messages:

     # Revealed type is "TypedDict('GuiOptions', {'language'?: builtins.str,
     #                                            'color'?: builtins.str})"
     reveal_type(options)

Totality also affects structural compatibility.  You can’t use a partial
‘TypedDict’ when a total one is expected.  Also, a total ‘TypedDict’ is
not valid when a partial one is expected.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/stdtypes.html#dict.get

   (2) https://docs.python.org/3/library/exceptions.html#KeyError

   (3) https://docs.python.org/3/library/stdtypes.html#dict.get

   (4) https://docs.python.org/3/library/stdtypes.html#dict.get


File: Mypy.info,  Node: Supported operations,  Next: Class-based syntax,  Prev: Totality,  Up: TypedDict

1.15.6.2 Supported operations
.............................

‘TypedDict’ objects support a subset of dictionary operations and
methods.  You must use string literals as keys when calling most of the
methods, as otherwise mypy won’t be able to check that the key is valid.
List of supported operations:

   * Anything included in Mapping(1):

        * ‘d[key]’

        * ‘key in d’

        * ‘len(d)’

        * ‘for key in d’ (iteration)

        * d.get(key[, default])(2)

        * d.keys()(3)

        * d.values()(4)

        * d.items()(5)

   * d.copy()(6)

   * d.setdefault(key, default)(7)

   * d1.update(d2)(8)

   * d.pop(key[, default])(9) (partial ‘TypedDict’s only)

   * ‘del d[key]’ (partial ‘TypedDict’s only)

     Note: clear()(10) and popitem()(11) are not supported since they
     are unsafe – they could delete required ‘TypedDict’ items that are
     not visible to mypy because of structural subtyping.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Mapping

   (2) https://docs.python.org/3/library/stdtypes.html#dict.get

   (3) https://docs.python.org/3/library/stdtypes.html#dict.keys

   (4) https://docs.python.org/3/library/stdtypes.html#dict.values

   (5) https://docs.python.org/3/library/stdtypes.html#dict.items

   (6) https://docs.python.org/3/library/stdtypes.html#dict.copy

   (7) https://docs.python.org/3/library/stdtypes.html#dict.setdefault

   (8) https://docs.python.org/3/library/stdtypes.html#dict.update

   (9) https://docs.python.org/3/library/stdtypes.html#dict.pop

   (10) https://docs.python.org/3/library/stdtypes.html#dict.clear

   (11) https://docs.python.org/3/library/stdtypes.html#dict.popitem


File: Mypy.info,  Node: Class-based syntax,  Next: Mixing required and non-required items,  Prev: Supported operations,  Up: TypedDict

1.15.6.3 Class-based syntax
...........................

An alternative, class-based syntax to define a ‘TypedDict’ is supported
in Python 3.6 and later:

     from typing_extensions import TypedDict

     class Movie(TypedDict):
         name: str
         year: int

The above definition is equivalent to the original ‘Movie’ definition.
It doesn’t actually define a real class.  This syntax also supports a
form of inheritance – subclasses can define additional items.  However,
this is primarily a notational shortcut.  Since mypy uses structural
compatibility with ‘TypedDict’s, inheritance is not required for
compatibility.  Here is an example of inheritance:

     class Movie(TypedDict):
         name: str
         year: int

     class BookBasedMovie(Movie):
         based_on: str

Now ‘BookBasedMovie’ has keys ‘name’, ‘year’ and ‘based_on’.


File: Mypy.info,  Node: Mixing required and non-required items,  Next: Unions of TypedDicts,  Prev: Class-based syntax,  Up: TypedDict

1.15.6.4 Mixing required and non-required items
...............................................

In addition to allowing reuse across ‘TypedDict’ types, inheritance also
allows you to mix required and non-required (using ‘total=False’) items
in a single ‘TypedDict’.  Example:

     class MovieBase(TypedDict):
         name: str
         year: int

     class Movie(MovieBase, total=False):
         based_on: str

Now ‘Movie’ has required keys ‘name’ and ‘year’, while ‘based_on’ can be
left out when constructing an object.  A ‘TypedDict’ with a mix of
required and non-required keys, such as ‘Movie’ above, will only be
compatible with another ‘TypedDict’ if all required keys in the other
‘TypedDict’ are required keys in the first ‘TypedDict’, and all
non-required keys of the other ‘TypedDict’ are also non-required keys in
the first ‘TypedDict’.


File: Mypy.info,  Node: Unions of TypedDicts,  Prev: Mixing required and non-required items,  Up: TypedDict

1.15.6.5 Unions of TypedDicts
.............................

Since TypedDicts are really just regular dicts at runtime, it is not
possible to use ‘isinstance’ checks to distinguish between different
variants of a Union of TypedDict in the same way you can with regular
objects.

Instead, you can use the *note tagged union pattern: fe.  The referenced
section of the docs has a full description with an example, but in
short, you will need to give each TypedDict the same key where each
value has a unique *note Literal type: ff.  Then, check that key to
distinguish between your TypedDicts.


File: Mypy.info,  Node: Literal types and Enums,  Next: Final names methods and classes,  Prev: More types,  Up: Contents

1.16 Literal types and Enums
============================

* Menu:

* Literal types::
* Enums::


File: Mypy.info,  Node: Literal types,  Next: Enums,  Up: Literal types and Enums

1.16.1 Literal types
--------------------

Literal types let you indicate that an expression is equal to some
specific primitive value.  For example, if we annotate a variable with
type ‘Literal["foo"]’, mypy will understand that variable is not only of
type ‘str’, but is also equal to specifically the string ‘"foo"’.

This feature is primarily useful when annotating functions that behave
differently based on the exact value the caller provides.  For example,
suppose we have a function ‘fetch_data(...)’ that returns ‘bytes’ if the
first argument is ‘True’, and ‘str’ if it’s ‘False’.  We can construct a
precise type signature for this function using ‘Literal[...]’ and
overloads:

     from typing import overload, Union, Literal

     # The first two overloads use Literal[...] so we can
     # have precise return types:

     @overload
     def fetch_data(raw: Literal[True]) -> bytes: ...
     @overload
     def fetch_data(raw: Literal[False]) -> str: ...

     # The last overload is a fallback in case the caller
     # provides a regular bool:

     @overload
     def fetch_data(raw: bool) -> Union[bytes, str]: ...

     def fetch_data(raw: bool) -> Union[bytes, str]:
         # Implementation is omitted
         ...

     reveal_type(fetch_data(True))        # Revealed type is "bytes"
     reveal_type(fetch_data(False))       # Revealed type is "str"

     # Variables declared without annotations will continue to have an
     # inferred type of 'bool'.

     variable = True
     reveal_type(fetch_data(variable))    # Revealed type is "Union[bytes, str]"

     Note: The examples in this page import ‘Literal’ as well as ‘Final’
     and ‘TypedDict’ from the ‘typing’ module.  These types were added
     to ‘typing’ in Python 3.8, but are also available for use in Python
     3.4 - 3.7 via the ‘typing_extensions’ package.

* Menu:

* Parameterizing Literals::
* Declaring literal variables::
* Intelligent indexing::
* Tagged unions::
* Exhaustiveness checking::
* Limitations::


File: Mypy.info,  Node: Parameterizing Literals,  Next: Declaring literal variables,  Up: Literal types

1.16.1.1 Parameterizing Literals
................................

Literal types may contain one or more literal bools, ints, strs, bytes,
and enum values.  However, literal types ‘cannot’ contain arbitrary
expressions: types like ‘Literal[my_string.trim()]’, ‘Literal[x > 3]’,
or ‘Literal[3j + 4]’ are all illegal.

Literals containing two or more values are equivalent to the union of
those values.  So, ‘Literal[-3, b"foo", MyEnum.A]’ is equivalent to
‘Union[Literal[-3], Literal[b"foo"], Literal[MyEnum.A]]’.  This makes
writing more complex types involving literals a little more convenient.

Literal types may also contain ‘None’.  Mypy will treat ‘Literal[None]’
as being equivalent to just ‘None’.  This means that ‘Literal[4, None]’,
‘Union[Literal[4], None]’, and ‘Optional[Literal[4]]’ are all
equivalent.

Literals may also contain aliases to other literal types.  For example,
the following program is legal:

     PrimaryColors = Literal["red", "blue", "yellow"]
     SecondaryColors = Literal["purple", "green", "orange"]
     AllowedColors = Literal[PrimaryColors, SecondaryColors]

     def paint(color: AllowedColors) -> None: ...

     paint("red")        # Type checks!
     paint("turquoise")  # Does not type check

Literals may not contain any other kind of type or expression.  This
means doing ‘Literal[my_instance]’, ‘Literal[Any]’, ‘Literal[3.14]’, or
‘Literal[{"foo": 2, "bar": 5}]’ are all illegal.


File: Mypy.info,  Node: Declaring literal variables,  Next: Intelligent indexing,  Prev: Parameterizing Literals,  Up: Literal types

1.16.1.2 Declaring literal variables
....................................

You must explicitly add an annotation to a variable to declare that it
has a literal type:

     a: Literal[19] = 19
     reveal_type(a)          # Revealed type is "Literal[19]"

In order to preserve backwards-compatibility, variables without this
annotation are ‘not’ assumed to be literals:

     b = 19
     reveal_type(b)          # Revealed type is "int"

If you find repeating the value of the variable in the type hint to be
tedious, you can instead change the variable to be ‘Final’ (see *note
Final names, methods and classes: 105.):

     from typing import Final, Literal

     def expects_literal(x: Literal[19]) -> None: pass

     c: Final = 19

     reveal_type(c)          # Revealed type is "Literal[19]?"
     expects_literal(c)      # ...and this type checks!

If you do not provide an explicit type in the ‘Final’, the type of ‘c’
becomes ‘context-sensitive’: mypy will basically try “substituting” the
original assigned value whenever it’s used before performing type
checking.  This is why the revealed type of ‘c’ is ‘Literal[19]?’: the
question mark at the end reflects this context-sensitive nature.

For example, mypy will type check the above program almost as if it were
written like so:

     from typing import Final, Literal

     def expects_literal(x: Literal[19]) -> None: pass

     reveal_type(19)
     expects_literal(19)

This means that while changing a variable to be ‘Final’ is not quite the
same thing as adding an explicit ‘Literal[...]’ annotation, it often
leads to the same effect in practice.

The main cases where the behavior of context-sensitive vs true literal
types differ are when you try using those types in places that are not
explicitly expecting a ‘Literal[...]’.  For example, compare and
contrast what happens when you try appending these types to a list:

     from typing import Final, Literal

     a: Final = 19
     b: Literal[19] = 19

     # Mypy will choose to infer list[int] here.
     list_of_ints = []
     list_of_ints.append(a)
     reveal_type(list_of_ints)  # Revealed type is "list[int]"

     # But if the variable you're appending is an explicit Literal, mypy
     # will infer list[Literal[19]].
     list_of_lits = []
     list_of_lits.append(b)
     reveal_type(list_of_lits)  # Revealed type is "list[Literal[19]]"


File: Mypy.info,  Node: Intelligent indexing,  Next: Tagged unions,  Prev: Declaring literal variables,  Up: Literal types

1.16.1.3 Intelligent indexing
.............................

We can use Literal types to more precisely index into structured
heterogeneous types such as tuples, NamedTuples, and TypedDicts.  This
feature is known as ‘intelligent indexing’.

For example, when we index into a tuple using some int, the inferred
type is normally the union of the tuple item types.  However, if we want
just the type corresponding to some particular index, we can use Literal
types like so:

     from typing import TypedDict

     tup = ("foo", 3.4)

     # Indexing with an int literal gives us the exact type for that index
     reveal_type(tup[0])  # Revealed type is "str"

     # But what if we want the index to be a variable? Normally mypy won't
     # know exactly what the index is and so will return a less precise type:
     int_index = 0
     reveal_type(tup[int_index])  # Revealed type is "Union[str, float]"

     # But if we use either Literal types or a Final int, we can gain back
     # the precision we originally had:
     lit_index: Literal[0] = 0
     fin_index: Final = 0
     reveal_type(tup[lit_index])  # Revealed type is "str"
     reveal_type(tup[fin_index])  # Revealed type is "str"

     # We can do the same thing with with TypedDict and str keys:
     class MyDict(TypedDict):
         name: str
         main_id: int
         backup_id: int

     d: MyDict = {"name": "Saanvi", "main_id": 111, "backup_id": 222}
     name_key: Final = "name"
     reveal_type(d[name_key])  # Revealed type is "str"

     # You can also index using unions of literals
     id_key: Literal["main_id", "backup_id"]
     reveal_type(d[id_key])    # Revealed type is "int"


File: Mypy.info,  Node: Tagged unions,  Next: Exhaustiveness checking,  Prev: Intelligent indexing,  Up: Literal types

1.16.1.4 Tagged unions
......................

When you have a union of types, you can normally discriminate between
each type in the union by using ‘isinstance’ checks.  For example, if
you had a variable ‘x’ of type ‘Union[int, str]’, you could write some
code that runs only if ‘x’ is an int by doing ‘if isinstance(x, int):
...’.

However, it is not always possible or convenient to do this.  For
example, it is not possible to use ‘isinstance’ to distinguish between
two different TypedDicts since at runtime, your variable will simply be
just a dict.

Instead, what you can do is ‘label’ or ‘tag’ your TypedDicts with a
distinct Literal type.  Then, you can discriminate between each kind of
TypedDict by checking the label:

     from typing import Literal, TypedDict, Union

     class NewJobEvent(TypedDict):
         tag: Literal["new-job"]
         job_name: str
         config_file_path: str

     class CancelJobEvent(TypedDict):
         tag: Literal["cancel-job"]
         job_id: int

     Event = Union[NewJobEvent, CancelJobEvent]

     def process_event(event: Event) -> None:
         # Since we made sure both TypedDicts have a key named 'tag', it's
         # safe to do 'event["tag"]'. This expression normally has the type
         # Literal["new-job", "cancel-job"], but the check below will narrow
         # the type to either Literal["new-job"] or Literal["cancel-job"].
         #
         # This in turns narrows the type of 'event' to either NewJobEvent
         # or CancelJobEvent.
         if event["tag"] == "new-job":
             print(event["job_name"])
         else:
             print(event["job_id"])

While this feature is mostly useful when working with TypedDicts, you
can also use the same technique with regular objects, tuples, or
namedtuples.

Similarly, tags do not need to be specifically str Literals: they can be
any type you can normally narrow within ‘if’ statements and the like.
For example, you could have your tags be int or Enum Literals or even
regular classes you narrow using ‘isinstance()’:

     from typing import Generic, TypeVar, Union

     T = TypeVar('T')

     class Wrapper(Generic[T]):
         def __init__(self, inner: T) -> None:
             self.inner = inner

     def process(w: Union[Wrapper[int], Wrapper[str]]) -> None:
         # Doing `if isinstance(w, Wrapper[int])` does not work: isinstance requires
         # that the second argument always be an *erased* type, with no generics.
         # This is because generics are a typing-only concept and do not exist at
         # runtime in a way `isinstance` can always check.
         #
         # However, we can side-step this by checking the type of `w.inner` to
         # narrow `w` itself:
         if isinstance(w.inner, int):
             reveal_type(w)  # Revealed type is "Wrapper[int]"
         else:
             reveal_type(w)  # Revealed type is "Wrapper[str]"

This feature is sometimes called “sum types” or “discriminated union
types” in other programming languages.


File: Mypy.info,  Node: Exhaustiveness checking,  Next: Limitations,  Prev: Tagged unions,  Up: Literal types

1.16.1.5 Exhaustiveness checking
................................

You may want to check that some code covers all possible ‘Literal’ or
‘Enum’ cases.  Example:

     from typing import Literal

     PossibleValues = Literal['one', 'two']

     def validate(x: PossibleValues) -> bool:
         if x == 'one':
             return True
         elif x == 'two':
             return False
         raise ValueError(f'Invalid value: {x}')

     assert validate('one') is True
     assert validate('two') is False

In the code above, it’s easy to make a mistake.  You can add a new
literal value to ‘PossibleValues’ but forget to handle it in the
‘validate’ function:

     PossibleValues = Literal['one', 'two', 'three']

Mypy won’t catch that ‘'three'’ is not covered.  If you want mypy to
perform an exhaustiveness check, you need to update your code to use an
‘assert_never()’ check:

     from typing import Literal, NoReturn

     PossibleValues = Literal['one', 'two']

     def assert_never(value: NoReturn) -> NoReturn:
         # This also works at runtime as well
         assert False, f'This code should never be reached, got: {value}'

     def validate(x: PossibleValues) -> bool:
         if x == 'one':
             return True
         elif x == 'two':
             return False
         assert_never(x)

Now if you add a new value to ‘PossibleValues’ but don’t update
‘validate’, mypy will spot the error:

     PossibleValues = Literal['one', 'two', 'three']

     def validate(x: PossibleValues) -> bool:
         if x == 'one':
             return True
         elif x == 'two':
             return False
         # Error: Argument 1 to "assert_never" has incompatible type "Literal['three']";
         # expected "NoReturn"
         assert_never(x)

If runtime checking against unexpected values is not needed, you can
leave out the ‘assert_never’ call in the above example, and mypy will
still generate an error about function ‘validate’ returning without a
value:

     PossibleValues = Literal['one', 'two', 'three']

     # Error: Missing return statement
     def validate(x: PossibleValues) -> bool:
         if x == 'one':
             return True
         elif x == 'two':
             return False

Exhaustiveness checking is also supported for match statements (Python
3.10 and later):

     def validate(x: PossibleValues) -> bool:
         match x:
             case 'one':
                 return True
             case 'two':
                 return False
         assert_never(x)


File: Mypy.info,  Node: Limitations,  Prev: Exhaustiveness checking,  Up: Literal types

1.16.1.6 Limitations
....................

Mypy will not understand expressions that use variables of type
‘Literal[..]’ on a deep level.  For example, if you have a variable ‘a’
of type ‘Literal[3]’ and another variable ‘b’ of type ‘Literal[5]’, mypy
will infer that ‘a + b’ has type ‘int’, ‘not’ type ‘Literal[8]’.

The basic rule is that literal types are treated as just regular
subtypes of whatever type the parameter has.  For example, ‘Literal[3]’
is treated as a subtype of ‘int’ and so will inherit all of ‘int’’s
methods directly.  This means that ‘Literal[3].__add__’ accepts the same
arguments and has the same return type as ‘int.__add__’.


File: Mypy.info,  Node: Enums,  Prev: Literal types,  Up: Literal types and Enums

1.16.2 Enums
------------

Mypy has special support for enum.Enum(1) and its subclasses:
enum.IntEnum(2), enum.Flag(3), enum.IntFlag(4), and ‘enum.StrEnum’.

     from enum import Enum

     class Direction(Enum):
         up = 'up'
         down = 'down'

     reveal_type(Direction.up)  # Revealed type is "Literal[Direction.up]?"
     reveal_type(Direction.down)  # Revealed type is "Literal[Direction.down]?"

You can use enums to annotate types as you would expect:

     class Movement:
         def __init__(self, direction: Direction, speed: float) -> None:
             self.direction = direction
             self.speed = speed

     Movement(Direction.up, 5.0)  # ok
     Movement('up', 5.0)  # E: Argument 1 to "Movement" has incompatible type "str"; expected "Direction"

* Menu:

* Exhaustiveness checking: Exhaustiveness checking<2>.
* Extra Enum checks::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/enum.html#enum.Enum

   (2) https://docs.python.org/3/library/enum.html#enum.IntEnum

   (3) https://docs.python.org/3/library/enum.html#enum.Flag

   (4) https://docs.python.org/3/library/enum.html#enum.IntFlag


File: Mypy.info,  Node: Exhaustiveness checking<2>,  Next: Extra Enum checks,  Up: Enums

1.16.2.1 Exhaustiveness checking
................................

Similar to ‘Literal’ types, ‘Enum’ supports exhaustiveness checking.
Let’s start with a definition:

     from enum import Enum
     from typing import NoReturn

     def assert_never(value: NoReturn) -> NoReturn:
         # This also works in runtime as well:
         assert False, f'This code should never be reached, got: {value}'

     class Direction(Enum):
         up = 'up'
         down = 'down'

Now, let’s use an exhaustiveness check:

     def choose_direction(direction: Direction) -> None:
         if direction is Direction.up:
             reveal_type(direction)  # N: Revealed type is "Literal[Direction.up]"
             print('Going up!')
             return
         elif direction is Direction.down:
             print('Down')
             return
         # This line is never reached
         assert_never(direction)

If we forget to handle one of the cases, mypy will generate an error:

     def choose_direction(direction: Direction) -> None:
         if direction == Direction.up:
             print('Going up!')
             return
         assert_never(direction)  # E: Argument 1 to "assert_never" has incompatible type "Direction"; expected "NoReturn"

Exhaustiveness checking is also supported for match statements (Python
3.10 and later).


File: Mypy.info,  Node: Extra Enum checks,  Prev: Exhaustiveness checking<2>,  Up: Enums

1.16.2.2 Extra Enum checks
..........................

Mypy also tries to support special features of ‘Enum’ the same way
Python’s runtime does:

   - Any ‘Enum’ class with values is implicitly *note final: 105.  This
     is what happens in CPython:

          >>> class AllDirection(Direction):
          ...     left = 'left'
          ...     right = 'right'
          Traceback (most recent call last):
            ...
          TypeError: Other: cannot extend enumeration 'Some'

     Mypy also catches this error:

          class AllDirection(Direction):  # E: Cannot inherit from final class "Some"
              left = 'left'
              right = 'right'

   - All ‘Enum’ fields are implicitly ‘final’ as well.

          Direction.up = '^'  # E: Cannot assign to final attribute "up"

   - All field names are checked to be unique.

          class Some(Enum):
             x = 1
             x = 2  # E: Attempted to reuse member name "x" in Enum definition "Some"

   - Base classes have no conflicts and mixin types are correct.

          class WrongEnum(str, int, enum.Enum):
              # E: Only a single data type mixin is allowed for Enum subtypes, found extra "int"
              ...

          class MixinAfterEnum(enum.Enum, Mixin): # E: No base classes are allowed after "enum.Enum"
              ...


File: Mypy.info,  Node: Final names methods and classes,  Next: Metaclasses,  Prev: Literal types and Enums,  Up: Contents

1.17 Final names, methods and classes
=====================================

This section introduces these related features:

  1. ‘Final names’ are variables or attributes that should not be
     reassigned after initialization.  They are useful for declaring
     constants.

  2. ‘Final methods’ should not be overridden in a subclass.

  3. ‘Final classes’ should not be subclassed.

All of these are only enforced by mypy, and only in annotated code.
There is no runtime enforcement by the Python runtime.

     Note: The examples in this page import ‘Final’ and ‘final’ from the
     ‘typing’ module.  These types were added to ‘typing’ in Python 3.8,
     but are also available for use in Python 3.4 - 3.7 via the
     ‘typing_extensions’ package.

* Menu:

* Final names::
* Final methods::
* Final classes::


File: Mypy.info,  Node: Final names,  Next: Final methods,  Up: Final names methods and classes

1.17.1 Final names
------------------

You can use the ‘typing.Final’ qualifier to indicate that a name or
attribute should not be reassigned, redefined, or overridden.  This is
often useful for module and class level constants as a way to prevent
unintended modification.  Mypy will prevent further assignments to final
names in type-checked code:

     from typing import Final

     RATE: Final = 3_000

     class Base:
         DEFAULT_ID: Final = 0

     RATE = 300  # Error: can't assign to final attribute
     Base.DEFAULT_ID = 1  # Error: can't override a final attribute

Another use case for final attributes is to protect certain attributes
from being overridden in a subclass:

     from typing import Final

     class Window:
         BORDER_WIDTH: Final = 2.5
         ...

     class ListView(Window):
         BORDER_WIDTH = 3  # Error: can't override a final attribute

You can use @property(1) to make an attribute read-only, but unlike
‘Final’, it doesn’t work with module attributes, and it doesn’t prevent
overriding in subclasses.

* Menu:

* Syntax variants::
* Details of using Final::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#property


File: Mypy.info,  Node: Syntax variants,  Next: Details of using Final,  Up: Final names

1.17.1.1 Syntax variants
........................

You can use ‘Final’ in one of these forms:

   * You can provide an explicit type using the syntax ‘Final[<type>]’.
     Example:

          ID: Final[int] = 1

     Here mypy will infer type ‘int’ for ‘ID’.

   * You can omit the type:

          ID: Final = 1

     Here mypy will infer type ‘Literal[1]’ for ‘ID’.  Note that unlike
     for generic classes this is ‘not’ the same as ‘Final[Any]’.

   * In class bodies and stub files you can omit the right hand side and
     just write ‘ID: Final[int]’.

   * Finally, you can write ‘self.id: Final = 1’ (also optionally with a
     type in square brackets).  This is allowed ‘only’ in __init__(1)
     methods, so that the final instance attribute is assigned only once
     when an instance is created.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__init__


File: Mypy.info,  Node: Details of using Final,  Prev: Syntax variants,  Up: Final names

1.17.1.2 Details of using ‘Final’
.................................

These are the two main rules for defining a final name:

   * There can be ‘at most one’ final declaration per module or class
     for a given attribute.  There can’t be separate class-level and
     instance-level constants with the same name.

   * There must be ‘exactly one’ assignment to a final name.

A final attribute declared in a class body without an initializer must
be initialized in the __init__(1) method (you can skip the initializer
in stub files):

     class ImmutablePoint:
         x: Final[int]
         y: Final[int]  # Error: final attribute without an initializer

         def __init__(self) -> None:
             self.x = 1  # Good

‘Final’ can only be used as the outermost type in assignments or
variable annotations.  Using it in any other position is an error.  In
particular, ‘Final’ can’t be used in annotations for function arguments:

     x: list[Final[int]] = []  # Error!

     def fun(x: Final[list[int]]) ->  None:  # Error!
         ...

‘Final’ and ClassVar(2) should not be used together.  Mypy will infer
the scope of a final declaration automatically depending on whether it
was initialized in the class body or in __init__(3).

A final attribute can’t be overridden by a subclass (even with another
explicit final declaration).  Note however that a final attribute can
override a read-only property:

     class Base:
         @property
         def ID(self) -> int: ...

     class Derived(Base):
         ID: Final = 1  # OK

Declaring a name as final only guarantees that the name will not be
re-bound to another value.  It doesn’t make the value immutable.  You
can use immutable ABCs and containers to prevent mutating such values:

     x: Final = ['a', 'b']
     x.append('c')  # OK

     y: Final[Sequence[str]] = ['a', 'b']
     y.append('x')  # Error: Sequence is immutable
     z: Final = ('a', 'b')  # Also an option

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (2) https://docs.python.org/3/library/typing.html#typing.ClassVar

   (3) 
https://docs.python.org/3/reference/datamodel.html#object.__init__


File: Mypy.info,  Node: Final methods,  Next: Final classes,  Prev: Final names,  Up: Final names methods and classes

1.17.2 Final methods
--------------------

Like with attributes, sometimes it is useful to protect a method from
overriding.  You can use the ‘typing.final’ decorator for this purpose:

     from typing import final

     class Base:
         @final
         def common_name(self) -> None:
             ...

     class Derived(Base):
         def common_name(self) -> None:  # Error: cannot override a final method
             ...

This ‘@final’ decorator can be used with instance methods, class
methods, static methods, and properties.

For overloaded methods you should add ‘@final’ on the implementation to
make it final (or on the first overload in stubs):

     from typing import Any, overload

     class Base:
         @overload
         def method(self) -> None: ...
         @overload
         def method(self, arg: int) -> int: ...
         @final
         def method(self, x=None):
             ...


File: Mypy.info,  Node: Final classes,  Prev: Final methods,  Up: Final names methods and classes

1.17.3 Final classes
--------------------

You can apply the ‘typing.final’ decorator to a class to indicate to
mypy that it should not be subclassed:

     from typing import final

     @final
     class Leaf:
         ...

     class MyLeaf(Leaf):  # Error: Leaf can't be subclassed
         ...

The decorator acts as a declaration for mypy (and as documentation for
humans), but it doesn’t actually prevent subclassing at runtime.

Here are some situations where using a final class may be useful:

   * A class wasn’t designed to be subclassed.  Perhaps subclassing
     would not work as expected, or subclassing would be error-prone.

   * Subclassing would make code harder to understand or maintain.  For
     example, you may want to prevent unnecessarily tight coupling
     between base classes and subclasses.

   * You want to retain the freedom to arbitrarily change the class
     implementation in the future, and these changes might break
     subclasses.

An abstract class that defines at least one abstract method or property
and has ‘@final’ decorator will generate an error from mypy, since those
attributes could never be implemented.

     from abc import ABCMeta, abstractmethod
     from typing import final

     @final
     class A(metaclass=ABCMeta):  # error: Final class A has abstract attributes "f"
         @abstractmethod
         def f(self, x: int) -> None: pass


File: Mypy.info,  Node: Metaclasses,  Next: Running mypy and managing imports,  Prev: Final names methods and classes,  Up: Contents

1.18 Metaclasses
================

A metaclass(1) is a class that describes the construction and behavior
of other classes, similarly to how classes describe the construction and
behavior of objects.  The default metaclass is type(2), but it’s
possible to use other metaclasses.  Metaclasses allows one to create “a
different kind of class”, such as Enum(3)s, NamedTuple(4)s and
singletons.

Mypy has some special understanding of ABCMeta(5) and ‘EnumMeta’.

* Menu:

* Defining a metaclass::
* Metaclass usage example::
* Gotchas and limitations of metaclass support::

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/reference/datamodel.html#metaclasses

   (2) https://docs.python.org/3/library/functions.html#type

   (3) https://docs.python.org/3/library/enum.html#enum.Enum

   (4) https://docs.python.org/3/library/typing.html#typing.NamedTuple

   (5) https://docs.python.org/3/library/abc.html#abc.ABCMeta


File: Mypy.info,  Node: Defining a metaclass,  Next: Metaclass usage example,  Up: Metaclasses

1.18.1 Defining a metaclass
---------------------------

     class M(type):
         pass

     class A(metaclass=M):
         pass


File: Mypy.info,  Node: Metaclass usage example,  Next: Gotchas and limitations of metaclass support,  Prev: Defining a metaclass,  Up: Metaclasses

1.18.2 Metaclass usage example
------------------------------

Mypy supports the lookup of attributes in the metaclass:

     from typing import Type, TypeVar, ClassVar
     T = TypeVar('T')

     class M(type):
         count: ClassVar[int] = 0

         def make(cls: Type[T]) -> T:
             M.count += 1
             return cls()

     class A(metaclass=M):
         pass

     a: A = A.make()  # make() is looked up at M; the result is an object of type A
     print(A.count)

     class B(A):
         pass

     b: B = B.make()  # metaclasses are inherited
     print(B.count + " objects were created")  # Error: Unsupported operand types for + ("int" and "str")


File: Mypy.info,  Node: Gotchas and limitations of metaclass support,  Prev: Metaclass usage example,  Up: Metaclasses

1.18.3 Gotchas and limitations of metaclass support
---------------------------------------------------

Note that metaclasses pose some requirements on the inheritance
structure, so it’s better not to combine metaclasses and class
hierarchies:

     class M1(type): pass
     class M2(type): pass

     class A1(metaclass=M1): pass
     class A2(metaclass=M2): pass

     class B1(A1, metaclass=M2): pass  # Mypy Error: metaclass conflict
     # At runtime the above definition raises an exception
     # TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases

     class B12(A1, A2): pass  # Mypy Error: metaclass conflict

     # This can be solved via a common metaclass subtype:
     class CorrectMeta(M1, M2): pass
     class B2(A1, A2, metaclass=CorrectMeta): pass  # OK, runtime is also OK

   * Mypy does not understand dynamically-computed metaclasses, such as
     ‘class A(metaclass=f()): ...’

   * Mypy does not and cannot understand arbitrary metaclass code.

   * Mypy only recognizes subclasses of type(1) as potential
     metaclasses.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#type


File: Mypy.info,  Node: Running mypy and managing imports,  Next: The mypy command line,  Prev: Metaclasses,  Up: Contents

1.19 Running mypy and managing imports
======================================

The *note Getting started: 4. page should have already introduced you to
the basics of how to run mypy – pass in the files and directories you
want to type check via the command line:

     $ mypy foo.py bar.py some_directory

This page discusses in more detail how exactly to specify what files you
want mypy to type check, how mypy discovers imported modules, and
recommendations on how to handle any issues you may encounter along the
way.

If you are interested in learning about how to configure the actual way
mypy type checks your code, see our *note The mypy command line: a.
guide.

* Menu:

* Specifying code to be checked::
* Reading a list of files from a file::
* Mapping file paths to modules::
* How mypy handles imports::
* Missing imports::
* How imports are found::
* Following imports::


File: Mypy.info,  Node: Specifying code to be checked,  Next: Reading a list of files from a file,  Up: Running mypy and managing imports

1.19.1 Specifying code to be checked
------------------------------------

Mypy lets you specify what files it should type check in several
different ways.

  1. First, you can pass in paths to Python files and directories you
     want to type check.  For example:

          $ mypy file_1.py foo/file_2.py file_3.pyi some/directory

     The above command tells mypy it should type check all of the
     provided files together.  In addition, mypy will recursively type
     check the entire contents of any provided directories.

     For more details about how exactly this is done, see *note Mapping
     file paths to modules: 121.

  2. Second, you can use the *note -m: 122. flag (long form: *note
     –module: 122.) to specify a module name to be type checked.  The
     name of a module is identical to the name you would use to import
     that module within a Python program.  For example, running:

          $ mypy -m html.parser

     …will type check the module ‘html.parser’ (this happens to be a
     library stub).

     Mypy will use an algorithm very similar to the one Python uses to
     find where modules and imports are located on the file system.  For
     more details, see *note How imports are found: 123.

  3. Third, you can use the *note -p: 124. (long form: *note –package:
     124.) flag to specify a package to be (recursively) type checked.
     This flag is almost identical to the *note -m: 122. flag except
     that if you give it a package name, mypy will recursively type
     check all submodules and subpackages of that package.  For example,
     running:

          $ mypy -p html

     …will type check the entire ‘html’ package (of library stubs).  In
     contrast, if we had used the *note -m: 122. flag, mypy would have
     type checked just ‘html’’s ‘__init__.py’ file and anything imported
     from there.

     Note that we can specify multiple packages and modules on the
     command line.  For example:

          $ mypy --package p.a --package p.b --module c

  4. Fourth, you can also instruct mypy to directly type check small
     strings as programs by using the *note -c: 125. (long form: *note
     –command: 125.) flag.  For example:

          $ mypy -c 'x = [1, 2]; print(x())'

     …will type check the above string as a mini-program (and in this
     case, will report that ‘list[int]’ is not callable).

You can also use the *note files: 126. option in your ‘mypy.ini’ file to
specify which files to check, in which case you can simply run ‘mypy’
with no arguments.


File: Mypy.info,  Node: Reading a list of files from a file,  Next: Mapping file paths to modules,  Prev: Specifying code to be checked,  Up: Running mypy and managing imports

1.19.2 Reading a list of files from a file
------------------------------------------

Finally, any command-line argument starting with ‘@’ reads additional
command-line arguments from the file following the ‘@’ character.  This
is primarily useful if you have a file containing a list of files that
you want to be type-checked: instead of using shell syntax like:

     $ mypy $(cat file_of_files.txt)

you can use this instead:

     $ mypy @file_of_files.txt

This file can technically also contain any command line flag, not just
file paths.  However, if you want to configure many different flags, the
recommended approach is to use a *note configuration file: 20. instead.


File: Mypy.info,  Node: Mapping file paths to modules,  Next: How mypy handles imports,  Prev: Reading a list of files from a file,  Up: Running mypy and managing imports

1.19.3 Mapping file paths to modules
------------------------------------

One of the main ways you can tell mypy what to type check is by
providing mypy a list of paths.  For example:

     $ mypy file_1.py foo/file_2.py file_3.pyi some/directory

This section describes how exactly mypy maps the provided paths to
modules to type check.

   - Mypy will check all paths provided that correspond to files.

   - Mypy will recursively discover and check all files ending in ‘.py’
     or ‘.pyi’ in directory paths provided, after accounting for *note
     –exclude: 129.

   - For each file to be checked, mypy will attempt to associate the
     file (e.g.  ‘project/foo/bar/baz.py’) with a fully qualified module
     name (e.g.  ‘foo.bar.baz’).  The directory the package is in
     (‘project’) is then added to mypy’s module search paths.

How mypy determines fully qualified module names depends on if the
options *note –no-namespace-packages: 12a. and *note
–explicit-package-bases: 12b. are set.

  1. If *note –no-namespace-packages: 12a. is set, mypy will rely solely
     upon the presence of ‘__init__.py[i]’ files to determine the fully
     qualified module name.  That is, mypy will crawl up the directory
     tree for as long as it continues to find ‘__init__.py’ (or
     ‘__init__.pyi’) files.

     For example, if your directory tree consists of
     ‘pkg/subpkg/mod.py’, mypy would require ‘pkg/__init__.py’ and
     ‘pkg/subpkg/__init__.py’ to exist in order correctly associate
     ‘mod.py’ with ‘pkg.subpkg.mod’

  2. The default case.  If *note –namespace-packages: 12a. is on, but
     *note –explicit-package-bases: 12b. is off, mypy will allow for the
     possibility that directories without ‘__init__.py[i]’ are packages.
     Specifically, mypy will look at all parent directories of the file
     and use the location of the highest ‘__init__.py[i]’ in the
     directory tree to determine the top-level package.

     For example, say your directory tree consists solely of
     ‘pkg/__init__.py’ and ‘pkg/a/b/c/d/mod.py’.  When determining
     ‘mod.py’’s fully qualified module name, mypy will look at
     ‘pkg/__init__.py’ and conclude that the associated module name is
     ‘pkg.a.b.c.d.mod’.

  3. You’ll notice that the above case still relies on ‘__init__.py’.
     If you can’t put an ‘__init__.py’ in your top-level package, but
     still wish to pass paths (as opposed to packages or modules using
     the ‘-p’ or ‘-m’ flags), *note –explicit-package-bases: 12b.
     provides a solution.

     With *note –explicit-package-bases: 12b, mypy will locate the
     nearest parent directory that is a member of the ‘MYPYPATH’
     environment variable, the *note mypy_path: 12c. config or is the
     current working directory.  Mypy will then use the relative path to
     determine the fully qualified module name.

     For example, say your directory tree consists solely of
     ‘src/namespace_pkg/mod.py’.  If you run the following command, mypy
     will correctly associate ‘mod.py’ with ‘namespace_pkg.mod’:

          $ MYPYPATH=src mypy --namespace-packages --explicit-package-bases .

If you pass a file not ending in ‘.py[i]’, the module name assumed is
‘__main__’ (matching the behavior of the Python interpreter), unless
*note –scripts-are-modules: 12d. is passed.

Passing *note -v: 12e. will show you the files and associated module
names that mypy will check.


File: Mypy.info,  Node: How mypy handles imports,  Next: Missing imports,  Prev: Mapping file paths to modules,  Up: Running mypy and managing imports

1.19.4 How mypy handles imports
-------------------------------

When mypy encounters an ‘import’ statement, it will first *note attempt
to locate: 123. that module or type stubs for that module in the file
system.  Mypy will then type check the imported module.  There are three
different outcomes of this process:

  1. Mypy is unable to follow the import: the module either does not
     exist, or is a third party library that does not use type hints.

  2. Mypy is able to follow and type check the import, but you did not
     want mypy to type check that module at all.

  3. Mypy is able to successfully both follow and type check the module,
     and you want mypy to type check that module.

The third outcome is what mypy will do in the ideal case.  The following
sections will discuss what to do in the other two cases.


File: Mypy.info,  Node: Missing imports,  Next: How imports are found,  Prev: How mypy handles imports,  Up: Running mypy and managing imports

1.19.5 Missing imports
----------------------

When you import a module, mypy may report that it is unable to follow
the import.  This can cause errors that look like the following:

     main.py:1: error: Skipping analyzing 'django': module is installed, but missing library stubs or py.typed marker
     main.py:2: error: Library stubs not installed for "requests"
     main.py:3: error: Cannot find implementation or library stub for module named "this_module_does_not_exist"

If you get any of these errors on an import, mypy will assume the type
of that module is ‘Any’, the dynamic type.  This means attempting to
access any attribute of the module will automatically succeed:

     # Error: Cannot find implementation or library stub for module named 'does_not_exist'
     import does_not_exist

     # But this type checks, and x will have type 'Any'
     x = does_not_exist.foobar()

The next sections describe what each of these errors means and
recommended next steps; scroll to the section that matches your error.

* Menu:

* Missing library stubs or py.typed marker: Missing library stubs or py typed marker.
* Library stubs not installed::
* Cannot find implementation or library stub::


File: Mypy.info,  Node: Missing library stubs or py typed marker,  Next: Library stubs not installed,  Up: Missing imports

1.19.5.1 Missing library stubs or py.typed marker
.................................................

If you are getting a ‘Skipping analyzing X: module is installed, but
missing library stubs or py.typed marker’, error, this means mypy was
able to find the module you were importing, but no corresponding type
hints.

Mypy will not try inferring the types of any 3rd party libraries you
have installed unless they either have declared themselves to be *note
PEP 561 compliant stub package: 14. (e.g.  with a ‘py.typed’ file) or
have registered themselves on typeshed(1), the repository of types for
the standard library and some 3rd party libraries.

If you are getting this error, try:

  1. Upgrading the version of the library you’re using, in case a newer
     version has started to include type hints.

  2. Searching to see if there is a *note PEP 561 compliant stub
     package: 14.  corresponding to your third party library.  Stub
     packages let you install type hints independently from the library
     itself.

     For example, if you want type hints for the ‘django’ library, you
     can install the django-stubs(2) package.

  3. *note Writing your own stub files: 15. containing type hints for
     the library.  You can point mypy at your type hints either by
     passing them in via the command line, by using the *note files:
     126. or *note mypy_path: 12c. config file options, or by adding the
     location to the ‘MYPYPATH’ environment variable.

     These stub files do not need to be complete!  A good strategy is to
     use stubgen, a program that comes bundled with mypy, to generate a
     first rough draft of the stubs.  You can then iterate on just the
     parts of the library you need.

     If you want to share your work, you can try contributing your stubs
     back to the library – see our documentation on creating *note PEP
     561 compliant packages: 14.

If you are unable to find any existing type hints nor have time to write
your own, you can instead ‘suppress’ the errors.  All this will do is
make mypy stop reporting an error on the line containing the import: the
imported module will continue to be of type ‘Any’.

  1. To suppress a ‘single’ missing import error, add a ‘# type: ignore’
     at the end of the line containing the import.

  2. To suppress ‘all’ missing import errors from a single library, add
     a section to your *note mypy config file: 20. for that library
     setting *note ignore_missing_imports: 25. to True.  For example,
     suppose your codebase makes heavy use of an (untyped) library named
     ‘foobar’.  You can silence all import errors associated with that
     library and that library alone by adding the following section to
     your config file:

          [mypy-foobar.*]
          ignore_missing_imports = True

     Note: this option is equivalent to adding a ‘# type: ignore’ to
     every import of ‘foobar’ in your codebase.  For more information,
     see the documentation about configuring *note import discovery:
     132. in config files.  The ‘.*’ after ‘foobar’ will ignore imports
     of ‘foobar’ modules and subpackages in addition to the ‘foobar’
     top-level package namespace.

  3. To suppress ‘all’ missing import errors for ‘all’ libraries in your
     codebase, invoke mypy with the *note –ignore-missing-imports: 133.
     command line flag or set the *note ignore_missing_imports: 25.
     config file option to True in the ‘global’ section of your mypy
     config file:

          [mypy]
          ignore_missing_imports = True

     We recommend using this approach only as a last resort: it’s
     equivalent to adding a ‘# type: ignore’ to all unresolved imports
     in your codebase.

   ---------- Footnotes ----------

   (1) https://github.com/python/typeshed

   (2) https://pypi.org/project/django-stubs/


File: Mypy.info,  Node: Library stubs not installed,  Next: Cannot find implementation or library stub,  Prev: Missing library stubs or py typed marker,  Up: Missing imports

1.19.5.2 Library stubs not installed
....................................

If mypy can’t find stubs for a third-party library, and it knows that
stubs exist for the library, you will get a message like this:

     main.py:1: error: Library stubs not installed for "yaml"
     main.py:1: note: Hint: "python3 -m pip install types-PyYAML"
     main.py:1: note: (or run "mypy --install-types" to install all missing stub packages)

You can resolve the issue by running the suggested pip command or
commands.  Alternatively, you can use *note –install-types: 135. to
install all known missing stubs:

     mypy --install-types

This installs any stub packages that were suggested in the previous mypy
run.  You can also use your normal mypy command line with the extra
*note –install-types: 135. option to install missing stubs at the end of
the run (if any were found).

Use *note –install-types: 135. with *note –non-interactive: 136. to
install all suggested stub packages without asking for confirmation,
‘and’ type check your code, in a single command:

     mypy --install-types --non-interactive src/

This can be useful in Continuous Integration jobs if you’d prefer not to
manage stub packages manually.  This is somewhat slower than explicitly
installing stubs before running mypy, since it may type check your code
twice – the first time to find the missing stubs, and the second time to
type check your code properly after mypy has installed the stubs.

If you’ve already installed the relevant third-party libraries in an
environment other than the one mypy is running in, you can use *note
–python-executable: 137. flag to point to the Python executable for that
environment, and mypy will find packages installed for that Python
executable.


File: Mypy.info,  Node: Cannot find implementation or library stub,  Prev: Library stubs not installed,  Up: Missing imports

1.19.5.3 Cannot find implementation or library stub
...................................................

If you are getting a ‘Cannot find implementation or library stub for
module’ error, this means mypy was not able to find the module you are
trying to import, whether it comes bundled with type hints or not.  If
you are getting this error, try:

  1. Making sure your import does not contain a typo.

  2. If the module is a third party library, making sure that mypy is
     able to find the interpreter containing the installed library.

     For example, if you are running your code in a virtualenv, make
     sure to install and use mypy within the virtualenv.  Alternatively,
     if you want to use a globally installed mypy, set the *note
     –python-executable: 137. command line flag to point the Python
     interpreter containing your installed third party packages.

  2. Reading the *note How imports are found: 123. section below to make
     sure you understand how exactly mypy searches for and finds modules
     and modify how you’re invoking mypy accordingly.

  3. Directly specifying the directory containing the module you want to
     type check from the command line, by using the *note mypy_path:
     12c. or *note files: 126. config file options, or by using the
     ‘MYPYPATH’ environment variable.

     Note: if the module you are trying to import is actually a
     ‘submodule’ of some package, you should specify the directory
     containing the ‘entire’ package.  For example, suppose you are
     trying to add the module ‘foo.bar.baz’ which is located at
     ‘~/foo-project/src/foo/bar/baz.py’.  In this case, you must run
     ‘mypy ~/foo-project/src’ (or set the ‘MYPYPATH’ to
     ‘~/foo-project/src’.

In some rare cases, you may get the “Cannot find implementation or
library stub for module” error even when the module is installed in your
system.  This can happen when the module is both missing type hints and
is installed on your system in an unconventional way.

In this case, follow the steps above on how to handle *note missing type
hints in third party libraries: 139.


File: Mypy.info,  Node: How imports are found,  Next: Following imports,  Prev: Missing imports,  Up: Running mypy and managing imports

1.19.6 How imports are found
----------------------------

When mypy encounters an ‘import’ statement or receives module names from
the command line via the *note –module: 122. or *note –package: 124.
flags, mypy tries to find the module on the file system similar to the
way Python finds it.  However, there are some differences.

First, mypy has its own search path.  This is computed from the
following items:

   - The ‘MYPYPATH’ environment variable (a list of directories,
     colon-separated on UNIX systems, semicolon-separated on Windows).

   - The *note mypy_path: 12c. config file option.

   - The directories containing the sources given on the command line
     (see *note Mapping file paths to modules: 121.).

   - The installed packages marked as safe for type checking (see *note
     PEP 561 support: 14.)

   - The relevant directories of the typeshed(1) repo.

     Note: You cannot point to a stub-only package ( PEP 561(2)) via the
     ‘MYPYPATH’, it must be installed (see *note PEP 561 support: 14.)

Second, mypy searches for stub files in addition to regular Python files
and packages.  The rules for searching for a module ‘foo’ are as
follows:

   - The search looks in each of the directories in the search path (see
     above) until a match is found.

   - If a package named ‘foo’ is found (i.e.  a directory ‘foo’
     containing an ‘__init__.py’ or ‘__init__.pyi’ file) that’s a match.

   - If a stub file named ‘foo.pyi’ is found, that’s a match.

   - If a Python module named ‘foo.py’ is found, that’s a match.

These matches are tried in order, so that if multiple matches are found
in the same directory on the search path (e.g.  a package and a Python
file, or a stub file and a Python file) the first one in the above list
wins.

In particular, if a Python file and a stub file are both present in the
same directory on the search path, only the stub file is used.
(However, if the files are in different directories, the one found in
the earlier directory is used.)

Setting *note mypy_path: 12c./‘MYPYPATH’ is mostly useful in the case
where you want to try running mypy against multiple distinct sets of
files that happen to share some common dependencies.

For example, if you have multiple projects that happen to be using the
same set of work-in-progress stubs, it could be convenient to just have
your ‘MYPYPATH’ point to a single directory containing the stubs.

   ---------- Footnotes ----------

   (1) https://github.com/python/typeshed

   (2) https://peps.python.org/pep-0561/


File: Mypy.info,  Node: Following imports,  Prev: How imports are found,  Up: Running mypy and managing imports

1.19.7 Following imports
------------------------

Mypy is designed to *note doggedly follow all imports: 123, even if the
imported module is not a file you explicitly wanted mypy to check.

For example, suppose we have two modules ‘mycode.foo’ and ‘mycode.bar’:
the former has type hints and the latter does not.  We run *note mypy -m
mycode.foo: 122. and mypy discovers that ‘mycode.foo’ imports
‘mycode.bar’.

How do we want mypy to type check ‘mycode.bar’?  Mypy’s behaviour here
is configurable – although we ‘strongly recommend’ using the default –
by using the *note –follow-imports: 13c. flag.  This flag accepts one of
four string values:

   - ‘normal’ (the default, recommended) follows all imports normally
     and type checks all top level code (as well as the bodies of all
     functions and methods with at least one type annotation in the
     signature).

   - ‘silent’ behaves in the same way as ‘normal’ but will additionally
     ‘suppress’ any error messages.

   - ‘skip’ will ‘not’ follow imports and instead will silently replace
     the module (and ‘anything imported from it’) with an object of type
     ‘Any’.

   - ‘error’ behaves in the same way as ‘skip’ but is not quite as
     silent – it will flag the import as an error, like this:

          main.py:1: note: Import of "mycode.bar" ignored
          main.py:1: note: (Using --follow-imports=error, module not passed on command line)

If you are starting a new codebase and plan on using type hints from the
start, we recommend you use either *note –follow-imports=normal: 13c.
(the default) or *note –follow-imports=error: 13c.  Either option will
help make sure you are not skipping checking any part of your codebase
by accident.

If you are planning on adding type hints to a large, existing code base,
we recommend you start by trying to make your entire codebase (including
files that do not use type hints) pass under *note
–follow-imports=normal: 13c.  This is usually not too difficult to do:
mypy is designed to report as few error messages as possible when it is
looking at unannotated code.

Only if doing this is intractable, we recommend passing mypy just the
files you want to type check and use *note –follow-imports=silent: 13c.
Even if mypy is unable to perfectly type check a file, it can still
glean some useful information by parsing it (for example, understanding
what methods a given object has).  See *note Using mypy with an existing
codebase: 19. for more recommendations.

We do not recommend using ‘skip’ unless you know what you are doing:
while this option can be quite powerful, it can also cause many
hard-to-debug errors.

Adjusting import following behaviour is often most useful when
restricted to specific modules.  This can be accomplished by setting a
per-module *note follow_imports: 13d. config option.


File: Mypy.info,  Node: The mypy command line,  Next: The mypy configuration file,  Prev: Running mypy and managing imports,  Up: Contents

1.20 The mypy command line
==========================

This section documents mypy’s command line interface.  You can view a
quick summary of the available flags by running *note mypy –help: 140.

     Note: Command line flags are liable to change between releases.

* Menu:

* Specifying what to type check::
* Optional arguments::
* Config file::
* Import discovery::
* Platform configuration::
* Disallow dynamic typing::
* Untyped definitions and calls::
* None and Optional handling::
* Configuring warnings::
* Miscellaneous strictness flags::
* Configuring error messages::
* Incremental mode::
* Advanced options::
* Report generation::
* Miscellaneous: Miscellaneous<2>.


File: Mypy.info,  Node: Specifying what to type check,  Next: Optional arguments,  Up: The mypy command line

1.20.1 Specifying what to type check
------------------------------------

By default, you can specify what code you want mypy to type check by
passing in the paths to what you want to have type checked:

     $ mypy foo.py bar.py some_directory

Note that directories are checked recursively.

Mypy also lets you specify what code to type check in several other
ways.  A short summary of the relevant flags is included below: for full
details, see *note Running mypy and managing imports: 11e.

 -- Option: -m MODULE, --module MODULE

     Asks mypy to type check the provided module.  This flag may be
     repeated multiple times.

     Mypy ‘will not’ recursively type check any submodules of the
     provided module.

 -- Option: -p PACKAGE, --package PACKAGE

     Asks mypy to type check the provided package.  This flag may be
     repeated multiple times.

     Mypy ‘will’ recursively type check any submodules of the provided
     package.  This flag is identical to *note –module: 122. apart from
     this behavior.

 -- Option: -c PROGRAM_TEXT, --command PROGRAM_TEXT

     Asks mypy to type check the provided string as a program.

 -- Option: --exclude

     A regular expression that matches file names, directory names and
     paths which mypy should ignore while recursively discovering files
     to check.  Use forward slashes on all platforms.

     For instance, to avoid discovering any files named ‘setup.py’ you
     could pass ‘--exclude '/setup\.py$'’.  Similarly, you can ignore
     discovering directories with a given name by e.g.  ‘--exclude
     /build/’ or those matching a subpath with ‘--exclude
     /project/vendor/’.  To ignore multiple files / directories / paths,
     you can provide the –exclude flag more than once, e.g ‘--exclude
     '/setup\.py$' --exclude '/build/'’.

     Note that this flag only affects recursive directory tree
     discovery, that is, when mypy is discovering files within a
     directory tree or submodules of a package to check.  If you pass a
     file or module explicitly it will still be checked.  For instance,
     ‘mypy --exclude '/setup.py$' but_still_check/setup.py’.

     In particular, ‘--exclude’ does not affect mypy’s *note import
     following: 26.  You can use a per-module *note follow_imports: 13d.
     config option to additionally avoid mypy from following imports and
     checking code you do not wish to be checked.

     Note that mypy will never recursively discover files and
     directories named “site-packages”, “node_modules” or “__pycache__”,
     or those whose name starts with a period, exactly as ‘--exclude
     '/(site-packages|node_modules|__pycache__|\..*)/$'’ would.  Mypy
     will also never recursively discover files with extensions other
     than ‘.py’ or ‘.pyi’.


File: Mypy.info,  Node: Optional arguments,  Next: Config file,  Prev: Specifying what to type check,  Up: The mypy command line

1.20.2 Optional arguments
-------------------------

 -- Option: -h, --help

     Show help message and exit.

 -- Option: -v, --verbose

     More verbose messages.

 -- Option: -V, --version

     Show program’s version number and exit.


File: Mypy.info,  Node: Config file,  Next: Import discovery,  Prev: Optional arguments,  Up: The mypy command line

1.20.3 Config file
------------------

 -- Option: --config-file CONFIG_FILE

     This flag makes mypy read configuration settings from the given
     file.

     By default settings are read from ‘mypy.ini’, ‘.mypy.ini’,
     ‘pyproject.toml’, or ‘setup.cfg’ in the current directory.
     Settings override mypy’s built-in defaults and command line flags
     can override settings.

     Specifying *note –config-file=: 14c. (with no filename) will ignore
     ‘all’ config files.

     See *note The mypy configuration file: 20. for the syntax of
     configuration files.

 -- Option: --warn-unused-configs

     This flag makes mypy warn about unused ‘[mypy-<pattern>]’ config
     file sections.  (This requires turning off incremental mode using
     *note –no-incremental: 14e.)


File: Mypy.info,  Node: Import discovery,  Next: Platform configuration,  Prev: Config file,  Up: The mypy command line

1.20.4 Import discovery
-----------------------

The following flags customize how exactly mypy discovers and follows
imports.

 -- Option: --explicit-package-bases

     This flag tells mypy that top-level packages will be based in
     either the current directory, or a member of the ‘MYPYPATH’
     environment variable or *note mypy_path: 12c. config option.  This
     option is only useful in in the absence of ‘__init__.py’.  See
     *note Mapping file paths to modules: 121. for details.

 -- Option: --ignore-missing-imports

     This flag makes mypy ignore all missing imports.  It is equivalent
     to adding ‘# type: ignore’ comments to all unresolved imports
     within your codebase.

     Note that this flag does ‘not’ suppress errors about missing names
     in successfully resolved modules.  For example, if one has the
     following files:

          package/__init__.py
          package/mod.py

     Then mypy will generate the following errors with *note
     –ignore-missing-imports: 133.:

          import package.unknown      # No error, ignored
          x = package.unknown.func()  # OK. 'func' is assumed to be of type 'Any'

          from package import unknown          # No error, ignored
          from package.mod import NonExisting  # Error: Module has no attribute 'NonExisting'

     For more details, see *note Missing imports: 16.

 -- Option: --follow-imports {normal,silent,skip,error}

     This flag adjusts how mypy follows imported modules that were not
     explicitly passed in via the command line.

     The default option is ‘normal’: mypy will follow and type check all
     modules.  For more information on what the other options do, see
     *note Following imports: 26.

 -- Option: --python-executable EXECUTABLE

     This flag will have mypy collect type information from PEP 561(1)
     compliant packages installed for the Python executable
     ‘EXECUTABLE’.  If not provided, mypy will use PEP 561 compliant
     packages installed for the Python executable running mypy.

     See *note Using installed packages: 14. for more on making PEP 561
     compliant packages.

 -- Option: --no-site-packages

     This flag will disable searching for PEP 561(2) compliant packages.
     This will also disable searching for a usable Python executable.

     Use this flag if mypy cannot find a Python executable for the
     version of Python being checked, and you don’t need to use PEP 561
     typed packages.  Otherwise, use *note –python-executable: 137.

 -- Option: --no-silence-site-packages

     By default, mypy will suppress any error messages generated within
     PEP 561(3) compliant packages.  Adding this flag will disable this
     behavior.

 -- Option: --fast-module-lookup

     The default logic used to scan through search paths to resolve
     imports has a quadratic worse-case behavior in some cases, which is
     for instance triggered by a large number of folders sharing a
     top-level namespace as in:

          foo/
              company/
                  foo/
                      a.py
          bar/
              company/
                  bar/
                      b.py
          baz/
              company/
                  baz/
                      c.py
          ...

     If you are in this situation, you can enable an experimental fast
     path by setting the *note –fast-module-lookup: 153. option.

 -- Option: --no-namespace-packages

     This flag disables import discovery of namespace packages (see PEP
     420(4)).  In particular, this prevents discovery of packages that
     don’t have an ‘__init__.py’ (or ‘__init__.pyi’) file.

     This flag affects how mypy finds modules and packages explicitly
     passed on the command line.  It also affects how mypy determines
     fully qualified module names for files passed on the command line.
     See *note Mapping file paths to modules: 121. for details.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0561/

   (2) https://peps.python.org/pep-0561/

   (3) https://peps.python.org/pep-0561/

   (4) https://peps.python.org/pep-0420/


File: Mypy.info,  Node: Platform configuration,  Next: Disallow dynamic typing,  Prev: Import discovery,  Up: The mypy command line

1.20.5 Platform configuration
-----------------------------

By default, mypy will assume that you intend to run your code using the
same operating system and Python version you are using to run mypy
itself.  The following flags let you modify this behavior.

For more information on how to use these flags, see *note Python version
and system platform checks: ed.

 -- Option: --python-version X.Y

     This flag will make mypy type check your code as if it were run
     under Python version X.Y. Without this option, mypy will default to
     using whatever version of Python is running mypy.

     This flag will attempt to find a Python executable of the
     corresponding version to search for PEP 561(1) compliant packages.
     If you’d like to disable this, use the *note –no-site-packages:
     151. flag (see *note Import discovery: 150. for more details).

 -- Option: --platform PLATFORM

     This flag will make mypy type check your code as if it were run
     under the given operating system.  Without this option, mypy will
     default to using whatever operating system you are currently using.

     The ‘PLATFORM’ parameter may be any string supported by
     sys.platform(2).
 -- Option: --always-true NAME

     This flag will treat all variables named ‘NAME’ as compile-time
     constants that are always true.  This flag may be repeated.

 -- Option: --always-false NAME

     This flag will treat all variables named ‘NAME’ as compile-time
     constants that are always false.  This flag may be repeated.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0561/

   (2) https://docs.python.org/3/library/sys.html#sys.platform


File: Mypy.info,  Node: Disallow dynamic typing,  Next: Untyped definitions and calls,  Prev: Platform configuration,  Up: The mypy command line

1.20.6 Disallow dynamic typing
------------------------------

The ‘Any’ type is used to represent a value that has a *note dynamic
type: 45.  The ‘--disallow-any’ family of flags will disallow various
uses of the ‘Any’ type in a module – this lets us strategically disallow
the use of dynamic typing in a controlled way.

The following options are available:

 -- Option: --disallow-any-unimported

     This flag disallows usage of types that come from unfollowed
     imports (such types become aliases for ‘Any’).  Unfollowed imports
     occur either when the imported module does not exist or when *note
     –follow-imports=skip: 13c. is set.

 -- Option: --disallow-any-expr

     This flag disallows all expressions in the module that have type
     ‘Any’.  If an expression of type ‘Any’ appears anywhere in the
     module mypy will output an error unless the expression is
     immediately used as an argument to cast()(1) or assigned to a
     variable with an explicit type annotation.

     In addition, declaring a variable of type ‘Any’ or casting to type
     ‘Any’ is not allowed.  Note that calling functions that take
     parameters of type ‘Any’ is still allowed.

 -- Option: --disallow-any-decorated

     This flag disallows functions that have ‘Any’ in their signature
     after decorator transformation.

 -- Option: --disallow-any-explicit

     This flag disallows explicit ‘Any’ in type positions such as type
     annotations and generic type parameters.

 -- Option: --disallow-any-generics

     This flag disallows usage of generic types that do not specify
     explicit type parameters.  For example, you can’t use a bare ‘x:
     list’.  Instead, you must always write something like ‘x:
     list[int]’.

 -- Option: --disallow-subclassing-any

     This flag reports an error whenever a class subclasses a value of
     type ‘Any’.  This may occur when the base class is imported from a
     module that doesn’t exist (when using *note
     –ignore-missing-imports: 133.) or is ignored due to *note
     –follow-imports=skip: 13c. or a ‘# type: ignore’ comment on the
     ‘import’ statement.

     Since the module is silenced, the imported class is given a type of
     ‘Any’.  By default mypy will assume that the subclass correctly
     inherited the base class even though that may not actually be the
     case.  This flag makes mypy raise an error instead.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.cast


File: Mypy.info,  Node: Untyped definitions and calls,  Next: None and Optional handling,  Prev: Disallow dynamic typing,  Up: The mypy command line

1.20.7 Untyped definitions and calls
------------------------------------

The following flags configure how mypy handles untyped function
definitions or calls.

 -- Option: --disallow-untyped-calls

     This flag reports an error whenever a function with type
     annotations calls a function defined without annotations.

 -- Option: --disallow-untyped-defs

     This flag reports an error whenever it encounters a function
     definition without type annotations.

 -- Option: --disallow-incomplete-defs

     This flag reports an error whenever it encounters a partly
     annotated function definition.

 -- Option: --check-untyped-defs

     This flag is less severe than the previous two options – it type
     checks the body of every function, regardless of whether it has
     type annotations.  (By default the bodies of functions without
     annotations are not type checked.)

     It will assume all arguments have type ‘Any’ and always infer ‘Any’
     as the return type.

 -- Option: --disallow-untyped-decorators

     This flag reports an error whenever a function with type
     annotations is decorated with a decorator without annotations.


File: Mypy.info,  Node: None and Optional handling,  Next: Configuring warnings,  Prev: Untyped definitions and calls,  Up: The mypy command line

1.20.8 None and Optional handling
---------------------------------

The following flags adjust how mypy handles values of type ‘None’.  For
more details, see *note Disabling strict optional checking: 66.
 -- Option: --implicit-optional

     This flag causes mypy to treat arguments with a ‘None’ default
     value as having an implicit Optional(1) type.

     For example, if this flag is set, mypy would assume that the ‘x’
     parameter is actually of type ‘Optional[int]’ in the code snippet
     below since the default parameter is ‘None’:

          def foo(x: int = None) -> None:
              print(x)

     ‘Note:’ This was disabled by default starting in mypy 0.980.

 -- Option: --no-strict-optional

     This flag disables strict checking of Optional(2) types and ‘None’
     values.  With this option, mypy doesn’t generally check the use of
     ‘None’ values – they are valid everywhere.  See *note Disabling
     strict optional checking: 66. for more about this feature.

     ‘Note:’ Strict optional checking was enabled by default starting in
     mypy 0.600, and in previous versions it had to be explicitly
     enabled using ‘--strict-optional’ (which is still accepted).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Optional

   (2) https://docs.python.org/3/library/typing.html#typing.Optional


File: Mypy.info,  Node: Configuring warnings,  Next: Miscellaneous strictness flags,  Prev: None and Optional handling,  Up: The mypy command line

1.20.9 Configuring warnings
---------------------------

The following flags enable warnings for code that is sound but is
potentially problematic or redundant in some way.

 -- Option: --warn-redundant-casts

     This flag will make mypy report an error whenever your code uses an
     unnecessary cast that can safely be removed.

 -- Option: --warn-unused-ignores

     This flag will make mypy report an error whenever your code uses a
     ‘# type: ignore’ comment on a line that is not actually generating
     an error message.

     This flag, along with the *note –warn-redundant-casts: 16a. flag,
     are both particularly useful when you are upgrading mypy.
     Previously, you may have needed to add casts or ‘# type: ignore’
     annotations to work around bugs in mypy or missing stubs for 3rd
     party libraries.

     These two flags let you discover cases where either workarounds are
     no longer necessary.

 -- Option: --no-warn-no-return

     By default, mypy will generate errors when a function is missing
     return statements in some execution paths.  The only exceptions are
     when:

        - The function has a ‘None’ or ‘Any’ return type

        - The function has an empty body or a body that is just ellipsis
          (‘...’).  Empty functions are often used for abstract methods.

     Passing in *note –no-warn-no-return: 16c. will disable these error
     messages in all cases.

 -- Option: --warn-return-any

     This flag causes mypy to generate a warning when returning a value
     with type ‘Any’ from a function declared with a non-‘Any’ return
     type.

 -- Option: --warn-unreachable

     This flag will make mypy report an error whenever it encounters
     code determined to be unreachable or redundant after performing
     type analysis.  This can be a helpful way of detecting certain
     kinds of bugs in your code.

     For example, enabling this flag will make mypy report that the ‘x >
     7’ check is redundant and that the ‘else’ block below is
     unreachable.

          def process(x: int) -> None:
              # Error: Right operand of "or" is never evaluated
              if isinstance(x, int) or x > 7:
                  # Error: Unsupported operand types for + ("int" and "str")
                  print(x + "bad")
              else:
                  # Error: 'Statement is unreachable' error
                  print(x + "bad")

     To help prevent mypy from generating spurious warnings, the
     “Statement is unreachable” warning will be silenced in exactly two
     cases:

       1. When the unreachable statement is a ‘raise’ statement, is an
          ‘assert False’ statement, or calls a function that has the
          NoReturn(1) return type hint.  In other words, when the
          unreachable statement throws an error or terminates the
          program in some way.

       2. When the unreachable statement was ‘intentionally’ marked as
          unreachable using *note Python version and system platform
          checks: ed.

          Note: Mypy currently cannot detect and report unreachable or
          redundant code inside any functions using *note Type variables
          with value restriction: d7.

          This limitation will be removed in future releases of mypy.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.NoReturn


File: Mypy.info,  Node: Miscellaneous strictness flags,  Next: Configuring error messages,  Prev: Configuring warnings,  Up: The mypy command line

1.20.10 Miscellaneous strictness flags
--------------------------------------

This section documents any other flags that do not neatly fall under any
of the above sections.

 -- Option: --allow-untyped-globals

     This flag causes mypy to suppress errors caused by not being able
     to fully infer the types of global and class variables.

 -- Option: --allow-redefinition

     By default, mypy won’t allow a variable to be redefined with an
     unrelated type.  This flag enables redefinition of a variable with
     an arbitrary type ‘in some contexts’: only redefinitions within the
     same block and nesting depth as the original definition are
     allowed.  Example where this can be useful:

          def process(items: list[str]) -> None:
              # 'items' has type list[str]
              items = [item.split() for item in items]
              # 'items' now has type list[list[str]]

     The variable must be used before it can be redefined:

          def process(items: list[str]) -> None:
             items = "mypy"  # invalid redefinition to str because the variable hasn't been used yet
             print(items)
             items = "100"  # valid, items now has type str
             items = int(items)  # valid, items now has type int

 -- Option: --local-partial-types

     In mypy, the most common cases for partial types are variables
     initialized using ‘None’, but without explicit ‘Optional’
     annotations.  By default, mypy won’t check partial types spanning
     module top level or class top level.  This flag changes the
     behavior to only allow partial types at local level, therefore it
     disallows inferring variable type for ‘None’ from two assignments
     in different scopes.  For example:

          from typing import Optional

          a = None  # Need type annotation here if using --local-partial-types
          b: Optional[int] = None

          class Foo:
              bar = None  # Need type annotation here if using --local-partial-types
              baz: Optional[int] = None

              def __init__(self) -> None:
                  self.bar = 1

          reveal_type(Foo().bar)  # Union[int, None] without --local-partial-types

     Note: this option is always implicitly enabled in mypy daemon and
     will become enabled by default for mypy in a future release.

 -- Option: --no-implicit-reexport

     By default, imported values to a module are treated as exported and
     mypy allows other modules to import them.  This flag changes the
     behavior to not re-export unless the item is imported using from-as
     or is included in ‘__all__’.  Note this is always treated as
     enabled for stub files.  For example:

          # This won't re-export the value
          from foo import bar

          # Neither will this
          from foo import bar as bang

          # This will re-export it as bar and allow other modules to import it
          from foo import bar as bar

          # This will also re-export bar
          from foo import bar
          __all__ = ['bar']

 -- Option: --strict-equality

     By default, mypy allows always-false comparisons like ‘42 == 'no'’.
     Use this flag to prohibit such comparisons of non-overlapping
     types, and similar identity and container checks:

          from typing import Text

          items: list[int]
          if 'some string' in items:  # Error: non-overlapping container check!
              ...

          text: Text
          if text != b'other bytes':  # Error: non-overlapping equality check!
              ...

          assert text is not None  # OK, check against None is allowed as a special case.

 -- Option: --strict

     This flag mode enables all optional error checking flags.  You can
     see the list of flags enabled by strict mode in the full *note mypy
     –help: 140. output.

     Note: the exact list of flags enabled by running *note –strict: 18.
     may change over time.

 -- Option: --disable-error-code

     This flag allows disabling one or multiple error codes globally.
     See *note Error codes: 176. for more information.

          # no flag
          x = 'a string'
          x.trim()  # error: "str" has no attribute "trim"  [attr-defined]

          # When using --disable-error-code attr-defined
          x = 'a string'
          x.trim()

 -- Option: --enable-error-code

     This flag allows enabling one or multiple error codes globally.
     See *note Error codes: 176. for more information.

     Note: This flag will override disabled error codes from the *note
     –disable-error-code: 175. flag.

          # When using --disable-error-code attr-defined
          x = 'a string'
          x.trim()

          # --disable-error-code attr-defined --enable-error-code attr-defined
          x = 'a string'
          x.trim()  # error: "str" has no attribute "trim"  [attr-defined]


File: Mypy.info,  Node: Configuring error messages,  Next: Incremental mode,  Prev: Miscellaneous strictness flags,  Up: The mypy command line

1.20.11 Configuring error messages
----------------------------------

The following flags let you adjust how much detail mypy displays in
error messages.

 -- Option: --show-error-context

     This flag will precede all errors with “note” messages explaining
     the context of the error.  For example, consider the following
     program:

          class Test:
              def foo(self, x: int) -> int:
                  return x + "bar"

     Mypy normally displays an error message that looks like this:

          main.py:3: error: Unsupported operand types for + ("int" and "str")

     If we enable this flag, the error message now looks like this:

          main.py: note: In member "foo" of class "Test":
          main.py:3: error: Unsupported operand types for + ("int" and "str")

 -- Option: --show-column-numbers

     This flag will add column offsets to error messages.  For example,
     the following indicates an error in line 12, column 9 (note that
     column offsets are 0-based):

          main.py:12:9: error: Unsupported operand types for / ("int" and "str")

 -- Option: --show-error-end

     This flag will make mypy show not just that start position where an
     error was detected, but also the end position of the relevant
     expression.  This way various tools can easily highlight the whole
     error span.  The format is ‘file:line:column:end_line:end_column’.
     This option implies ‘--show-column-numbers’.

 -- Option: --hide-error-codes

     This flag will hide the error code ‘[<code>]’ from error messages.
     By default, the error code is shown after each error message:

          prog.py:1: error: "str" has no attribute "trim"  [attr-defined]

     See *note Error codes: 176. for more information.

 -- Option: --pretty

     Use visually nicer output in error messages: use soft word wrap,
     show source code snippets, and show error location markers.

 -- Option: --no-color-output

     This flag will disable color output in error messages, enabled by
     default.

 -- Option: --no-error-summary

     This flag will disable error summary.  By default mypy shows a
     summary line including total number of errors, number of files with
     errors, and number of files checked.

 -- Option: --show-absolute-path

     Show absolute paths to files.

 -- Option: --soft-error-limit N

     This flag will adjust the limit after which mypy will (sometimes)
     disable reporting most additional errors.  The limit only applies
     if it seems likely that most of the remaining errors will not be
     useful or they may be overly noisy.  If ‘N’ is negative, there is
     no limit.  The default limit is 200.


File: Mypy.info,  Node: Incremental mode,  Next: Advanced options,  Prev: Configuring error messages,  Up: The mypy command line

1.20.12 Incremental mode
------------------------

By default, mypy will store type information into a cache.  Mypy will
use this information to avoid unnecessary recomputation when it type
checks your code again.  This can help speed up the type checking
process, especially when most parts of your program have not changed
since the previous mypy run.

If you want to speed up how long it takes to recheck your code beyond
what incremental mode can offer, try running mypy in *note daemon mode:
2e.

 -- Option: --no-incremental

     This flag disables incremental mode: mypy will no longer reference
     the cache when re-run.

     Note that mypy will still write out to the cache even when
     incremental mode is disabled: see the *note –cache-dir: 185. flag
     below for more details.

 -- Option: --cache-dir DIR

     By default, mypy stores all cache data inside of a folder named
     ‘.mypy_cache’ in the current directory.  This flag lets you change
     this folder.  This flag can also be useful for controlling cache
     use when using *note remote caching: 2f.

     This setting will override the ‘MYPY_CACHE_DIR’ environment
     variable if it is set.

     Mypy will also always write to the cache even when incremental mode
     is disabled so it can “warm up” the cache.  To disable writing to
     the cache, use ‘--cache-dir=/dev/null’ (UNIX) or ‘--cache-dir=nul’
     (Windows).

 -- Option: --sqlite-cache

     Use an SQLite(1) database to store the cache.

 -- Option: --cache-fine-grained

     Include fine-grained dependency information in the cache for the
     mypy daemon.

 -- Option: --skip-version-check

     By default, mypy will ignore cache data generated by a different
     version of mypy.  This flag disables that behavior.

 -- Option: --skip-cache-mtime-checks

     Skip cache internal consistency checks based on mtime.

   ---------- Footnotes ----------

   (1) https://www.sqlite.org/


File: Mypy.info,  Node: Advanced options,  Next: Report generation,  Prev: Incremental mode,  Up: The mypy command line

1.20.13 Advanced options
------------------------

The following flags are useful mostly for people who are interested in
developing or debugging mypy internals.

 -- Option: --pdb

     This flag will invoke the Python debugger when mypy encounters a
     fatal error.

 -- Option: --show-traceback, --tb

     If set, this flag will display a full traceback when mypy
     encounters a fatal error.

 -- Option: --raise-exceptions

     Raise exception on fatal error.

 -- Option: --custom-typing-module MODULE

     This flag lets you use a custom module as a substitute for the
     typing(1) module.

 -- Option: --custom-typeshed-dir DIR

     This flag specifies the directory where mypy looks for standard
     library typeshed stubs, instead of the typeshed that ships with
     mypy.  This is primarily intended to make it easier to test
     typeshed changes before submitting them upstream, but also allows
     you to use a forked version of typeshed.

     Note that this doesn’t affect third-party library stubs.  To test
     third-party stubs, for example try ‘MYPYPATH=stubs/six mypy ...’.
 -- Option: --warn-incomplete-stub

     This flag modifies both the *note –disallow-untyped-defs: 9. and
     *note –disallow-incomplete-defs: 162. flags so they also report
     errors if stubs in typeshed are missing type annotations or has
     incomplete annotations.  If both flags are missing, *note
     –warn-incomplete-stub: 192. also does nothing.

     This flag is mainly intended to be used by people who want
     contribute to typeshed and would like a convenient way to find gaps
     and omissions.

     If you want mypy to report an error when your codebase ‘uses’ an
     untyped function, whether that function is defined in typeshed or
     not, use the *note –disallow-untyped-calls: 161. flag.  See *note
     Untyped definitions and calls: eb. for more details.
 -- Option: --shadow-file SOURCE_FILE SHADOW_FILE

     When mypy is asked to type check ‘SOURCE_FILE’, this flag makes
     mypy read from and type check the contents of ‘SHADOW_FILE’
     instead.  However, diagnostics will continue to refer to
     ‘SOURCE_FILE’.

     Specifying this argument multiple times (‘--shadow-file X1 Y1
     --shadow-file X2 Y2’) will allow mypy to perform multiple
     substitutions.

     This allows tooling to create temporary files with helpful
     modifications without having to change the source file in place.
     For example, suppose we have a pipeline that adds ‘reveal_type’ for
     certain variables.  This pipeline is run on ‘original.py’ to
     produce ‘temp.py’.  Running ‘mypy --shadow-file original.py temp.py
     original.py’ will then cause mypy to type check the contents of
     ‘temp.py’ instead of ‘original.py’, but error messages will still
     reference ‘original.py’.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Report generation,  Next: Miscellaneous<2>,  Prev: Advanced options,  Up: The mypy command line

1.20.14 Report generation
-------------------------

If these flags are set, mypy will generate a report in the specified
format into the specified directory.

 -- Option: --any-exprs-report DIR

     Causes mypy to generate a text file report documenting how many
     expressions of type ‘Any’ are present within your codebase.

 -- Option: --cobertura-xml-report DIR

     Causes mypy to generate a Cobertura XML type checking coverage
     report.

     To generate this report, you must either manually install the
     lxml(1) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

 -- Option: --html-report / --xslt-html-report DIR

     Causes mypy to generate an HTML type checking coverage report.

     To generate this report, you must either manually install the
     lxml(2) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

 -- Option: --linecount-report DIR

     Causes mypy to generate a text file report documenting the
     functions and lines that are typed and untyped within your
     codebase.

 -- Option: --linecoverage-report DIR

     Causes mypy to generate a JSON file that maps each source file’s
     absolute filename to a list of line numbers that belong to typed
     functions in that file.

 -- Option: --lineprecision-report DIR

     Causes mypy to generate a flat text file report with per-module
     statistics of how many lines are typechecked etc.

 -- Option: --txt-report / --xslt-txt-report DIR

     Causes mypy to generate a text file type checking coverage report.

     To generate this report, you must either manually install the
     lxml(3) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

 -- Option: --xml-report DIR

     Causes mypy to generate an XML type checking coverage report.

     To generate this report, you must either manually install the
     lxml(4) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

   ---------- Footnotes ----------

   (1) https://pypi.org/project/lxml/

   (2) https://pypi.org/project/lxml/

   (3) https://pypi.org/project/lxml/

   (4) https://pypi.org/project/lxml/


File: Mypy.info,  Node: Miscellaneous<2>,  Prev: Report generation,  Up: The mypy command line

1.20.15 Miscellaneous
---------------------

 -- Option: --install-types

     This flag causes mypy to install known missing stub packages for
     third-party libraries using pip.  It will display the pip command
     that will be run, and expects a confirmation before installing
     anything.  For security reasons, these stubs are limited to only a
     small subset of manually selected packages that have been verified
     by the typeshed team.  These packages include only stub files and
     no executable code.

     If you use this option without providing any files or modules to
     type check, mypy will install stub packages suggested during the
     previous mypy run.  If there are files or modules to type check,
     mypy first type checks those, and proposes to install missing stubs
     at the end of the run, but only if any missing modules were
     detected.

          Note: This is new in mypy 0.900.  Previous mypy versions
          included a selection of third-party package stubs, instead of
          having them installed separately.

 -- Option: --non-interactive

     When used together with *note –install-types: 135, this causes mypy
     to install all suggested stub packages using pip without asking for
     confirmation, and then continues to perform type checking using the
     installed stubs, if some files or modules are provided to type
     check.

     This is implemented as up to two mypy runs internally.  The first
     run is used to find missing stub packages, and output is shown from
     this run only if no missing stub packages were found.  If missing
     stub packages were found, they are installed and then another run
     is performed.

 -- Option: --junit-xml JUNIT_XML

     Causes mypy to generate a JUnit XML test result document with type
     checking results.  This can make it easier to integrate mypy with
     continuous integration (CI) tools.

 -- Option: --find-occurrences CLASS.MEMBER

     This flag will make mypy print out all usages of a class member
     based on static type information.  This feature is experimental.

 -- Option: --scripts-are-modules

     This flag will give command line arguments that appear to be
     scripts (i.e.  files whose name does not end in ‘.py’) a module
     name derived from the script name rather than the fixed name
     __main__(1).

     This lets you check more than one script in a single mypy
     invocation.  (The default __main__(2) is technically more correct,
     but if you have many scripts that import a large package, the
     behavior enabled by this flag is often more convenient.)

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/__main__.html#module-__main__

   (2) https://docs.python.org/3/library/__main__.html#module-__main__


File: Mypy.info,  Node: The mypy configuration file,  Next: Inline configuration,  Prev: The mypy command line,  Up: Contents

1.21 The mypy configuration file
================================

Mypy supports reading configuration settings from a file.  By default it
uses the file ‘mypy.ini’ with a fallback to ‘.mypy.ini’, then
‘pyproject.toml’, then ‘setup.cfg’ in the current directory, then
‘$XDG_CONFIG_HOME/mypy/config’, then ‘~/.config/mypy/config’, and
finally ‘.mypy.ini’ in the user home directory if none of them are
found; the *note –config-file: 14c. command-line flag can be used to
read a different file instead (see *note Config file: 14b.).

It is important to understand that there is no merging of configuration
files, as it would lead to ambiguity.  The *note –config-file: 14c. flag
has the highest precedence and must be correct; otherwise mypy will
report an error and exit.  Without command line option, mypy will look
for configuration files in the above mentioned order.

Most flags correspond closely to *note command-line flags: a. but there
are some differences in flag names and some flags may take a different
value based on the module being processed.

Some flags support user home directory and environment variable
expansion.  To refer to the user home directory, use ‘~’ at the
beginning of the path.  To expand environment variables use ‘$VARNAME’
or ‘${VARNAME}’.

* Menu:

* Config file format::
* Per-module and global options::
* Inverting option values::
* Examples::
* Import discovery: Import discovery<2>.
* Platform configuration: Platform configuration<2>.
* Disallow dynamic typing: Disallow dynamic typing<2>.
* Untyped definitions and calls: Untyped definitions and calls<2>.
* None and Optional handling: None and Optional handling<2>.
* Configuring warnings: Configuring warnings<2>.
* Suppressing errors::
* Miscellaneous strictness flags: Miscellaneous strictness flags<2>.
* Configuring error messages: Configuring error messages<2>.
* Incremental mode: Incremental mode<2>.
* Advanced options: Advanced options<2>.
* Report generation: Report generation<2>.
* Miscellaneous: Miscellaneous<3>.
* Using a pyproject.toml file: Using a pyproject toml file.
* Example pyproject.toml: Example pyproject toml.


File: Mypy.info,  Node: Config file format,  Next: Per-module and global options,  Up: The mypy configuration file

1.21.1 Config file format
-------------------------

The configuration file format is the usual ini file(1) format.  It
should contain section names in square brackets and flag settings of the
form ‘NAME = VALUE’. Comments start with ‘#’ characters.

   - A section named ‘[mypy]’ must be present.  This specifies the
     global flags.

   - Additional sections named ‘[mypy-PATTERN1,PATTERN2,...]’ may be
     present, where ‘PATTERN1’, ‘PATTERN2’, etc., are comma-separated
     patterns of fully-qualified module names, with some components
     optionally replaced by the ‘*’ character (e.g.  ‘foo.bar’,
     ‘foo.bar.*’, ‘foo.*.baz’).  These sections specify additional flags
     that only apply to ‘modules’ whose name matches at least one of the
     patterns.

     A pattern of the form ‘qualified_module_name’ matches only the
     named module, while ‘dotted_module_name.*’ matches
     ‘dotted_module_name’ and any submodules (so ‘foo.bar.*’ would match
     all of ‘foo.bar’, ‘foo.bar.baz’, and ‘foo.bar.baz.quux’).

     Patterns may also be “unstructured” wildcards, in which stars may
     appear in the middle of a name (e.g ‘site.*.migrations.*’).  Stars
     match zero or more module components (so ‘site.*.migrations.*’ can
     match ‘site.migrations’).  When options conflict, the precedence
     order for configuration is:

            1. *note Inline configuration: 1a6. in the source file

            2. Sections with concrete module names (‘foo.bar’)

            3. Sections with “unstructured” wildcard patterns
               (‘foo.*.baz’), with sections later in the configuration
               file overriding sections earlier.

            4. Sections with “well-structured” wildcard patterns
               (‘foo.bar.*’), with more specific overriding more
               general.

            5. Command line options.

            6. Top-level configuration file options.

The difference in precedence order between “structured” patterns (by
specificity) and “unstructured” patterns (by order in the file) is
unfortunate, and is subject to change in future versions.

     Note: The *note warn_unused_configs: 1a7. flag may be useful to
     debug misspelled section names.

     Note: Configuration flags are liable to change between releases.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/configparser.html


File: Mypy.info,  Node: Per-module and global options,  Next: Inverting option values,  Prev: Config file format,  Up: The mypy configuration file

1.21.2 Per-module and global options
------------------------------------

Some of the config options may be set either globally (in the ‘[mypy]’
section) or on a per-module basis (in sections like ‘[mypy-foo.bar]’).

If you set an option both globally and for a specific module, the module
configuration options take precedence.  This lets you set global
defaults and override them on a module-by-module basis.  If multiple
pattern sections match a module, *note the options from the most
specific section are used where they disagree: 1a5.

Some other options, as specified in their description, may only be set
in the global section (‘[mypy]’).


File: Mypy.info,  Node: Inverting option values,  Next: Examples,  Prev: Per-module and global options,  Up: The mypy configuration file

1.21.3 Inverting option values
------------------------------

Options that take a boolean value may be inverted by adding ‘no_’ to
their name or by (when applicable) swapping their prefix from ‘disallow’
to ‘allow’ (and vice versa).


File: Mypy.info,  Node: Examples,  Next: Import discovery<2>,  Prev: Inverting option values,  Up: The mypy configuration file

1.21.4 Examples
---------------

Here is an example of a ‘mypy.ini’ file.  To use this config file, place
it at the root of your repo and run mypy.

     # Global options:

     [mypy]
     warn_return_any = True
     warn_unused_configs = True

     # Per-module options:

     [mypy-mycode.foo.*]
     disallow_untyped_defs = True

     [mypy-mycode.bar]
     warn_return_any = False

     [mypy-somelibrary]
     ignore_missing_imports = True

This config file specifies two global options in the ‘[mypy]’ section.
These two options will:

  1. Report an error whenever a function returns a value that is
     inferred to have type ‘Any’.

  2. Report any config options that are unused by mypy.  (This will help
     us catch typos when making changes to our config file).

Next, this module specifies three per-module options.  The first two
options change how mypy type checks code in ‘mycode.foo.*’ and
‘mycode.bar’, which we assume here are two modules that you wrote.  The
final config option changes how mypy type checks ‘somelibrary’, which we
assume here is some 3rd party library you’ve installed and are
importing.  These options will:

  1. Selectively disallow untyped function definitions only within the
     ‘mycode.foo’ package – that is, only for function definitions
     defined in the ‘mycode/foo’ directory.

  2. Selectively ‘disable’ the “function is returning any” warnings
     within ‘mycode.bar’ only.  This overrides the global default we set
     earlier.

  3. Suppress any error messages generated when your codebase tries
     importing the module ‘somelibrary’.  This is useful if
     ‘somelibrary’ is some 3rd party library missing type hints.


File: Mypy.info,  Node: Import discovery<2>,  Next: Platform configuration<2>,  Prev: Examples,  Up: The mypy configuration file

1.21.5 Import discovery
-----------------------

For more information, see the *note Import discovery: 150. section of
the command line docs.

 -- Configuration Value: mypy_path


     Type: string

     Specifies the paths to use, after trying the paths from ‘MYPYPATH’
     environment variable.  Useful if you’d like to keep stubs in your
     repo, along with the config file.  Multiple paths are always
     separated with a ‘:’ or ‘,’ regardless of the platform.  User home
     directory and environment variables will be expanded.

     Relative paths are treated relative to the working directory of the
     mypy command, not the config file.  Use the ‘MYPY_CONFIG_FILE_DIR’
     environment variable to refer to paths relative to the config file
     (e.g.  ‘mypy_path = $MYPY_CONFIG_FILE_DIR/src’).

     This option may only be set in the global section (‘[mypy]’).

     ‘Note:’ On Windows, use UNC paths to avoid using ‘:’ (e.g.
     ‘\\127.0.0.1\X$\MyDir’ where ‘X’ is the drive letter).

 -- Configuration Value: files


     Type: comma-separated list of strings

     A comma-separated list of paths which should be checked by mypy if
     none are given on the command line.  Supports recursive file
     globbing using glob(1), where ‘*’ (e.g.  ‘*.py’) matches files in
     the current directory and ‘**/’ (e.g.  ‘**/*.py’) matches files in
     any directories below the current one.  User home directory and
     environment variables will be expanded.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: exclude


     Type: regular expression

     A regular expression that matches file names, directory names and
     paths which mypy should ignore while recursively discovering files
     to check.  Use forward slashes (‘/’) as directory separators on all
     platforms.

          [mypy]
          exclude = (?x)(
              ^one\.py$    # files named "one.py"
              | two\.pyi$  # or files ending with "two.pyi"
              | ^three\.   # or files starting with "three."
            )

     Crafting a single regular expression that excludes multiple files
     while remaining human-readable can be a challenge.  The above
     example demonstrates one approach.  ‘(?x)’ enables the ‘VERBOSE’
     flag for the subsequent regular expression, which ignores most
     whitespace and supports comments(2).  The above is equivalent to:
     ‘(^one\.py$|two\.pyi$|^three\.)’.

     For more details, see *note –exclude: 129.

     This option may only be set in the global section (‘[mypy]’).

          Note: Note that the TOML equivalent differs slightly.  It can
          be either a single string (including a multi-line string) –
          which is treated as a single regular expression – or an array
          of such strings.  The following TOML examples are equivalent
          to the above INI example.

          Array of strings:

               [tool.mypy]
               exclude = [
                   "^one\\.py$",  # TOML's double-quoted strings require escaping backslashes
                   'two\.pyi$',  # but TOML's single-quoted strings do not
                   '^three\.',
               ]

          A single, multi-line string:

               [tool.mypy]
               exclude = '''(?x)(
                   ^one\.py$    # files named "one.py"
                   | two\.pyi$  # or files ending with "two.pyi"
                   | ^three\.   # or files starting with "three."
               )'''  # TOML's single-quoted strings do not require escaping backslashes

          See *note Using a pyproject.toml file: 1ad.

 -- Configuration Value: namespace_packages


     Type: boolean


     Default: True

     Enables PEP 420(3) style namespace packages.  See the corresponding
     flag *note –no-namespace-packages: 12a. for more information.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: explicit_package_bases


     Type: boolean


     Default: False

     This flag tells mypy that top-level packages will be based in
     either the current directory, or a member of the ‘MYPYPATH’
     environment variable or *note mypy_path: 12c. config option.  This
     option is only useful in the absence of ‘__init__.py’.  See *note
     Mapping file paths to modules: 121. for details.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: ignore_missing_imports


     Type: boolean


     Default: False

     Suppresses error messages about imports that cannot be resolved.

     If this option is used in a per-module section, the module name
     should match the name of the ‘imported’ module, not the module
     containing the import statement.

 -- Configuration Value: follow_imports


     Type: string


     Default: ‘normal’

     Directs what to do with imports when the imported module is found
     as a ‘.py’ file and not part of the files, modules and packages
     provided on the command line.

     The four possible values are ‘normal’, ‘silent’, ‘skip’ and
     ‘error’.  For explanations see the discussion for the *note
     –follow-imports: 13c. command line flag.

     Using this option in a per-module section (potentially with a
     wildcard, as described at the top of this page) is a good way to
     prevent mypy from checking portions of your code.

     If this option is used in a per-module section, the module name
     should match the name of the ‘imported’ module, not the module
     containing the import statement.

 -- Configuration Value: follow_imports_for_stubs


     Type: boolean


     Default: False

     Determines whether to respect the *note follow_imports: 13d.
     setting even for stub (‘.pyi’) files.

     Used in conjunction with *note follow_imports=skip: 13d, this can
     be used to suppress the import of a module from ‘typeshed’,
     replacing it with ‘Any’.

     Used in conjunction with *note follow_imports=error: 13d, this can
     be used to make any use of a particular ‘typeshed’ module an error.

          Note: This is not supported by the mypy daemon.

 -- Configuration Value: python_executable


     Type: string

     Specifies the path to the Python executable to inspect to collect a
     list of available *note PEP 561 packages: 14.  User home directory
     and environment variables will be expanded.  Defaults to the
     executable used to run mypy.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: no_site_packages


     Type: bool


     Default: False

     Disables using type information in installed packages (see PEP
     561(4)).  This will also disable searching for a usable Python
     executable.  This acts the same as *note –no-site-packages: 151.
     command line flag.

 -- Configuration Value: no_silence_site_packages


     Type: boolean


     Default: False

     Enables reporting error messages generated within installed
     packages (see PEP 561(5) for more details on distributing type
     information).  Those error messages are suppressed by default,
     since you are usually not able to control errors in 3rd party code.

     This option may only be set in the global section (‘[mypy]’).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/glob.html#module-glob

   (2) https://docs.python.org/3/library/re.html#re.X

   (3) https://peps.python.org/pep-0420/

   (4) https://peps.python.org/pep-0561/

   (5) https://peps.python.org/pep-0561/


File: Mypy.info,  Node: Platform configuration<2>,  Next: Disallow dynamic typing<2>,  Prev: Import discovery<2>,  Up: The mypy configuration file

1.21.6 Platform configuration
-----------------------------

 -- Configuration Value: python_version


     Type: string

     Specifies the Python version used to parse and check the target
     program.  The string should be in the format ‘MAJOR.MINOR’ – for
     example ‘2.7’.  The default is the version of the Python
     interpreter used to run mypy.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: platform


     Type: string

     Specifies the OS platform for the target program, for example
     ‘darwin’ or ‘win32’ (meaning OS X or Windows, respectively).  The
     default is the current platform as revealed by Python’s
     sys.platform(1) variable.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: always_true


     Type: comma-separated list of strings

     Specifies a list of variables that mypy will treat as compile-time
     constants that are always true.

 -- Configuration Value: always_false


     Type: comma-separated list of strings

     Specifies a list of variables that mypy will treat as compile-time
     constants that are always false.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/sys.html#sys.platform


File: Mypy.info,  Node: Disallow dynamic typing<2>,  Next: Untyped definitions and calls<2>,  Prev: Platform configuration<2>,  Up: The mypy configuration file

1.21.7 Disallow dynamic typing
------------------------------

For more information, see the *note Disallow dynamic typing: 158.
section of the command line docs.

 -- Configuration Value: disallow_any_unimported


     Type: boolean


     Default: False

     Disallows usage of types that come from unfollowed imports
     (anything imported from an unfollowed import is automatically given
     a type of ‘Any’).

 -- Configuration Value: disallow_any_expr


     Type: boolean


     Default: False

     Disallows all expressions in the module that have type ‘Any’.

 -- Configuration Value: disallow_any_decorated


     Type: boolean


     Default: False

     Disallows functions that have ‘Any’ in their signature after
     decorator transformation.

 -- Configuration Value: disallow_any_explicit


     Type: boolean


     Default: False

     Disallows explicit ‘Any’ in type positions such as type annotations
     and generic type parameters.

 -- Configuration Value: disallow_any_generics


     Type: boolean


     Default: False

     Disallows usage of generic types that do not specify explicit type
     parameters.

 -- Configuration Value: disallow_subclassing_any


     Type: boolean


     Default: False

     Disallows subclassing a value of type ‘Any’.


File: Mypy.info,  Node: Untyped definitions and calls<2>,  Next: None and Optional handling<2>,  Prev: Disallow dynamic typing<2>,  Up: The mypy configuration file

1.21.8 Untyped definitions and calls
------------------------------------

For more information, see the *note Untyped definitions and calls: eb.
section of the command line docs.

 -- Configuration Value: disallow_untyped_calls


     Type: boolean


     Default: False

     Disallows calling functions without type annotations from functions
     with type annotations.

 -- Configuration Value: disallow_untyped_defs


     Type: boolean


     Default: False

     Disallows defining functions without type annotations or with
     incomplete type annotations.

 -- Configuration Value: disallow_incomplete_defs


     Type: boolean


     Default: False

     Disallows defining functions with incomplete type annotations.

 -- Configuration Value: check_untyped_defs


     Type: boolean


     Default: False

     Type-checks the interior of functions without type annotations.

 -- Configuration Value: disallow_untyped_decorators


     Type: boolean


     Default: False

     Reports an error whenever a function with type annotations is
     decorated with a decorator without annotations.


File: Mypy.info,  Node: None and Optional handling<2>,  Next: Configuring warnings<2>,  Prev: Untyped definitions and calls<2>,  Up: The mypy configuration file

1.21.9 None and Optional handling
---------------------------------

For more information, see the *note None and Optional handling: 165.
section of the command line docs.

 -- Configuration Value: implicit_optional


     Type: boolean


     Default: False

     Causes mypy to treat arguments with a ‘None’ default value as
     having an implicit Optional(1) type.

     ‘Note:’ This was True by default in mypy versions 0.980 and
     earlier.

 -- Configuration Value: strict_optional


     Type: boolean


     Default: True

     Enables or disables strict Optional checks.  If False, mypy treats
     ‘None’ as compatible with every type.

     ‘Note:’ This was False by default in mypy versions earlier than
     0.600.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Optional


File: Mypy.info,  Node: Configuring warnings<2>,  Next: Suppressing errors,  Prev: None and Optional handling<2>,  Up: The mypy configuration file

1.21.10 Configuring warnings
----------------------------

For more information, see the *note Configuring warnings: 168. section
of the command line docs.

 -- Configuration Value: warn_redundant_casts


     Type: boolean


     Default: False

     Warns about casting an expression to its inferred type.

     This option may only be set in the global section (‘[mypy]’).

 -- Configuration Value: warn_unused_ignores


     Type: boolean


     Default: False

     Warns about unneeded ‘# type: ignore’ comments.

 -- Configuration Value: warn_no_return


     Type: boolean


     Default: True

     Shows errors for missing return statements on some execution paths.

 -- Configuration Value: warn_return_any


     Type: boolean


     Default: False

     Shows a warning when returning a value with type ‘Any’ from a
     function declared with a non- ‘Any’ return type.

 -- Configuration Value: warn_unreachable


     Type: boolean


     Default: False

     Shows a warning when encountering any code inferred to be
     unreachable or redundant after performing type analysis.


File: Mypy.info,  Node: Suppressing errors,  Next: Miscellaneous strictness flags<2>,  Prev: Configuring warnings<2>,  Up: The mypy configuration file

1.21.11 Suppressing errors
--------------------------

Note: these configuration options are available in the config file only.
There is no analog available via the command line options.

 -- Configuration Value: ignore_errors


     Type: boolean


     Default: False

     Ignores all non-fatal errors.


File: Mypy.info,  Node: Miscellaneous strictness flags<2>,  Next: Configuring error messages<2>,  Prev: Suppressing errors,  Up: The mypy configuration file

1.21.12 Miscellaneous strictness flags
--------------------------------------

For more information, see the *note Miscellaneous strictness flags: 16f.
section of the command line docs.

 -- Configuration Value: allow_untyped_globals


     Type: boolean


     Default: False

     Causes mypy to suppress errors caused by not being able to fully
     infer the types of global and class variables.

 -- Configuration Value: allow_redefinition


     Type: boolean


     Default: False

     Allows variables to be redefined with an arbitrary type, as long as
     the redefinition is in the same block and nesting level as the
     original definition.  Example where this can be useful:

          def process(items: list[str]) -> None:
              # 'items' has type list[str]
              items = [item.split() for item in items]
              # 'items' now has type list[list[str]]

     The variable must be used before it can be redefined:

          def process(items: list[str]) -> None:
             items = "mypy"  # invalid redefinition to str because the variable hasn't been used yet
             print(items)
             items = "100"  # valid, items now has type str
             items = int(items)  # valid, items now has type int

 -- Configuration Value: local_partial_types


     Type: boolean


     Default: False

     Disallows inferring variable type for ‘None’ from two assignments
     in different scopes.  This is always implicitly enabled when using
     the *note mypy daemon: 2e.

 -- Configuration Value: disable_error_code


     Type: comma-separated list of strings

     Allows disabling one or multiple error codes globally.

 -- Configuration Value: enable_error_code


     Type: comma-separated list of strings

     Allows enabling one or multiple error codes globally.

     Note: This option will override disabled error codes from the
     disable_error_code option.

 -- Configuration Value: implicit_reexport


     Type: boolean


     Default: True

     By default, imported values to a module are treated as exported and
     mypy allows other modules to import them.  When false, mypy will
     not re-export unless the item is imported using from-as or is
     included in ‘__all__’.  Note that mypy treats stub files as if this
     is always disabled.  For example:

          # This won't re-export the value
          from foo import bar
          # This will re-export it as bar and allow other modules to import it
          from foo import bar as bar
          # This will also re-export bar
          from foo import bar
          __all__ = ['bar']

 -- Configuration Value: strict_concatenate


     Type: boolean


     Default: False

     Make arguments prepended via ‘Concatenate’ be truly
     positional-only.

 -- Configuration Value: strict_equality


          type: boolean


          default: False

     Prohibit equality checks, identity checks, and container checks
     between non-overlapping types.

 -- Configuration Value: strict


          type: boolean


          default: False

     Enable all optional error checking flags.  You can see the list of
     flags enabled by strict mode in the full *note mypy –help: 140.
     output.

     Note: the exact list of flags enabled by *note strict: 1d8. may
     change over time.


File: Mypy.info,  Node: Configuring error messages<2>,  Next: Incremental mode<2>,  Prev: Miscellaneous strictness flags<2>,  Up: The mypy configuration file

1.21.13 Configuring error messages
----------------------------------

For more information, see the *note Configuring error messages: 178.
section of the command line docs.

These options may only be set in the global section (‘[mypy]’).

 -- Configuration Value: show_error_context


     Type: boolean


     Default: False

     Prefixes each error with the relevant context.

 -- Configuration Value: show_column_numbers


     Type: boolean


     Default: False

     Shows column numbers in error messages.

 -- Configuration Value: hide_error_codes


     Type: boolean


     Default: False

     Hides error codes in error messages.  See *note Error codes: 176.
     for more information.

 -- Configuration Value: pretty


     Type: boolean


     Default: False

     Use visually nicer output in error messages: use soft word wrap,
     show source code snippets, and show error location markers.

 -- Configuration Value: color_output


     Type: boolean


     Default: True

     Shows error messages with color enabled.

 -- Configuration Value: error_summary


     Type: boolean


     Default: True

     Shows a short summary line after error messages.

 -- Configuration Value: show_absolute_path


     Type: boolean


     Default: False

     Show absolute paths to files.


File: Mypy.info,  Node: Incremental mode<2>,  Next: Advanced options<2>,  Prev: Configuring error messages<2>,  Up: The mypy configuration file

1.21.14 Incremental mode
------------------------

These options may only be set in the global section (‘[mypy]’).

 -- Configuration Value: incremental


     Type: boolean


     Default: True

     Enables *note incremental mode: 183.

 -- Configuration Value: cache_dir


     Type: string


     Default: ‘.mypy_cache’

     Specifies the location where mypy stores incremental cache info.
     User home directory and environment variables will be expanded.
     This setting will be overridden by the ‘MYPY_CACHE_DIR’ environment
     variable.

     Note that the cache is only read when incremental mode is enabled
     but is always written to, unless the value is set to ‘/dev/null’
     (UNIX) or ‘nul’ (Windows).

 -- Configuration Value: sqlite_cache


     Type: boolean


     Default: False

     Use an SQLite(1) database to store the cache.

 -- Configuration Value: cache_fine_grained


     Type: boolean


     Default: False

     Include fine-grained dependency information in the cache for the
     mypy daemon.

 -- Configuration Value: skip_version_check


     Type: boolean


     Default: False

     Makes mypy use incremental cache data even if it was generated by a
     different version of mypy.  (By default, mypy will perform a
     version check and regenerate the cache if it was written by older
     versions of mypy.)

 -- Configuration Value: skip_cache_mtime_checks


     Type: boolean


     Default: False

     Skip cache internal consistency checks based on mtime.

   ---------- Footnotes ----------

   (1) https://www.sqlite.org/


File: Mypy.info,  Node: Advanced options<2>,  Next: Report generation<2>,  Prev: Incremental mode<2>,  Up: The mypy configuration file

1.21.15 Advanced options
------------------------

These options may only be set in the global section (‘[mypy]’).

 -- Configuration Value: plugins


     Type: comma-separated list of strings

     A comma-separated list of mypy plugins.  See *note Extending mypy
     using plugins: 1ea.

 -- Configuration Value: pdb


     Type: boolean


     Default: False

     Invokes pdb(1) on fatal error.

 -- Configuration Value: show_traceback


     Type: boolean


     Default: False

     Shows traceback on fatal error.

 -- Configuration Value: raise_exceptions


     Type: boolean


     Default: False

     Raise exception on fatal error.

 -- Configuration Value: custom_typing_module


     Type: string

     Specifies a custom module to use as a substitute for the typing(2)
     module.

 -- Configuration Value: custom_typeshed_dir


     Type: string

     This specifies the directory where mypy looks for standard library
     typeshed stubs, instead of the typeshed that ships with mypy.  This
     is primarily intended to make it easier to test typeshed changes
     before submitting them upstream, but also allows you to use a
     forked version of typeshed.

     User home directory and environment variables will be expanded.

     Note that this doesn’t affect third-party library stubs.  To test
     third-party stubs, for example try ‘MYPYPATH=stubs/six mypy ...’.

 -- Configuration Value: warn_incomplete_stub


     Type: boolean


     Default: False

     Warns about missing type annotations in typeshed.  This is only
     relevant in combination with *note disallow_untyped_defs: 2b. or
     *note disallow_incomplete_defs: 1c2.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/pdb.html#module-pdb

   (2) https://docs.python.org/3/library/typing.html#module-typing


File: Mypy.info,  Node: Report generation<2>,  Next: Miscellaneous<3>,  Prev: Advanced options<2>,  Up: The mypy configuration file

1.21.16 Report generation
-------------------------

If these options are set, mypy will generate a report in the specified
format into the specified directory.

 -- Configuration Value: any_exprs_report


     Type: string

     Causes mypy to generate a text file report documenting how many
     expressions of type ‘Any’ are present within your codebase.

 -- Configuration Value: cobertura_xml_report


     Type: string

     Causes mypy to generate a Cobertura XML type checking coverage
     report.

     To generate this report, you must either manually install the
     lxml(1) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

 -- Configuration Value: html_report / xslt_html_report


     Type: string

     Causes mypy to generate an HTML type checking coverage report.

     To generate this report, you must either manually install the
     lxml(2) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

 -- Configuration Value: linecount_report


     Type: string

     Causes mypy to generate a text file report documenting the
     functions and lines that are typed and untyped within your
     codebase.

 -- Configuration Value: linecoverage_report


     Type: string

     Causes mypy to generate a JSON file that maps each source file’s
     absolute filename to a list of line numbers that belong to typed
     functions in that file.

 -- Configuration Value: lineprecision_report


     Type: string

     Causes mypy to generate a flat text file report with per-module
     statistics of how many lines are typechecked etc.

 -- Configuration Value: txt_report / xslt_txt_report


     Type: string

     Causes mypy to generate a text file type checking coverage report.

     To generate this report, you must either manually install the
     lxml(3) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

 -- Configuration Value: xml_report


     Type: string

     Causes mypy to generate an XML type checking coverage report.

     To generate this report, you must either manually install the
     lxml(4) library or specify mypy installation with the setuptools
     extra ‘mypy[reports]’.

   ---------- Footnotes ----------

   (1) https://pypi.org/project/lxml/

   (2) https://pypi.org/project/lxml/

   (3) https://pypi.org/project/lxml/

   (4) https://pypi.org/project/lxml/


File: Mypy.info,  Node: Miscellaneous<3>,  Next: Using a pyproject toml file,  Prev: Report generation<2>,  Up: The mypy configuration file

1.21.17 Miscellaneous
---------------------

These options may only be set in the global section (‘[mypy]’).

 -- Configuration Value: junit_xml


     Type: string

     Causes mypy to generate a JUnit XML test result document with type
     checking results.  This can make it easier to integrate mypy with
     continuous integration (CI) tools.

 -- Configuration Value: scripts_are_modules


     Type: boolean


     Default: False

     Makes script ‘x’ become module ‘x’ instead of ‘__main__’.  This is
     useful when checking multiple scripts in a single run.

 -- Configuration Value: warn_unused_configs


     Type: boolean


     Default: False

     Warns about per-module sections in the config file that do not
     match any files processed when invoking mypy.  (This requires
     turning off incremental mode using *note incremental = False: 1e2.)

 -- Configuration Value: verbosity


     Type: integer


     Default: 0

     Controls how much debug output will be generated.  Higher numbers
     are more verbose.


File: Mypy.info,  Node: Using a pyproject toml file,  Next: Example pyproject toml,  Prev: Miscellaneous<3>,  Up: The mypy configuration file

1.21.18 Using a pyproject.toml file
-----------------------------------

Instead of using a ‘mypy.ini’ file, a ‘pyproject.toml’ file (as
specified by PEP 518(1)) may be used instead.  A few notes on doing so:

   * The ‘[mypy]’ section should have ‘tool.’ prepended to its name:

        * I.e., ‘[mypy]’ would become ‘[tool.mypy]’

   * The module specific sections should be moved into
     ‘[[tool.mypy.overrides]]’ sections:

        * For example, ‘[mypy-packagename]’ would become:

     [[tool.mypy.overrides]]
     module = 'packagename'
     ...

   * Multi-module specific sections can be moved into a single
     ‘[[tool.mypy.overrides]]’ section with a module property set to an
     array of modules:

        * For example, ‘[mypy-packagename,packagename2]’ would become:

     [[tool.mypy.overrides]]
     module = [
         'packagename',
         'packagename2'
     ]
     ...

   * The following care should be given to values in the
     ‘pyproject.toml’ files as compared to ‘ini’ files:

        * Strings must be wrapped in double quotes, or single quotes if
          the string contains special characters

        * Boolean values should be all lower case

Please see the TOML Documentation(2) for more details and information on
what is allowed in a ‘toml’ file.  See PEP 518(3) for more information
on the layout and structure of the ‘pyproject.toml’ file.

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0518/

   (2) https://toml.io/

   (3) https://www.python.org/dev/peps/pep-0518/


File: Mypy.info,  Node: Example pyproject toml,  Prev: Using a pyproject toml file,  Up: The mypy configuration file

1.21.19 Example ‘pyproject.toml’
--------------------------------

Here is an example of a ‘pyproject.toml’ file.  To use this config file,
place it at the root of your repo (or append it to the end of an
existing ‘pyproject.toml’ file) and run mypy.

     # mypy global options:

     [tool.mypy]
     python_version = "2.7"
     warn_return_any = true
     warn_unused_configs = true
     exclude = [
         '^file1\.py$',  # TOML literal string (single-quotes, no escaping necessary)
         "^file2\\.py$",  # TOML basic string (double-quotes, backslash and other characters need escaping)
     ]

     # mypy per-module options:

     [[tool.mypy.overrides]]
     module = "mycode.foo.*"
     disallow_untyped_defs = true

     [[tool.mypy.overrides]]
     module = "mycode.bar"
     warn_return_any = false

     [[tool.mypy.overrides]]
     module = [
         "somelibrary",
         "some_other_library"
     ]
     ignore_missing_imports = true


File: Mypy.info,  Node: Inline configuration,  Next: Mypy daemon mypy server,  Prev: The mypy configuration file,  Up: Contents

1.22 Inline configuration
=========================

Mypy supports setting per-file configuration options inside files
themselves using ‘# mypy:’ comments.  For example:

     # mypy: disallow-any-generics

Inline configuration comments take precedence over all other
configuration mechanisms.

* Menu:

* Configuration comment format::


File: Mypy.info,  Node: Configuration comment format,  Up: Inline configuration

1.22.1 Configuration comment format
-----------------------------------

Flags correspond to *note config file flags: 20. but allow hyphens to be
substituted for underscores.

Values are specified using ‘=’, but ‘= True’ may be omitted:

     # mypy: disallow-any-generics
     # mypy: always-true=FOO

Multiple flags can be separated by commas or placed on separate lines.
To include a comma as part of an option’s value, place the value inside
quotes:

     # mypy: disallow-untyped-defs, always-false="FOO,BAR"

Like in the configuration file, options that take a boolean value may be
inverted by adding ‘no-’ to their name or by (when applicable) swapping
their prefix from ‘disallow’ to ‘allow’ (and vice versa):

     # mypy: allow-untyped-defs, no-strict-optional


File: Mypy.info,  Node: Mypy daemon mypy server,  Next: Using installed packages,  Prev: Inline configuration,  Up: Contents

1.23 Mypy daemon (mypy server)
==============================

Instead of running mypy as a command-line tool, you can also run it as a
long-running daemon (server) process and use a command-line client to
send type-checking requests to the server.  This way mypy can perform
type checking much faster, since program state cached from previous runs
is kept in memory and doesn’t have to be read from the file system on
each run.  The server also uses finer-grained dependency tracking to
reduce the amount of work that needs to be done.

If you have a large codebase to check, running mypy using the mypy
daemon can be ‘10 or more times faster’ than the regular command-line
‘mypy’ tool, especially if your workflow involves running mypy
repeatedly after small edits – which is often a good idea, as this way
you’ll find errors sooner.

     Note: The command-line interface of mypy daemon may change in
     future mypy releases.

     Note: Each mypy daemon process supports one user and one set of
     source files, and it can only process one type checking request at
     a time.  You can run multiple mypy daemon processes to type check
     multiple repositories.

* Menu:

* Basic usage::
* Daemon client commands::
* Additional daemon flags::
* Static inference of annotations::
* Statically inspect expressions::


File: Mypy.info,  Node: Basic usage,  Next: Daemon client commands,  Up: Mypy daemon mypy server

1.23.1 Basic usage
------------------

The client utility ‘dmypy’ is used to control the mypy daemon.  Use
‘dmypy run -- <flags> <files>’ to type check a set of files (or
directories).  This will launch the daemon if it is not running.  You
can use almost arbitrary mypy flags after ‘--’.  The daemon will always
run on the current host.  Example:

     dmypy run -- prog.py pkg/*.py

‘dmypy run’ will automatically restart the daemon if the configuration
or mypy version changes.

The initial run will process all the code and may take a while to
finish, but subsequent runs will be quick, especially if you’ve only
changed a few files.  (You can use *note remote caching: 2f. to speed up
the initial run.  The speedup can be significant if you have a large
codebase.)

     Note: Mypy 0.780 added support for following imports in dmypy
     (enabled by default).  This functionality is still experimental.
     You can use ‘--follow-imports=skip’ or ‘--follow-imports=error’ to
     fall back to the stable functionality.  See *note Following
     imports: 26. for details on how these work.


File: Mypy.info,  Node: Daemon client commands,  Next: Additional daemon flags,  Prev: Basic usage,  Up: Mypy daemon mypy server

1.23.2 Daemon client commands
-----------------------------

While ‘dmypy run’ is sufficient for most uses, some workflows (ones
using *note remote caching: 2f, perhaps), require more precise control
over the lifetime of the daemon process:

   * ‘dmypy stop’ stops the daemon.

   * ‘dmypy start -- <flags>’ starts the daemon but does not check any
     files.  You can use almost arbitrary mypy flags after ‘--’.

   * ‘dmypy restart -- <flags>’ restarts the daemon.  The flags are the
     same as with ‘dmypy start’.  This is equivalent to a stop command
     followed by a start.

   * Use ‘dmypy run --timeout SECONDS -- <flags>’ (or ‘start’ or
     ‘restart’) to automatically shut down the daemon after inactivity.
     By default, the daemon runs until it’s explicitly stopped.

   * ‘dmypy check <files>’ checks a set of files using an already
     running daemon.

   * ‘dmypy recheck’ checks the same set of files as the most recent
     ‘check’ or ‘recheck’ command.  (You can also use the *note –update:
     208. and *note –remove: 209. options to alter the set of files, and
     to define which files should be processed.)

   * ‘dmypy status’ checks whether a daemon is running.  It prints a
     diagnostic and exits with ‘0’ if there is a running daemon.

Use ‘dmypy --help’ for help on additional commands and command-line
options not discussed here, and ‘dmypy <command> --help’ for help on
command-specific options.


File: Mypy.info,  Node: Additional daemon flags,  Next: Static inference of annotations,  Prev: Daemon client commands,  Up: Mypy daemon mypy server

1.23.3 Additional daemon flags
------------------------------

 -- Option: --status-file FILE

     Use ‘FILE’ as the status file for storing daemon runtime state.
     This is normally a JSON file that contains information about daemon
     process and connection.  The default path is ‘.dmypy.json’ in the
     current working directory.

 -- Option: --log-file FILE

     Direct daemon stdout/stderr to ‘FILE’.  This is useful for
     debugging daemon crashes, since the server traceback is not always
     printed by the client.  This is available for the ‘start’,
     ‘restart’, and ‘run’ commands.

 -- Option: --timeout TIMEOUT

     Automatically shut down server after ‘TIMEOUT’ seconds of
     inactivity.  This is available for the ‘start’, ‘restart’, and
     ‘run’ commands.

 -- Option: --update FILE

     Re-check ‘FILE’, or add it to the set of files being checked (and
     check it).  This option may be repeated, and it’s only available
     for the ‘recheck’ command.  By default, mypy finds and checks all
     files changed since the previous run and files that depend on them.
     However, if you use this option (and/or *note –remove: 209.), mypy
     assumes that only the explicitly specified files have changed.
     This is only useful to speed up mypy if you type check a very large
     number of files, and use an external, fast file system watcher,
     such as watchman(1) or watchdog(2), to determine which files got
     edited or deleted.  ‘Note:’ This option is never required and is
     only available for performance tuning.

 -- Option: --remove FILE

     Remove ‘FILE’ from the set of files being checked.  This option may
     be repeated.  This is only available for the ‘recheck’ command.
     See *note –update: 208. above for when this may be useful.  ‘Note:’
     This option is never required and is only available for performance
     tuning.

 -- Option: --fswatcher-dump-file FILE

     Collect information about the current internal file state.  This is
     only available for the ‘status’ command.  This will dump JSON to
     ‘FILE’ in the format ‘{path: [modification_time, size,
     content_hash]}’.  This is useful for debugging the built-in file
     system watcher.  ‘Note:’ This is an internal flag and the format
     may change.

 -- Option: --perf-stats-file FILE

     Write performance profiling information to ‘FILE’.  This is only
     available for the ‘check’, ‘recheck’, and ‘run’ commands.

 -- Option: --export-types

     Store all expression types in memory for future use.  This is
     useful to speed up future calls to ‘dmypy inspect’ (but uses more
     memory).  Only valid for ‘check’, ‘recheck’, and ‘run’ command.

   ---------- Footnotes ----------

   (1) https://facebook.github.io/watchman/

   (2) https://pypi.org/project/watchdog/


File: Mypy.info,  Node: Static inference of annotations,  Next: Statically inspect expressions,  Prev: Additional daemon flags,  Up: Mypy daemon mypy server

1.23.4 Static inference of annotations
--------------------------------------

The mypy daemon supports (as an experimental feature) statically
inferring draft function and method type annotations.  Use ‘dmypy
suggest FUNCTION’ to generate a draft signature in the format
‘(param_type_1, param_type_2, ...) -> ret_type’ (types are included for
all arguments, including keyword-only arguments, ‘*args’ and
‘**kwargs’).

This is a low-level feature intended to be used by editor integrations,
IDEs, and other tools (for example, the mypy plugin for PyCharm(1)), to
automatically add annotations to source files, or to propose function
signatures.

In this example, the function ‘format_id()’ has no annotation:

     def format_id(user):
         return f"User: {user}"

     root = format_id(0)

‘dmypy suggest’ uses call sites, return statements, and other heuristics
(such as looking for signatures in base classes) to infer that
‘format_id()’ accepts an ‘int’ argument and returns a ‘str’.  Use ‘dmypy
suggest module.format_id’ to print the suggested signature for the
function.

More generally, the target function may be specified in two ways:

   * By its fully qualified name, i.e.
     ‘[package.]module.[class.]function’.

   * By its location in a source file, i.e.  ‘/path/to/file.py:line’.
     The path can be absolute or relative, and ‘line’ can refer to any
     line number within the function body.

This command can also be used to find a more precise alternative for an
existing, imprecise annotation with some ‘Any’ types.

The following flags customize various aspects of the ‘dmypy suggest’
command.

 -- Option: --json

     Output the signature as JSON, so that PyAnnotate(2) can read it and
     add the signature to the source file.  Here is what the JSON looks
     like:

          [{"func_name": "example.format_id",
            "line": 1,
            "path": "/absolute/path/to/example.py",
            "samples": 0,
            "signature": {"arg_types": ["int"], "return_type": "str"}}]

 -- Option: --no-errors

     Only produce suggestions that cause no errors in the checked code.
     By default, mypy will try to find the most precise type, even if it
     causes some type errors.

 -- Option: --no-any

     Only produce suggestions that don’t contain ‘Any’ types.  By
     default mypy proposes the most precise signature found, even if it
     contains ‘Any’ types.

 -- Option: --flex-any FRACTION

     Only allow some fraction of types in the suggested signature to be
     ‘Any’ types.  The fraction ranges from ‘0’ (same as ‘--no-any’) to
     ‘1’.

 -- Option: --callsites

     Only find call sites for a given function instead of suggesting a
     type.  This will produce a list with line numbers and types of
     actual arguments for each call: ‘/path/to/file.py:line:
     (arg_type_1, arg_type_2, ...)’.

 -- Option: --use-fixme NAME

     Use a dummy name instead of plain ‘Any’ for types that cannot be
     inferred.  This may be useful to emphasize to a user that a given
     type couldn’t be inferred and needs to be entered manually.

 -- Option: --max-guesses NUMBER

     Set the maximum number of types to try for a function (default:
     ‘64’).

   ---------- Footnotes ----------

   (1) https://github.com/dropbox/mypy-PyCharm-plugin

   (2) https://github.com/dropbox/pyannotate


File: Mypy.info,  Node: Statically inspect expressions,  Prev: Static inference of annotations,  Up: Mypy daemon mypy server

1.23.5 Statically inspect expressions
-------------------------------------

The daemon allows to get declared or inferred type of an expression (or
other information about an expression, such as known attributes or
definition location) using ‘dmypy inspect LOCATION’ command.  The
location of the expression should be specified in the format
‘path/to/file.py:line:column[:end_line:end_column]’.  Both line and
column are 1-based.  Both start and end position are inclusive.  These
rules match how mypy prints the error location in error messages.

If a span is given (i.e.  all 4 numbers), then only an exactly matching
expression is inspected.  If only a position is given (i.e.  2 numbers,
line and column), mypy will inspect all ‘expressions’, that include this
position, starting from the innermost one.

Consider this Python code snippet:

     def foo(x: int, longer_name: str) -> None:
         x
         longer_name

Here to find the type of ‘x’ one needs to call ‘dmypy inspect
src.py:2:5:2:5’ or ‘dmypy inspect src.py:2:5’.  While for ‘longer_name’
one needs to call ‘dmypy inspect src.py:3:5:3:15’ or, for example,
‘dmypy inspect src.py:3:10’.  Please note that this command is only
valid after daemon had a successful type check (without parse errors),
so that types are populated, e.g.  using ‘dmypy check’.  In case where
multiple expressions match the provided location, their types are
returned separated by a newline.

Important note: it is recommended to check files with *note
–export-types: 210. since otherwise most inspections will not work
without *note –force-reload: 21a.

 -- Option: --show INSPECTION

     What kind of inspection to run for expression(s) found.  Currently
     the supported inspections are:

        * ‘type’ (default): Show the best known type of a given
          expression.

        * ‘attrs’: Show which attributes are valid for an expression
          (e.g.  for auto-completion).  Format is ‘{"Base1": ["name_1",
          "name_2", ...]; "Base2": ...}’.  Names are sorted by method
          resolution order.  If expression refers to a module, then
          module attributes will be under key like
          ‘"<full.module.name>"’.

        * ‘definition’ (experimental): Show the definition location for
          a name expression or member expression.  Format is
          ‘path/to/file.py:line:column:Symbol’.  If multiple definitions
          are found (e.g.  for a Union attribute), they are separated by
          comma.

 -- Option: --verbose

     Increase verbosity of types string representation (can be
     repeated).  For example, this will print fully qualified names of
     instance types (like ‘"builtins.str"’), instead of just a short
     name (like ‘"str"’).

 -- Option: --limit NUM

     If the location is given as ‘line:column’, this will cause daemon
     to return only at most ‘NUM’ inspections of innermost expressions.
     Value of 0 means no limit (this is the default).  For example, if
     one calls ‘dmypy inspect src.py:4:10 --limit=1’ with this code

          def foo(x: int) -> str: ..
          def bar(x: str) -> None: ...
          baz: int
          bar(foo(baz))

     This will output just one type ‘"int"’ (for ‘baz’ name expression).
     While without the limit option, it would output all three types:
     ‘"int"’, ‘"str"’, and ‘"None"’.

 -- Option: --include-span

     With this option on, the daemon will prepend each inspection result
     with the full span of corresponding expression, formatted as
     ‘1:2:1:4 -> "int"’.  This may be useful in case multiple
     expressions match a location.

 -- Option: --include-kind

     With this option on, the daemon will prepend each inspection result
     with the kind of corresponding expression, formatted as ‘NameExpr
     -> "int"’.  If both this option and *note –include-span: 21e. are
     on, the kind will appear first, for example ‘NameExpr:1:2:1:4 ->
     "int"’.

 -- Option: --include-object-attrs

     This will make the daemon include attributes of ‘object’ (excluded
     by default) in case of an ‘atts’ inspection.

 -- Option: --union-attrs

     Include attributes valid for some of possible expression types (by
     default an intersection is returned).  This is useful for union
     types of type variables with values.  For example, with this code:

          from typing import Union

          class A:
              x: int
              z: int
          class B:
              y: int
              z: int
          var: Union[A, B]
          var

     The command ‘dmypy inspect --show attrs src.py:10:1’ will return
     ‘{"A": ["z"], "B": ["z"]}’, while with ‘--union-attrs’ it will
     return ‘{"A": ["x", "z"], "B": ["y", "z"]}’.

 -- Option: --force-reload

     Force re-parsing and re-type-checking file before inspection.  By
     default this is done only when needed (for example file was not
     loaded from cache or daemon was initially run without
     ‘--export-types’ mypy option), since reloading may be slow (up to
     few seconds for very large files).


File: Mypy.info,  Node: Using installed packages,  Next: Extending and integrating mypy,  Prev: Mypy daemon mypy server,  Up: Contents

1.24 Using installed packages
=============================

Packages installed with pip can declare that they support type checking.
For example, the aiohttp(1) package has built-in support for type
checking.

Packages can also provide stubs for a library.  For example,
‘types-requests’ is a stub-only package that provides stubs for the
requests(2) package.  Stub packages are usually published from
typeshed(3), a shared repository for Python library stubs, and have a
name of form ‘types-<library>’.  Note that many stub packages are not
maintained by the original maintainers of the package.

The sections below explain how mypy can use these packages, and how you
can create such packages.

     Note: PEP 561(4) specifies how a package can declare that it
     supports type checking.

     Note: New versions of stub packages often use type system features
     not supported by older, and even fairly recent mypy versions.  If
     you pin to an older version of mypy (using ‘requirements.txt’, for
     example), it is recommended that you also pin the versions of all
     your stub package dependencies.

     Note: Starting in mypy 0.900, most third-party package stubs must
     be installed explicitly.  This decouples mypy and stub versioning,
     allowing stubs to updated without updating mypy.  This also allows
     stubs not originally included with mypy to be installed.  Earlier
     mypy versions included a fixed set of stubs for third-party
     packages.

* Menu:

* Using installed packages with mypy (PEP 561): Using installed packages with mypy PEP 561.
* Creating PEP 561 compatible packages::

   ---------- Footnotes ----------

   (1) https://docs.aiohttp.org/en/stable/

   (2) https://requests.readthedocs.io/en/master/

   (3) https://github.com/python/typeshed

   (4) https://peps.python.org/pep-0561/


File: Mypy.info,  Node: Using installed packages with mypy PEP 561,  Next: Creating PEP 561 compatible packages,  Up: Using installed packages

1.24.1 Using installed packages with mypy (PEP 561)
---------------------------------------------------

Typically mypy will automatically find and use installed packages that
support type checking or provide stubs.  This requires that you install
the packages in the Python environment that you use to run mypy.  As
many packages don’t support type checking yet, you may also have to
install a separate stub package, usually named ‘types-<library>’.  (See
*note Missing imports: 13. for how to deal with libraries that don’t
support type checking and are also missing stubs.)

If you have installed typed packages in another Python installation or
environment, mypy won’t automatically find them.  One option is to
install another copy of those packages in the environment in which you
installed mypy.  Alternatively, you can use the *note
–python-executable: 137. flag to point to the Python executable for
another environment, and mypy will find packages installed for that
Python executable.

Note that mypy does not support some more advanced import features, such
as zip imports and custom import hooks.

If you don’t want to use installed packages that provide type
information at all, use the *note –no-site-packages: 151. flag to
disable searching for installed packages.

Note that stub-only packages cannot be used with ‘MYPYPATH’.  If you
want mypy to find the package, it must be installed.  For a package
‘foo’, the name of the stub-only package (‘foo-stubs’) is not a legal
package name, so mypy will not find it, unless it is installed (see PEP
561: Stub-only Packages(1) for more information).

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0561/#stub-only-packages


File: Mypy.info,  Node: Creating PEP 561 compatible packages,  Prev: Using installed packages with mypy PEP 561,  Up: Using installed packages

1.24.2 Creating PEP 561 compatible packages
-------------------------------------------

     Note: You can generally ignore this section unless you maintain a
     package on PyPI, or want to publish type information for an
     existing PyPI package.

PEP 561(1) describes three main ways to distribute type information:

  1. A package has inline type annotations in the Python implementation.

  2. A package ships *note stub files: 15. with type information
     alongside the Python implementation.

  3. A package ships type information for another package separately as
     stub files (also known as a “stub-only package”).

If you want to create a stub-only package for an existing library, the
simplest way is to contribute stubs to the typeshed(2) repository, and a
stub package will automatically be uploaded to PyPI.

If you would like to publish a library package to a package repository
yourself (e.g.  on PyPI) for either internal or external use in type
checking, packages that supply type information via type comments or
annotations in the code should put a ‘py.typed’ file in their package
directory.  For example, here is a typical directory structure:

     setup.py
     package_a/
         __init__.py
         lib.py
         py.typed

The ‘setup.py’ file could look like this:

     from distutils.core import setup

     setup(
         name="SuperPackageA",
         author="Me",
         version="0.1",
         package_data={"package_a": ["py.typed"]},
         packages=["package_a"]
     )

     Note: If you use setuptools(3), you must pass the option
     ‘zip_safe=False’ to ‘setup()’, or mypy will not be able to find the
     installed package.

Some packages have a mix of stub files and runtime files.  These
packages also require a ‘py.typed’ file.  An example can be seen below:

     setup.py
     package_b/
         __init__.py
         lib.py
         lib.pyi
         py.typed

The ‘setup.py’ file might look like this:

     from distutils.core import setup

     setup(
         name="SuperPackageB",
         author="Me",
         version="0.1",
         package_data={"package_b": ["py.typed", "lib.pyi"]},
         packages=["package_b"]
     )

In this example, both ‘lib.py’ and the ‘lib.pyi’ stub file exist.  At
runtime, the Python interpreter will use ‘lib.py’, but mypy will use
‘lib.pyi’ instead.

If the package is stub-only (not imported at runtime), the package
should have a prefix of the runtime package name and a suffix of
‘-stubs’.  A ‘py.typed’ file is not needed for stub-only packages.  For
example, if we had stubs for ‘package_c’, we might do the following:

     setup.py
     package_c-stubs/
         __init__.pyi
         lib.pyi

The ‘setup.py’ might look like this:

     from distutils.core import setup

     setup(
         name="SuperPackageC",
         author="Me",
         version="0.1",
         package_data={"package_c-stubs": ["__init__.pyi", "lib.pyi"]},
         packages=["package_c-stubs"]
     )

The instructions above are enough to ensure that the built wheels
contain the appropriate files.  However, to ensure inclusion inside the
‘sdist’ (‘.tar.gz’ archive), you may also need to modify the inclusion
rules in your ‘MANIFEST.in’:

     global-include *.pyi
     global-include *.typed

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0561/

   (2) https://github.com/python/typeshed

   (3) https://setuptools.pypa.io/en/latest/index.html


File: Mypy.info,  Node: Extending and integrating mypy,  Next: Automatic stub generation stubgen,  Prev: Using installed packages,  Up: Contents

1.25 Extending and integrating mypy
===================================

* Menu:

* Integrating mypy into another Python application::
* Extending mypy using plugins::
* Configuring mypy to use plugins::
* High-level overview::
* Current list of plugin hooks::
* Notes about the semantic analyzer::


File: Mypy.info,  Node: Integrating mypy into another Python application,  Next: Extending mypy using plugins,  Up: Extending and integrating mypy

1.25.1 Integrating mypy into another Python application
-------------------------------------------------------

It is possible to integrate mypy into another Python 3 application by
importing ‘mypy.api’ and calling the ‘run’ function with a parameter of
type ‘list[str]’, containing what normally would have been the command
line arguments to mypy.

Function ‘run’ returns a ‘tuple[str, str, int]’, namely
‘(<normal_report>, <error_report>, <exit_status>)’, in which
‘<normal_report>’ is what mypy normally writes to sys.stdout(1),
‘<error_report>’ is what mypy normally writes to sys.stderr(2) and
‘exit_status’ is the exit status mypy normally returns to the operating
system.

A trivial example of using the api is the following

     import sys
     from mypy import api

     result = api.run(sys.argv[1:])

     if result[0]:
         print('\nType checking report:\n')
         print(result[0])  # stdout

     if result[1]:
         print('\nError report:\n')
         print(result[1])  # stderr

     print('\nExit status:', result[2])

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/sys.html#sys.stdout

   (2) https://docs.python.org/3/library/sys.html#sys.stderr


File: Mypy.info,  Node: Extending mypy using plugins,  Next: Configuring mypy to use plugins,  Prev: Integrating mypy into another Python application,  Up: Extending and integrating mypy

1.25.2 Extending mypy using plugins
-----------------------------------

Python is a highly dynamic language and has extensive metaprogramming
capabilities.  Many popular libraries use these to create APIs that may
be more flexible and/or natural for humans, but are hard to express
using static types.  Extending the PEP 484(1) type system to accommodate
all existing dynamic patterns is impractical and often just impossible.

Mypy supports a plugin system that lets you customize the way mypy type
checks code.  This can be useful if you want to extend mypy so it can
type check code that uses a library that is difficult to express using
just PEP 484(2) types.

The plugin system is focused on improving mypy’s understanding of
‘semantics’ of third party frameworks.  There is currently no way to
define new first class kinds of types.

     Note: The plugin system is experimental and prone to change.  If
     you want to write a mypy plugin, we recommend you start by
     contacting the mypy core developers on gitter(3).  In particular,
     there are no guarantees about backwards compatibility.

     Backwards incompatible changes may be made without a deprecation
     period, but we will announce them in the plugin API changes
     announcement issue(4).

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/

   (2) https://peps.python.org/pep-0484/

   (3) https://gitter.im/python/typing

   (4) https://github.com/python/mypy/issues/6617


File: Mypy.info,  Node: Configuring mypy to use plugins,  Next: High-level overview,  Prev: Extending mypy using plugins,  Up: Extending and integrating mypy

1.25.3 Configuring mypy to use plugins
--------------------------------------

Plugins are Python files that can be specified in a mypy *note config
file: 20. using the *note plugins: 1e9. option and one of the two
formats: relative or absolute path to the plugin file, or a module name
(if the plugin is installed using ‘pip install’ in the same virtual
environment where mypy is running).  The two formats can be mixed, for
example:

     [mypy]
     plugins = /one/plugin.py, other.plugin

Mypy will try to import the plugins and will look for an entry point
function named ‘plugin’.  If the plugin entry point function has a
different name, it can be specified after colon:

     [mypy]
     plugins = custom_plugin:custom_entry_point

In the following sections we describe the basics of the plugin system
with some examples.  For more technical details, please read the
docstrings in mypy/plugin.py(1) in mypy source code.  Also you can find
good examples in the bundled plugins located in mypy/plugins(2).

   ---------- Footnotes ----------

   (1) https://github.com/python/mypy/blob/master/mypy/plugin.py

   (2) https://github.com/python/mypy/tree/master/mypy/plugins


File: Mypy.info,  Node: High-level overview,  Next: Current list of plugin hooks,  Prev: Configuring mypy to use plugins,  Up: Extending and integrating mypy

1.25.4 High-level overview
--------------------------

Every entry point function should accept a single string argument that
is a full mypy version and return a subclass of ‘mypy.plugin.Plugin’:

     from mypy.plugin import Plugin

     class CustomPlugin(Plugin):
         def get_type_analyze_hook(self, fullname: str):
             # see explanation below
             ...

     def plugin(version: str):
         # ignore version argument if the plugin works with all mypy versions.
         return CustomPlugin

During different phases of analyzing the code (first in semantic
analysis, and then in type checking) mypy calls plugin methods such as
‘get_type_analyze_hook()’ on user plugins.  This particular method, for
example, can return a callback that mypy will use to analyze unbound
types with the given full name.  See the full plugin hook method list
*note below: 22f.

Mypy maintains a list of plugins it gets from the config file plus the
default (built-in) plugin that is always enabled.  Mypy calls a method
once for each plugin in the list until one of the methods returns a
non-‘None’ value.  This callback will be then used to customize the
corresponding aspect of analyzing/checking the current abstract syntax
tree node.

The callback returned by the ‘get_xxx’ method will be given a detailed
current context and an API to create new nodes, new types, emit error
messages, etc., and the result will be used for further processing.

Plugin developers should ensure that their plugins work well in
incremental and daemon modes.  In particular, plugins should not hold
global state due to caching of plugin hook results.


File: Mypy.info,  Node: Current list of plugin hooks,  Next: Notes about the semantic analyzer,  Prev: High-level overview,  Up: Extending and integrating mypy

1.25.5 Current list of plugin hooks
-----------------------------------

‘get_type_analyze_hook()’ customizes behaviour of the type analyzer.
For example, PEP 484(1) doesn’t support defining variadic generic types:

     from lib import Vector

     a: Vector[int, int]
     b: Vector[int, int, int]

When analyzing this code, mypy will call
‘get_type_analyze_hook("lib.Vector")’, so the plugin can return some
valid type for each variable.

‘get_function_hook()’ is used to adjust the return type of a function
call.  This is a good choice if the return type of some function depends
on ‘values’ of some arguments that can’t be expressed using literal
types (for example a function may return an ‘int’ for positive arguments
and a ‘float’ for negative arguments).  This hook will be also called
for instantiation of classes.  For example:

     from contextlib import contextmanager
     from typing import TypeVar, Callable

     T = TypeVar('T')

     @contextmanager  # built-in plugin can infer a precise type here
     def stopwatch(timer: Callable[[], T]) -> Iterator[T]:
         ...
         yield timer()

‘get_function_signature_hook’ is used to adjust the signature of a
function.

‘get_method_hook()’ is the same as ‘get_function_hook()’ but for methods
instead of module level functions.

‘get_method_signature_hook()’ is used to adjust the signature of a
method.  This includes special Python methods except __init__()(2) and
__new__()(3).  For example in this code:

     from ctypes import Array, c_int

     x: Array[c_int]
     x[0] = 42

mypy will call ‘get_method_signature_hook("ctypes.Array.__setitem__")’
so that the plugin can mimic the ctypes(4) auto-convert behavior.

‘get_attribute_hook()’ overrides instance member field lookups and
property access (not assignments, and not method calls).  This hook is
only called for fields which already exist on the class.  ‘Exception:’
if __getattr__(5) or __getattribute__(6) is a method on the class, the
hook is called for all fields which do not refer to methods.

‘get_class_attribute_hook()’ is similar to above, but for attributes on
classes rather than instances.  Unlike above, this does not have special
casing for __getattr__(7) or __getattribute__(8).

‘get_class_decorator_hook()’ can be used to update class definition for
given class decorators.  For example, you can add some attributes to the
class to match runtime behaviour:

     from dataclasses import dataclass

     @dataclass  # built-in plugin adds `__init__` method here
     class User:
         name: str

     user = User(name='example')  # mypy can understand this using a plugin

‘get_metaclass_hook()’ is similar to above, but for metaclasses.

‘get_base_class_hook()’ is similar to above, but for base classes.

‘get_dynamic_class_hook()’ can be used to allow dynamic class
definitions in mypy.  This plugin hook is called for every assignment to
a simple name where right hand side is a function call:

     from lib import dynamic_class

     X = dynamic_class('X', [])

For such definition, mypy will call
‘get_dynamic_class_hook("lib.dynamic_class")’.  The plugin should create
the corresponding ‘mypy.nodes.TypeInfo’ object, and place it into a
relevant symbol table.  (Instances of this class represent classes in
mypy and hold essential information such as qualified name, method
resolution order, etc.)

‘get_customize_class_mro_hook()’ can be used to modify class MRO (for
example insert some entries there) before the class body is analyzed.

‘get_additional_deps()’ can be used to add new dependencies for a
module.  It is called before semantic analysis.  For example, this can
be used if a library has dependencies that are dynamically loaded based
on configuration information.

‘report_config_data()’ can be used if the plugin has some sort of
per-module configuration that can affect typechecking.  In that case,
when the configuration for a module changes, we want to invalidate
mypy’s cache for that module so that it can be rechecked.  This hook
should be used to report to mypy any relevant configuration data, so
that mypy knows to recheck the module if the configuration changes.  The
hooks should return data encodable as JSON.

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/

   (2) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (3) https://docs.python.org/3/reference/datamodel.html#object.__new__

   (4) https://docs.python.org/3/library/ctypes.html#module-ctypes

   (5) 
https://docs.python.org/3/reference/datamodel.html#object.__getattr__

   (6) 
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__

   (7) 
https://docs.python.org/3/reference/datamodel.html#object.__getattr__

   (8) 
https://docs.python.org/3/reference/datamodel.html#object.__getattribute__


File: Mypy.info,  Node: Notes about the semantic analyzer,  Prev: Current list of plugin hooks,  Up: Extending and integrating mypy

1.25.6 Notes about the semantic analyzer
----------------------------------------

Mypy 0.710 introduced a new semantic analyzer, and the old semantic
analyzer was removed in mypy 0.730.  Support for the new semantic
analyzer required some changes to existing plugins.  Here is a short
summary of the most important changes:

   * The order of processing AST nodes is different.  Code outside
     functions is processed first, and functions and methods are
     processed afterwards.

   * Each AST node can be processed multiple times to resolve forward
     references.  The same plugin hook may be called multiple times, so
     they need to be idempotent.

   * The ‘anal_type()’ API method returns ‘None’ if some part of the
     type is not available yet due to forward references, for example.

   * When looking up symbols, you may encounter ‘placeholder nodes’ that
     are used for names that haven’t been fully processed yet.  You’ll
     generally want to request another semantic analysis iteration by
     ‘deferring’ in that case.

See the docstring at the top of mypy/plugin.py(1) for more details.

   ---------- Footnotes ----------

   (1) https://github.com/python/mypy/blob/master/mypy/plugin.py


File: Mypy.info,  Node: Automatic stub generation stubgen,  Next: Automatic stub testing stubtest,  Prev: Extending and integrating mypy,  Up: Contents

1.26 Automatic stub generation (stubgen)
========================================

A stub file (see PEP 484(1)) contains only type hints for the public
interface of a module, with empty function bodies.  Mypy can use a stub
file instead of the real implementation to provide type information for
the module.  They are useful for third-party modules whose authors have
not yet added type hints (and when no stubs are available in typeshed)
and C extension modules (which mypy can’t directly process).

Mypy includes the ‘stubgen’ tool that can automatically generate stub
files (‘.pyi’ files) for Python modules and C extension modules.  For
example, consider this source file:

     from other_module import dynamic

     BORDER_WIDTH = 15

     class Window:
         parent = dynamic()
         def __init__(self, width, height):
             self.width = width
             self.height = height

     def create_empty() -> Window:
         return Window(0, 0)

Stubgen can generate this stub file based on the above file:

     from typing import Any

     BORDER_WIDTH: int = ...

     class Window:
         parent: Any = ...
         width: Any = ...
         height: Any = ...
         def __init__(self, width, height) -> None: ...

     def create_empty() -> Window: ...

Stubgen generates ‘draft’ stubs.  The auto-generated stub files often
require some manual updates, and most types will default to ‘Any’.  The
stubs will be much more useful if you add more precise type annotations,
at least for the most commonly used functionality.

The rest of this section documents the command line interface of
stubgen.  Run *note stubgen –help: 234. for a quick summary of options.

     Note: The command-line flags may change between releases.

* Menu:

* Specifying what to stub::
* Specifying how to generate stubs::
* Additional flags::

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0484/


File: Mypy.info,  Node: Specifying what to stub,  Next: Specifying how to generate stubs,  Up: Automatic stub generation stubgen

1.26.1 Specifying what to stub
------------------------------

You can give stubgen paths of the source files for which you want to
generate stubs:

     $ stubgen foo.py bar.py

This generates stubs ‘out/foo.pyi’ and ‘out/bar.pyi’.  The default
output directory ‘out’ can be overridden with *note -o DIR: 236.

You can also pass directories, and stubgen will recursively search them
for any ‘.py’ files and generate stubs for all of them:

     $ stubgen my_pkg_dir

Alternatively, you can give module or package names using the *note -m:
237. or *note -p: 238. options:

     $ stubgen -m foo -m bar -p my_pkg_dir

Details of the options:

 -- Option: -m MODULE, --module MODULE

     Generate a stub file for the given module.  This flag may be
     repeated multiple times.

     Stubgen ‘will not’ recursively generate stubs for any submodules of
     the provided module.

 -- Option: -p PACKAGE, --package PACKAGE

     Generate stubs for the given package.  This flag maybe repeated
     multiple times.

     Stubgen ‘will’ recursively generate stubs for all submodules of the
     provided package.  This flag is identical to *note –module: 237.
     apart from this behavior.

     Note: You can’t mix paths and *note -m: 237./*note -p: 238. options
     in the same stubgen invocation.

Stubgen applies heuristics to avoid generating stubs for submodules that
include tests or vendored third-party packages.


File: Mypy.info,  Node: Specifying how to generate stubs,  Next: Additional flags,  Prev: Specifying what to stub,  Up: Automatic stub generation stubgen

1.26.2 Specifying how to generate stubs
---------------------------------------

By default stubgen will try to import the target modules and packages.
This allows stubgen to use runtime introspection to generate stubs for C
extension modules and to improve the quality of the generated stubs.  By
default, stubgen will also use mypy to perform light-weight semantic
analysis of any Python modules.  Use the following flags to alter the
default behavior:

 -- Option: --no-import

     Don’t try to import modules.  Instead only use mypy’s normal search
     mechanism to find sources.  This does not support C extension
     modules.  This flag also disables runtime introspection
     functionality, which mypy uses to find the value of ‘__all__’.  As
     result the set of exported imported names in stubs may be
     incomplete.  This flag is generally only useful when importing a
     module causes unwanted side effects, such as the running of tests.
     Stubgen tries to skip test modules even without this option, but
     this does not always work.

 -- Option: --parse-only

     Don’t perform semantic analysis of source files.  This may generate
     worse stubs – in particular, some module, class, and function
     aliases may be represented as variables with the ‘Any’ type.  This
     is generally only useful if semantic analysis causes a critical
     mypy error.

 -- Option: --doc-dir PATH

     Try to infer better signatures by parsing .rst documentation in
     ‘PATH’.  This may result in better stubs, but currently it only
     works for C extension modules.


File: Mypy.info,  Node: Additional flags,  Prev: Specifying how to generate stubs,  Up: Automatic stub generation stubgen

1.26.3 Additional flags
-----------------------

 -- Option: -h, --help

     Show help message and exit.

 -- Option: --ignore-errors

     If an exception was raised during stub generation, continue to
     process any remaining modules instead of immediately failing with
     an error.

 -- Option: --include-private

     Include definitions that are considered private in stubs (with
     names such as ‘_foo’ with single leading underscore and no trailing
     underscores).

 -- Option: --export-less

     Don’t export all names imported from other modules within the same
     package.  Instead, only export imported names that are not
     referenced in the module that contains the import.

 -- Option: --search-path PATH

     Specify module search directories, separated by colons (only used
     if *note –no-import: 23c. is given).

 -- Option: -o PATH, --output PATH

     Change the output directory.  By default the stubs are written in
     the ‘./out’ directory.  The output directory will be created if it
     doesn’t exist.  Existing stubs in the output directory will be
     overwritten without warning.

 -- Option: -v, --verbose

     Produce more verbose output.

 -- Option: -q, --quiet

     Produce less verbose output.


File: Mypy.info,  Node: Automatic stub testing stubtest,  Next: Common issues and solutions,  Prev: Automatic stub generation stubgen,  Up: Contents

1.27 Automatic stub testing (stubtest)
======================================

Stub files are files containing type annotations.  See PEP 484(1) for
more motivation and details.

A common problem with stub files is that they tend to diverge from the
actual implementation.  Mypy includes the ‘stubtest’ tool that can
automatically check for discrepancies between the stubs and the
implementation at runtime.

* Menu:

* What stubtest does and does not do::
* Example::
* Usage::

   ---------- Footnotes ----------

   (1) https://www.python.org/dev/peps/pep-0484/#stub-files


File: Mypy.info,  Node: What stubtest does and does not do,  Next: Example,  Up: Automatic stub testing stubtest

1.27.1 What stubtest does and does not do
-----------------------------------------

Stubtest will import your code and introspect your code objects at
runtime, for example, by using the capabilities of the inspect(1)
module.  Stubtest will then analyse the stub files, and compare the two,
pointing out things that differ between stubs and the implementation at
runtime.

It’s important to be aware of the limitations of this comparison.
Stubtest will not make any attempt to statically analyse your actual
code and relies only on dynamic runtime introspection (in particular,
this approach means stubtest works well with extension modules).
However, this means that stubtest has limited visibility; for instance,
it cannot tell if a return type of a function is accurately typed in the
stubs.

For clarity, here are some additional things stubtest can’t do:

   * Type check your code – use ‘mypy’ instead

   * Generate stubs – use ‘stubgen’ or ‘pyright --createstub’ instead

   * Generate stubs based on running your application or test suite –
     use ‘monkeytype’ instead

   * Apply stubs to code to produce inline types – use ‘retype’ or
     ‘libcst’ instead

In summary, stubtest works very well for ensuring basic consistency
between stubs and implementation or to check for stub completeness.
It’s used to test Python’s official collection of library stubs,
typeshed(2).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/inspect.html#module-inspect

   (2) https://github.com/python/typeshed


File: Mypy.info,  Node: Example,  Next: Usage,  Prev: What stubtest does and does not do,  Up: Automatic stub testing stubtest

1.27.2 Example
--------------

Here’s a quick example of what stubtest can do:

     $ python3 -m pip install mypy

     $ cat library.py
     x = "hello, stubtest"

     def foo(x=None):
         print(x)

     $ cat library.pyi
     x: int

     def foo(x: int) -> None: ...

     $ python3 -m mypy.stubtest library
     error: library.foo is inconsistent, runtime argument "x" has a default value but stub argument does not
     Stub: at line 3
     def (x: builtins.int)
     Runtime: at line 3 in file ~/library.py
     def (x=None)

     error: library.x variable differs from runtime type Literal['hello, stubtest']
     Stub: at line 1
     builtins.int
     Runtime:
     'hello, stubtest'


File: Mypy.info,  Node: Usage,  Prev: Example,  Up: Automatic stub testing stubtest

1.27.3 Usage
------------

Running stubtest can be as simple as ‘stubtest module_to_check’.  Run
*note stubtest –help: 24f. for a quick summary of options.

Subtest must be able to import the code to be checked, so make sure that
mypy is installed in the same environment as the library to be tested.
In some cases, setting ‘PYTHONPATH’ can help stubtest find the code to
import.

Similarly, stubtest must be able to find the stubs to be checked.
Stubtest respects the ‘MYPYPATH’ environment variable – consider using
this if you receive a complaint along the lines of “failed to find
stubs”.

Note that stubtest requires mypy to be able to analyse stubs.  If mypy
is unable to analyse stubs, you may get an error on the lines of “not
checking stubs due to mypy build errors”.  In this case, you will need
to mitigate those errors before stubtest will run.  Despite potential
overlap in errors here, stubtest is not intended as a substitute for
running mypy directly.

If you wish to ignore some of stubtest’s complaints, stubtest supports a
pretty handy allowlist system.

The rest of this section documents the command line interface of
stubtest.

 -- Option: --concise

     Makes stubtest’s output more concise, one line per error

 -- Option: --ignore-missing-stub

     Ignore errors for stub missing things that are present at runtime

 -- Option: --ignore-positional-only

     Ignore errors for whether an argument should or shouldn’t be
     positional-only

 -- Option: --allowlist FILE

     Use file as an allowlist.  Can be passed multiple times to combine
     multiple allowlists.  Allowlists can be created with
     –generate-allowlist.  Allowlists support regular expressions.

 -- Option: --generate-allowlist

     Print an allowlist (to stdout) to be used with –allowlist

 -- Option: --ignore-unused-allowlist

     Ignore unused allowlist entries

 -- Option: --mypy-config-file FILE

     Use specified mypy config file to determine mypy plugins and mypy
     path

 -- Option: --custom-typeshed-dir DIR

     Use the custom typeshed in DIR

 -- Option: --check-typeshed

     Check all stdlib modules in typeshed

 -- Option: --help

     Show a help message :-)


File: Mypy.info,  Node: Common issues and solutions,  Next: Supported Python features,  Prev: Automatic stub testing stubtest,  Up: Contents

1.28 Common issues and solutions
================================

This section has examples of cases when you need to update your code to
use static typing, and ideas for working around issues if mypy doesn’t
work as expected.  Statically typed code is often identical to normal
Python code (except for type annotations), but sometimes you need to do
things slightly differently.

* Menu:

* Can’t install mypy using pip::
* No errors reported for obviously wrong code::
* Spurious errors and locally silencing the checker::
* Ignoring a whole file::
* Issues with code at runtime::
* Mypy runs are slow::
* Types of empty collections::
* Redefinitions with incompatible types::
* Invariance vs covariance::
* Declaring a supertype as variable type::
* Complex type tests::
* Python version and system platform checks::
* Displaying the type of an expression::
* Silencing linters::
* Covariant subtyping of mutable protocol members is rejected::
* Dealing with conflicting names::
* Using a development mypy build::
* Variables vs type aliases::
* Incompatible overrides::
* Unreachable code::
* Narrowing and inner functions::


File: Mypy.info,  Node: Can’t install mypy using pip,  Next: No errors reported for obviously wrong code,  Up: Common issues and solutions

1.28.1 Can’t install mypy using pip
-----------------------------------

If installation fails, you’ve probably hit one of these issues:

   * Mypy needs Python 3.6 or later to run.

   * You may have to run pip like this: ‘python3 -m pip install mypy’.


File: Mypy.info,  Node: No errors reported for obviously wrong code,  Next: Spurious errors and locally silencing the checker,  Prev: Can’t install mypy using pip,  Up: Common issues and solutions

1.28.2 No errors reported for obviously wrong code
--------------------------------------------------

There are several common reasons why obviously wrong code is not flagged
as an error.

‘The function containing the error is not annotated.’ Functions that do
not have any annotations (neither for any argument nor for the return
type) are not type-checked, and even the most blatant type errors (e.g.
‘2 + 'a'’) pass silently.  The solution is to add annotations.  Where
that isn’t possible, functions without annotations can be checked using
*note –check-untyped-defs: ea.

Example:

     def foo(a):
         return '(' + a.split() + ')'  # No error!

This gives no error even though ‘a.split()’ is “obviously” a list (the
author probably meant ‘a.strip()’).  The error is reported once you add
annotations:

     def foo(a: str) -> str:
         return '(' + a.split() + ')'
     # error: Unsupported operand types for + ("str" and List[str])

If you don’t know what types to add, you can use ‘Any’, but beware:

‘One of the values involved has type ‘Any’.’ Extending the above
example, if we were to leave out the annotation for ‘a’, we’d get no
error:

     def foo(a) -> str:
         return '(' + a.split() + ')'  # No error!

The reason is that if the type of ‘a’ is unknown, the type of
‘a.split()’ is also unknown, so it is inferred as having type ‘Any’, and
it is no error to add a string to an ‘Any’.

If you’re having trouble debugging such situations, *note reveal_type():
f6. might come in handy.

Note that sometimes library stubs have imprecise type information, e.g.
the pow()(1) builtin returns ‘Any’ (see typeshed issue 285(2) for the
reason).

__init__(3) ‘method has no annotated arguments or return type
annotation.’ __init__(4) is considered fully-annotated ‘if at least one
argument is annotated’, while mypy will infer the return type as ‘None’.
The implication is that, for a __init__(5) method that has no argument,
you’ll have to explicitly annotate the return type as ‘None’ to
type-check this __init__(6) method:

     def foo(s: str) -> str:
         return s

     class A():
         def __init__(self, value: str): # Return type inferred as None, considered as typed method
             self.value = value
             foo(1) # error: Argument 1 to "foo" has incompatible type "int"; expected "str"

     class B():
         def __init__(self):  # No argument is annotated, considered as untyped method
             foo(1)  # No error!

     class C():
         def __init__(self) -> None:  # Must specify return type to type-check
             foo(1) # error: Argument 1 to "foo" has incompatible type "int"; expected "str"

‘Some imports may be silently ignored’.  Another source of unexpected
‘Any’ values are the *note –ignore-missing-imports: 133. and *note
–follow-imports=skip: 13c. flags.  When you use *note
–ignore-missing-imports: 133, any imported module that cannot be found
is silently replaced with ‘Any’.  When using *note –follow-imports=skip:
13c. the same is true for modules for which a ‘.py’ file is found but
that are not specified on the command line.  (If a ‘.pyi’ stub is found
it is always processed normally, regardless of the value of *note
–follow-imports: 13c.)  To help debug the former situation (no module
found at all) leave out *note –ignore-missing-imports: 133.; to get
clarity about the latter use *note –follow-imports=error: 13c.  You can
read up about these and other useful flags in *note The mypy command
line: a.

‘A function annotated as returning a non-optional type returns ‘None’
and mypy doesn’t complain’.

     def foo() -> str:
         return None  # No error!

You may have disabled strict optional checking (see *note Disabling
strict optional checking: 66. for more).

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#pow

   (2) https://github.com/python/typeshed/issues/285

   (3) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (4) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (5) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (6) 
https://docs.python.org/3/reference/datamodel.html#object.__init__


File: Mypy.info,  Node: Spurious errors and locally silencing the checker,  Next: Ignoring a whole file,  Prev: No errors reported for obviously wrong code,  Up: Common issues and solutions

1.28.3 Spurious errors and locally silencing the checker
--------------------------------------------------------

You can use a ‘# type: ignore’ comment to silence the type checker on a
particular line.  For example, let’s say our code is using the C
extension module ‘frobnicate’, and there’s no stub available.  Mypy will
complain about this, as it has no information about the module:

     import frobnicate  # Error: No module "frobnicate"
     frobnicate.start()

You can add a ‘# type: ignore’ comment to tell mypy to ignore this
error:

     import frobnicate  # type: ignore
     frobnicate.start()  # Okay!

The second line is now fine, since the ignore comment causes the name
‘frobnicate’ to get an implicit ‘Any’ type.

     Note: You can use the form ‘# type: ignore[<code>]’ to only ignore
     specific errors on the line.  This way you are less likely to
     silence unexpected errors that are not safe to ignore, and this
     will also document what the purpose of the comment is.  See *note
     Error codes: 176. for more information.

     Note: The ‘# type: ignore’ comment will only assign the implicit
     ‘Any’ type if mypy cannot find information about that particular
     module.  So, if we did have a stub available for ‘frobnicate’ then
     mypy would ignore the ‘# type: ignore’ comment and typecheck the
     stub as usual.

Another option is to explicitly annotate values with type ‘Any’ – mypy
will let you perform arbitrary operations on ‘Any’ values.  Sometimes
there is no more precise type you can use for a particular value,
especially if you use dynamic Python features such as __getattr__(1):

     class Wrapper:
         ...
         def __getattr__(self, a: str) -> Any:
             return getattr(self._wrapped, a)

Finally, you can create a stub file (‘.pyi’) for a file that generates
spurious errors.  Mypy will only look at the stub file and ignore the
implementation, since stub files take precedence over ‘.py’ files.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__getattr__


File: Mypy.info,  Node: Ignoring a whole file,  Next: Issues with code at runtime,  Prev: Spurious errors and locally silencing the checker,  Up: Common issues and solutions

1.28.4 Ignoring a whole file
----------------------------

A ‘# type: ignore’ comment at the top of a module (before any
statements, including imports or docstrings) has the effect of ignoring
the entire contents of the module.

To only ignore errors, use a top-level ‘# mypy: ignore-errors’ comment
instead.  To only ignore errors with a specific error code, use a
top-level ‘# mypy: disable-error-code=...’ comment.  To replace the
contents of the module with ‘Any’, use a per-module ‘follow_imports =
skip’.  See *note Following imports: 26. for details.

     # type: ignore

     import foo

     foo.bar()


File: Mypy.info,  Node: Issues with code at runtime,  Next: Mypy runs are slow,  Prev: Ignoring a whole file,  Up: Common issues and solutions

1.28.5 Issues with code at runtime
----------------------------------

Idiomatic use of type annotations can sometimes run up against what a
given version of Python considers legal code.  These can result in some
of the following errors when trying to run your code:

   * ‘ImportError’ from circular imports

   * ‘NameError: name "X" is not defined’ from forward references

   * ‘TypeError: 'type' object is not subscriptable’ from types that are
     not generic at runtime

   * ‘ImportError’ or ‘ModuleNotFoundError’ from use of stub definitions
     not available at runtime

   * ‘TypeError: unsupported operand type(s) for |: 'type' and 'type'’
     from use of new syntax

For dealing with these, see *note Annotation issues at runtime: 38.


File: Mypy.info,  Node: Mypy runs are slow,  Next: Types of empty collections,  Prev: Issues with code at runtime,  Up: Common issues and solutions

1.28.6 Mypy runs are slow
-------------------------

If your mypy runs feel slow, you should probably use the *note mypy
daemon: 2e, which can speed up incremental mypy runtimes by a factor of
10 or more.  *note Remote caching: 2f. can make cold mypy runs several
times faster.


File: Mypy.info,  Node: Types of empty collections,  Next: Redefinitions with incompatible types,  Prev: Mypy runs are slow,  Up: Common issues and solutions

1.28.7 Types of empty collections
---------------------------------

You often need to specify the type when you assign an empty list or dict
to a new variable, as mentioned earlier:

     a: List[int] = []

Without the annotation mypy can’t always figure out the precise type of
‘a’.

You can use a simple empty list literal in a dynamically typed function
(as the type of ‘a’ would be implicitly ‘Any’ and need not be inferred),
if type of the variable has been declared or inferred before, or if you
perform a simple modification operation in the same scope (such as
‘append’ for a list):

     a = []  # Okay because followed by append, inferred type List[int]
     for i in range(n):
         a.append(i * i)

However, in more complex cases an explicit type annotation can be
required (mypy will tell you this).  Often the annotation can make your
code easier to understand, so it doesn’t only help mypy but everybody
who is reading the code!


File: Mypy.info,  Node: Redefinitions with incompatible types,  Next: Invariance vs covariance,  Prev: Types of empty collections,  Up: Common issues and solutions

1.28.8 Redefinitions with incompatible types
--------------------------------------------

Each name within a function only has a single ‘declared’ type.  You can
reuse for loop indices etc., but if you want to use a variable with
multiple types within a single function, you may need to declare it with
the ‘Any’ type.

     def f() -> None:
         n = 1
         ...
         n = 'x'        # Type error: n has type int

     Note: This limitation could be lifted in a future mypy release.

Note that you can redefine a variable with a more ‘precise’ or a more
concrete type.  For example, you can redefine a sequence (which does not
support ‘sort()’) as a list and sort it in-place:

     def f(x: Sequence[int]) -> None:
         # Type of x is Sequence[int] here; we don't know the concrete type.
         x = list(x)
         # Type of x is List[int] here.
         x.sort()  # Okay!


File: Mypy.info,  Node: Invariance vs covariance,  Next: Declaring a supertype as variable type,  Prev: Redefinitions with incompatible types,  Up: Common issues and solutions

1.28.9 Invariance vs covariance
-------------------------------

Most mutable generic collections are invariant, and mypy considers all
user-defined generic classes invariant by default (see *note Variance of
generic types: d6. for motivation).  This could lead to some unexpected
errors when combined with type inference.  For example:

     class A: ...
     class B(A): ...

     lst = [A(), A()]  # Inferred type is List[A]
     new_lst = [B(), B()]  # inferred type is List[B]
     lst = new_lst  # mypy will complain about this, because List is invariant

Possible strategies in such situations are:

   * Use an explicit type annotation:

          new_lst: List[A] = [B(), B()]
          lst = new_lst  # OK

   * Make a copy of the right hand side:

          lst = list(new_lst) # Also OK

   * Use immutable collections as annotations whenever possible:

          def f_bad(x: List[A]) -> A:
              return x[0]
          f_bad(new_lst) # Fails

          def f_good(x: Sequence[A]) -> A:
              return x[0]
          f_good(new_lst) # OK


File: Mypy.info,  Node: Declaring a supertype as variable type,  Next: Complex type tests,  Prev: Invariance vs covariance,  Up: Common issues and solutions

1.28.10 Declaring a supertype as variable type
----------------------------------------------

Sometimes the inferred type is a subtype (subclass) of the desired type.
The type inference uses the first assignment to infer the type of a name
(assume here that ‘Shape’ is the base class of both ‘Circle’ and
‘Triangle’):

     shape = Circle()    # Infer shape to be Circle
     ...
     shape = Triangle()  # Type error: Triangle is not a Circle

You can just give an explicit type for the variable in cases such the
above example:

     shape = Circle() # type: Shape   # The variable s can be any Shape,
                                      # not just Circle
     ...
     shape = Triangle()               # OK


File: Mypy.info,  Node: Complex type tests,  Next: Python version and system platform checks,  Prev: Declaring a supertype as variable type,  Up: Common issues and solutions

1.28.11 Complex type tests
--------------------------

Mypy can usually infer the types correctly when using isinstance(1),
issubclass(2), or ‘type(obj) is some_class’ type tests, and even *note
user-defined type guards: bb, but for other kinds of checks you may need
to add an explicit type cast:

     from typing import Sequence, cast

     def find_first_str(a: Sequence[object]) -> str:
         index = next((i for i, s in enumerate(a) if isinstance(s, str)), -1)
         if index < 0:
             raise ValueError('No str found')

         found = a[index]  # Has type "object", despite the fact that we know it is "str"
         return cast(str, found)  # We need an explicit cast to make mypy happy

Alternatively, you can use an ‘assert’ statement together with some of
the supported type inference techniques:

     def find_first_str(a: Sequence[object]) -> str:
         index = next((i for i, s in enumerate(a) if isinstance(s, str)), -1)
         if index < 0:
             raise ValueError('No str found')

         found = a[index]  # Has type "object", despite the fact that we know it is "str"
         assert isinstance(found, str)  # Now, "found" will be narrowed to "str"
         return found  # No need for the explicit "cast()" anymore

     Note: Note that the object(3) type used in the above example is
     similar to ‘Object’ in Java: it only supports operations defined
     for ‘all’ objects, such as equality and isinstance()(4).  The type
     ‘Any’, in contrast, supports all operations, even if they may fail
     at runtime.  The cast above would have been unnecessary if the type
     of ‘o’ was ‘Any’.

     Note: You can read more about type narrowing techniques *note here:
     82.

Type inference in Mypy is designed to work well in common cases, to be
predictable and to let the type checker give useful error messages.
More powerful type inference strategies often have complex and
difficult-to-predict failure modes and could result in very confusing
error messages.  The tradeoff is that you as a programmer sometimes have
to give the type checker a little help.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#isinstance

   (2) https://docs.python.org/3/library/functions.html#issubclass

   (3) https://docs.python.org/3/library/functions.html#object

   (4) https://docs.python.org/3/library/functions.html#isinstance


File: Mypy.info,  Node: Python version and system platform checks,  Next: Displaying the type of an expression,  Prev: Complex type tests,  Up: Common issues and solutions

1.28.12 Python version and system platform checks
-------------------------------------------------

Mypy supports the ability to perform Python version checks and platform
checks (e.g.  Windows vs Posix), ignoring code paths that won’t be run
on the targeted Python version or platform.  This allows you to more
effectively typecheck code that supports multiple versions of Python or
multiple operating systems.

More specifically, mypy will understand the use of sys.version_info(1)
and sys.platform(2) checks within ‘if/elif/else’ statements.  For
example:

     import sys

     # Distinguishing between different versions of Python:
     if sys.version_info >= (3, 8):
         # Python 3.8+ specific definitions and imports
     else:
         # Other definitions and imports

     # Distinguishing between different operating systems:
     if sys.platform.startswith("linux"):
         # Linux-specific code
     elif sys.platform == "darwin":
         # Mac-specific code
     elif sys.platform == "win32":
         # Windows-specific code
     else:
         # Other systems

As a special case, you can also use one of these checks in a top-level
(unindented) ‘assert’; this makes mypy skip the rest of the file.
Example:

     import sys

     assert sys.platform != 'win32'

     # The rest of this file doesn't apply to Windows.

Some other expressions exhibit similar behavior; in particular,
TYPE_CHECKING(3), variables named ‘MYPY’, and any variable whose name is
passed to *note –always-true: ee. or *note –always-false: ef.  (However,
‘True’ and ‘False’ are not treated specially!)

     Note: Mypy currently does not support more complex checks, and does
     not assign any special meaning when assigning a sys.version_info(4)
     or sys.platform(5) check to a variable.  This may change in future
     versions of mypy.

By default, mypy will use your current version of Python and your
current operating system as default values for sys.version_info(6) and
sys.platform(7).

To target a different Python version, use the *note –python-version X.Y:
f0. flag.  For example, to verify your code typechecks if were run using
Python 3.8, pass in *note –python-version 3.8: f0. from the command
line.  Note that you do not need to have Python 3.8 installed to perform
this check.

To target a different operating system, use the *note –platform
PLATFORM: 156. flag.  For example, to verify your code typechecks if it
were run in Windows, pass in *note –platform win32: 156.  See the
documentation for sys.platform(8) for examples of valid platform
parameters.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/sys.html#sys.version_info

   (2) https://docs.python.org/3/library/sys.html#sys.platform

   (3) 
https://docs.python.org/3/library/typing.html#typing.TYPE_CHECKING

   (4) https://docs.python.org/3/library/sys.html#sys.version_info

   (5) https://docs.python.org/3/library/sys.html#sys.platform

   (6) https://docs.python.org/3/library/sys.html#sys.version_info

   (7) https://docs.python.org/3/library/sys.html#sys.platform

   (8) https://docs.python.org/3/library/sys.html#sys.platform


File: Mypy.info,  Node: Displaying the type of an expression,  Next: Silencing linters,  Prev: Python version and system platform checks,  Up: Common issues and solutions

1.28.13 Displaying the type of an expression
--------------------------------------------

You can use ‘reveal_type(expr)’ to ask mypy to display the inferred
static type of an expression.  This can be useful when you don’t quite
understand how mypy handles a particular piece of code.  Example:

     reveal_type((1, 'hello'))  # Revealed type is "Tuple[builtins.int, builtins.str]"

You can also use ‘reveal_locals()’ at any line in a file to see the
types of all local variables at once.  Example:

     a = 1
     b = 'one'
     reveal_locals()
     # Revealed local types are:
     #     a: builtins.int
     #     b: builtins.str

     Note: ‘reveal_type’ and ‘reveal_locals’ are only understood by mypy
     and don’t exist in Python.  If you try to run your program, you’ll
     have to remove any ‘reveal_type’ and ‘reveal_locals’ calls before
     you can run your code.  Both are always available and you don’t
     need to import them.


File: Mypy.info,  Node: Silencing linters,  Next: Covariant subtyping of mutable protocol members is rejected,  Prev: Displaying the type of an expression,  Up: Common issues and solutions

1.28.14 Silencing linters
-------------------------

In some cases, linters will complain about unused imports or code.  In
these cases, you can silence them with a comment after type comments, or
on the same line as the import:

     # to silence complaints about unused imports
     from typing import List  # noqa
     a = None  # type: List[int]

To silence the linter on the same line as a type comment put the linter
comment ‘after’ the type comment:

     a = some_complex_thing()  # type: ignore  # noqa


File: Mypy.info,  Node: Covariant subtyping of mutable protocol members is rejected,  Next: Dealing with conflicting names,  Prev: Silencing linters,  Up: Common issues and solutions

1.28.15 Covariant subtyping of mutable protocol members is rejected
-------------------------------------------------------------------

Mypy rejects this because this is potentially unsafe.  Consider this
example:

     from typing_extensions import Protocol

     class P(Protocol):
         x: float

     def fun(arg: P) -> None:
         arg.x = 3.14

     class C:
         x = 42
     c = C()
     fun(c)  # This is not safe
     c.x << 5  # Since this will fail!

To work around this problem consider whether “mutating” is actually part
of a protocol.  If not, then one can use a @property(1) in the protocol
definition:

     from typing_extensions import Protocol

     class P(Protocol):
         @property
         def x(self) -> float:
            pass

     def fun(arg: P) -> None:
         ...

     class C:
         x = 42
     fun(C())  # OK

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#property


File: Mypy.info,  Node: Dealing with conflicting names,  Next: Using a development mypy build,  Prev: Covariant subtyping of mutable protocol members is rejected,  Up: Common issues and solutions

1.28.16 Dealing with conflicting names
--------------------------------------

Suppose you have a class with a method whose name is the same as an
imported (or built-in) type, and you want to use the type in another
method signature.  E.g.:

     class Message:
         def bytes(self):
             ...
         def register(self, path: bytes):  # error: Invalid type "mod.Message.bytes"
             ...

The third line elicits an error because mypy sees the argument type
‘bytes’ as a reference to the method by that name.  Other than renaming
the method, a workaround is to use an alias:

     bytes_ = bytes
     class Message:
         def bytes(self):
             ...
         def register(self, path: bytes_):
             ...


File: Mypy.info,  Node: Using a development mypy build,  Next: Variables vs type aliases,  Prev: Dealing with conflicting names,  Up: Common issues and solutions

1.28.17 Using a development mypy build
--------------------------------------

You can install the latest development version of mypy from source.
Clone the mypy repository on GitHub(1), and then run ‘pip install’
locally:

     git clone https://github.com/python/mypy.git
     cd mypy
     sudo python3 -m pip install --upgrade .

   ---------- Footnotes ----------

   (1) https://github.com/python/mypy


File: Mypy.info,  Node: Variables vs type aliases,  Next: Incompatible overrides,  Prev: Using a development mypy build,  Up: Common issues and solutions

1.28.18 Variables vs type aliases
---------------------------------

Mypy has both ‘type aliases’ and variables with types like ‘Type[...]’.
These are subtly different, and it’s important to understand how they
differ to avoid pitfalls.

  1. A variable with type ‘Type[...]’ is defined using an assignment
     with an explicit type annotation:

          class A: ...
          tp: Type[A] = A

  2. You can define a type alias using an assignment without an explicit
     type annotation at the top level of a module:

          class A: ...
          Alias = A

     You can also use ‘TypeAlias’ ( PEP 613(1)) to define an ‘explicit
     type alias’:

          from typing import TypeAlias  # "from typing_extensions" in Python 3.9 and earlier

          class A: ...
          Alias: TypeAlias = A

     You should always use ‘TypeAlias’ to define a type alias in a class
     body or inside a function.

The main difference is that the target of an alias is precisely known
statically, and this means that they can be used in type annotations and
other ‘type contexts’.  Type aliases can’t be defined conditionally
(unless using *note supported Python version and platform checks: ed.):

          class A: ...
          class B: ...

          if random() > 0.5:
              Alias = A
          else:
              # error: Cannot assign multiple types to name "Alias" without an
              # explicit "Type[...]" annotation
              Alias = B

          tp: Type[object]  # "tp" is a variable with a type object value
          if random() > 0.5:
              tp = A
          else:
              tp = B  # This is OK

          def fun1(x: Alias) -> None: ...  # OK
          def fun2(x: tp) -> None: ...  # Error: "tp" is not valid as a type

   ---------- Footnotes ----------

   (1) https://peps.python.org/pep-0613/


File: Mypy.info,  Node: Incompatible overrides,  Next: Unreachable code,  Prev: Variables vs type aliases,  Up: Common issues and solutions

1.28.19 Incompatible overrides
------------------------------

It’s unsafe to override a method with a more specific argument type, as
it violates the Liskov substitution principle(1).  For return types,
it’s unsafe to override a method with a more general return type.

Other incompatible signature changes in method overrides, such as adding
an extra required parameter, or removing an optional parameter, will
also generate errors.  The signature of a method in a subclass should
accept all valid calls to the base class method.  Mypy treats a subclass
as a subtype of the base class.  An instance of a subclass is valid
everywhere where an instance of the base class is valid.

This example demonstrates both safe and unsafe overrides:

     from typing import Sequence, List, Iterable

     class A:
         def test(self, t: Sequence[int]) -> Sequence[str]:
             ...

     class GeneralizedArgument(A):
         # A more general argument type is okay
         def test(self, t: Iterable[int]) -> Sequence[str]:  # OK
             ...

     class NarrowerArgument(A):
         # A more specific argument type isn't accepted
         def test(self, t: List[int]) -> Sequence[str]:  # Error
             ...

     class NarrowerReturn(A):
         # A more specific return type is fine
         def test(self, t: Sequence[int]) -> List[str]:  # OK
             ...

     class GeneralizedReturn(A):
         # A more general return type is an error
         def test(self, t: Sequence[int]) -> Iterable[str]:  # Error
             ...

You can use ‘# type: ignore[override]’ to silence the error.  Add it to
the line that generates the error, if you decide that type safety is not
necessary:

     class NarrowerArgument(A):
         def test(self, t: List[int]) -> Sequence[str]:  # type: ignore[override]
             ...

   ---------- Footnotes ----------

   (1) 
https://stackoverflow.com/questions/56860/what-is-an-example-of-the-liskov-substitution-principle


File: Mypy.info,  Node: Unreachable code,  Next: Narrowing and inner functions,  Prev: Incompatible overrides,  Up: Common issues and solutions

1.28.20 Unreachable code
------------------------

Mypy may consider some code as ‘unreachable’, even if it might not be
immediately obvious why.  It’s important to note that mypy will ‘not’
type check such code.  Consider this example:

     class Foo:
         bar: str = ''

     def bar() -> None:
         foo: Foo = Foo()
         return
         x: int = 'abc'  # Unreachable -- no error

It’s easy to see that any statement after ‘return’ is unreachable, and
hence mypy will not complain about the mis-typed code below it.  For a
more subtle example, consider this code:

     class Foo:
         bar: str = ''

     def bar() -> None:
         foo: Foo = Foo()
         assert foo.bar is None
         x: int = 'abc'  # Unreachable -- no error

Again, mypy will not report any errors.  The type of ‘foo.bar’ is ‘str’,
and mypy reasons that it can never be ‘None’.  Hence the ‘assert’
statement will always fail and the statement below will never be
executed.  (Note that in Python, ‘None’ is not an empty reference but an
object of type ‘None’.)

In this example mypy will go on to check the last line and report an
error, since mypy thinks that the condition could be either True or
False:

     class Foo:
         bar: str = ''

     def bar() -> None:
         foo: Foo = Foo()
         if not foo.bar:
             return
         x: int = 'abc'  # Reachable -- error

If you use the *note –warn-unreachable: b6. flag, mypy will generate an
error about each unreachable code block.


File: Mypy.info,  Node: Narrowing and inner functions,  Prev: Unreachable code,  Up: Common issues and solutions

1.28.21 Narrowing and inner functions
-------------------------------------

Because closures in Python are late-binding
(‘https://docs.python-guide.org/writing/gotchas/#late-binding-closures’),
mypy will not narrow the type of a captured variable in an inner
function.  This is best understood via an example:

     def foo(x: Optional[int]) -> Callable[[], int]:
         if x is None:
             x = 5
         print(x + 1)  # mypy correctly deduces x must be an int here
         def inner() -> int:
             return x + 1  # but (correctly) complains about this line

         x = None  # because x could later be assigned None
         return inner

     inner = foo(5)
     inner()  # this will raise an error when called

To get this code to type check, you could assign ‘y = x’ after ‘x’ has
been narrowed, and use ‘y’ in the inner function, or add an assert in
the inner function.


File: Mypy.info,  Node: Supported Python features,  Next: Error codes,  Prev: Common issues and solutions,  Up: Contents

1.29 Supported Python features
==============================

A list of unsupported Python features is maintained in the mypy wiki:

   - Unsupported Python features(1)

* Menu:

* Runtime definition of methods and functions::

   ---------- Footnotes ----------

   (1) https://github.com/python/mypy/wiki/Unsupported-Python-Features


File: Mypy.info,  Node: Runtime definition of methods and functions,  Up: Supported Python features

1.29.1 Runtime definition of methods and functions
--------------------------------------------------

By default, mypy will complain if you add a function to a class or
module outside its definition – but only if this is visible to the type
checker.  This only affects static checking, as mypy performs no
additional type checking at runtime.  You can easily work around this.
For example, you can use dynamically typed code or values with ‘Any’
types, or you can use setattr()(1) or other introspection features.
However, you need to be careful if you decide to do this.  If used
indiscriminately, you may have difficulty using static typing
effectively, since the type checker cannot see functions defined at
runtime.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#setattr


File: Mypy.info,  Node: Error codes,  Next: Error codes enabled by default,  Prev: Supported Python features,  Up: Contents

1.30 Error codes
================

Mypy can optionally display an error code such as ‘[attr-defined]’ after
each error message.  Error codes serve two purposes:

  1. It’s possible to silence specific error codes on a line using ‘#
     type: ignore[code]’.  This way you won’t accidentally ignore other,
     potentially more serious errors.

  2. The error code can be used to find documentation about the error.
     The next two topics (*note Error codes enabled by default: 278. and
     *note Error codes for optional checks: 2c.) document the various
     error codes mypy can report.

Most error codes are shared between multiple related error messages.
Error codes may change in future mypy releases.

* Menu:

* Displaying error codes::
* Silencing errors based on error codes::
* Enabling specific error codes::
* Per-module enabling/disabling error codes::


File: Mypy.info,  Node: Displaying error codes,  Next: Silencing errors based on error codes,  Up: Error codes

1.30.1 Displaying error codes
-----------------------------

Error codes are displayed by default.  Use *note –hide-error-codes: 17d.
or config ‘hide_error_codes = True’ to hide error codes.  Error codes
are shown inside square brackets:

     $ mypy prog.py
     prog.py:1: error: "str" has no attribute "trim"  [attr-defined]

It’s also possible to require error codes for ‘type: ignore’ comments.
See *note ignore-without-code: 27a. for more information.


File: Mypy.info,  Node: Silencing errors based on error codes,  Next: Enabling specific error codes,  Prev: Displaying error codes,  Up: Error codes

1.30.2 Silencing errors based on error codes
--------------------------------------------

You can use a special comment ‘# type: ignore[code, ...]’ to only ignore
errors with a specific error code (or codes) on a particular line.  This
can be used even if you have not configured mypy to show error codes.
Currently it’s only possible to disable arbitrary error codes on
individual lines using this comment.

You can also use *note –disable-error-code: 175. to disable specific
error codes globally.

This example shows how to ignore an error about an imported name mypy
thinks is undefined:

     # 'foo' is defined in 'foolib', even though mypy can't see the
     # definition.
     from foolib import foo  # type: ignore[attr-defined]


File: Mypy.info,  Node: Enabling specific error codes,  Next: Per-module enabling/disabling error codes,  Prev: Silencing errors based on error codes,  Up: Error codes

1.30.3 Enabling specific error codes
------------------------------------

There are command-line flags and config file settings for enabling
certain optional error codes, such as *note –disallow-untyped-defs: 9,
which enables the ‘no-untyped-def’ error code.

You can use *note –enable-error-code: 177. to enable specific error
codes that don’t have a dedicated command-line flag or config file
setting.


File: Mypy.info,  Node: Per-module enabling/disabling error codes,  Prev: Enabling specific error codes,  Up: Error codes

1.30.4 Per-module enabling/disabling error codes
------------------------------------------------

You can use *note configuration file: 20. sections to enable or disable
specific error codes only in some modules.  For example, this ‘mypy.ini’
config will enable non-annotated empty containers in tests, while
keeping other parts of code checked in strict mode:

     [mypy]
     strict = True

     [mypy-tests.*]
     allow_untyped_defs = True
     allow_untyped_calls = True
     disable_error_code = var-annotated, has-type

Note that per-module enabling/disabling acts as override over the global
options.  So that you don’t need to repeat the error code lists for each
module if you have them in global config section.  For example:

     [mypy]
     enable_error_code = truthy-bool, ignore-without-code, unused-awaitable

     [mypy-extensions.*]
     disable_error_code = unused-awaitable

The above config will allow unused awaitables in extension modules, but
will still keep the other two error codes enabled.  The overall logic is
following:

   * Command line and/or config main section set global error codes

   * Individual config sections ‘adjust’ them per glob/module

   * Inline ‘# mypy: ...’ comments can further ‘adjust’ them for a
     specific module

So one can e.g.  enable some code globally, disable it for all tests in
the corresponding config section, and then re-enable it with an inline
comment in some specific test.


File: Mypy.info,  Node: Error codes enabled by default,  Next: Error codes for optional checks,  Prev: Error codes,  Up: Contents

1.31 Error codes enabled by default
===================================

This section documents various errors codes that mypy can generate with
default options.  See *note Error codes: 176. for general documentation
about error codes.  *note Error codes for optional checks: 2c. documents
additional error codes that you can enable.

* Menu:

* Check that attribute exists [attr-defined]::
* Check that attribute exists in each union item [union-attr]::
* Check that name is defined [name-defined]::
* Check arguments in calls [call-arg]::
* Check argument types [arg-type]::
* Check calls to overloaded functions [call-overload]::
* Check validity of types [valid-type]::
* Require annotation if variable type is unclear [var-annotated]::
* Check validity of overrides [override]::
* Check that function returns a value [return]::
* Check that return value is compatible [return-value]::
* Check types in assignment statement [assignment]::
* Check type variable values [type-var]::
* Check uses of various operators [operator]::
* Check indexing operations [index]::
* Check list items [list-item]::
* Check dict items [dict-item]::
* Check TypedDict items [typeddict-item]::
* Check that type of target is known [has-type]::
* Check that import target can be found [import]::
* Check that each name is defined once [no-redef]::
* Check that called function returns a value [func-returns-value]::
* Check instantiation of abstract classes [abstract]::
* Safe handling of abstract type object types [type-abstract]::
* Check that call to an abstract method via super is valid [safe-super]::
* Check the target of NewType [valid-newtype]::
* Check the return type of __exit__ [exit-return]::
* Check that naming is consistent [name-match]::
* Check that overloaded functions have an implementation [no-overload-impl]::
* Check that coroutine return value is used [unused-coroutine]::
* Check types in assert_type [assert-type]::
* Report syntax errors [syntax]::
* Miscellaneous checks [misc]::


File: Mypy.info,  Node: Check that attribute exists [attr-defined],  Next: Check that attribute exists in each union item [union-attr],  Up: Error codes enabled by default

1.31.1 Check that attribute exists [attr-defined]
-------------------------------------------------

Mypy checks that an attribute is defined in the target class or module
when using the dot operator.  This applies to both getting and setting
an attribute.  New attributes are defined by assignments in the class
body, or assignments to ‘self.x’ in methods.  These assignments don’t
generate ‘attr-defined’ errors.

Example:

     class Resource:
         def __init__(self, name: str) -> None:
             self.name = name

     r = Resource('x')
     print(r.name)  # OK
     print(r.id)  # Error: "Resource" has no attribute "id"  [attr-defined]
     r.id = 5  # Error: "Resource" has no attribute "id"  [attr-defined]

This error code is also generated if an imported name is not defined in
the module in a ‘from ... import’ statement (as long as the target
module can be found):

     # Error: Module "os" has no attribute "non_existent"  [attr-defined]
     from os import non_existent

A reference to a missing attribute is given the ‘Any’ type.  In the
above example, the type of ‘non_existent’ will be ‘Any’, which can be
important if you silence the error.


File: Mypy.info,  Node: Check that attribute exists in each union item [union-attr],  Next: Check that name is defined [name-defined],  Prev: Check that attribute exists [attr-defined],  Up: Error codes enabled by default

1.31.2 Check that attribute exists in each union item [union-attr]
------------------------------------------------------------------

If you access the attribute of a value with a union type, mypy checks
that the attribute is defined for ‘every’ type in that union.  Otherwise
the operation can fail at runtime.  This also applies to optional types.

Example:

     from typing import Union

     class Cat:
         def sleep(self) -> None: ...
         def miaow(self) -> None: ...

     class Dog:
         def sleep(self) -> None: ...
         def follow_me(self) -> None: ...

     def func(animal: Union[Cat, Dog]) -> None:
         # OK: 'sleep' is defined for both Cat and Dog
         animal.sleep()
         # Error: Item "Cat" of "Union[Cat, Dog]" has no attribute "follow_me"  [union-attr]
         animal.follow_me()

You can often work around these errors by using ‘assert isinstance(obj,
ClassName)’ or ‘assert obj is not None’ to tell mypy that you know that
the type is more specific than what mypy thinks.


File: Mypy.info,  Node: Check that name is defined [name-defined],  Next: Check arguments in calls [call-arg],  Prev: Check that attribute exists in each union item [union-attr],  Up: Error codes enabled by default

1.31.3 Check that name is defined [name-defined]
------------------------------------------------

Mypy expects that all references to names have a corresponding
definition in an active scope, such as an assignment, function
definition or an import.  This can catch missing definitions, missing
imports, and typos.

This example accidentally calls ‘sort()’ instead of sorted()(1):

     x = sort([3, 2, 4])  # Error: Name "sort" is not defined  [name-defined]

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/functions.html#sorted


File: Mypy.info,  Node: Check arguments in calls [call-arg],  Next: Check argument types [arg-type],  Prev: Check that name is defined [name-defined],  Up: Error codes enabled by default

1.31.4 Check arguments in calls [call-arg]
------------------------------------------

Mypy expects that the number and names of arguments match the called
function.  Note that argument type checks have a separate error code
‘arg-type’.

Example:

     from typing import Sequence

     def greet(name: str) -> None:
          print('hello', name)

     greet('jack')  # OK
     greet('jill', 'jack')  # Error: Too many arguments for "greet"  [call-arg]


File: Mypy.info,  Node: Check argument types [arg-type],  Next: Check calls to overloaded functions [call-overload],  Prev: Check arguments in calls [call-arg],  Up: Error codes enabled by default

1.31.5 Check argument types [arg-type]
--------------------------------------

Mypy checks that argument types in a call match the declared argument
types in the signature of the called function (if one exists).

Example:

     from typing import Optional

     def first(x: list[int]) -> Optional[int]:
         return x[0] if x else 0

     t = (5, 4)
     # Error: Argument 1 to "first" has incompatible type "tuple[int, int]";
     #        expected "list[int]"  [arg-type]
     print(first(t))


File: Mypy.info,  Node: Check calls to overloaded functions [call-overload],  Next: Check validity of types [valid-type],  Prev: Check argument types [arg-type],  Up: Error codes enabled by default

1.31.6 Check calls to overloaded functions [call-overload]
----------------------------------------------------------

When you call an overloaded function, mypy checks that at least one of
the signatures of the overload items match the argument types in the
call.

Example:

     from typing import overload, Optional

     @overload
     def inc_maybe(x: None) -> None: ...

     @overload
     def inc_maybe(x: int) -> int: ...

     def inc_maybe(x: Optional[int]) -> Optional[int]:
          if x is None:
              return None
          else:
              return x + 1

     inc_maybe(None)  # OK
     inc_maybe(5)  # OK

     # Error: No overload variant of "inc_maybe" matches argument type "float"  [call-overload]
     inc_maybe(1.2)


File: Mypy.info,  Node: Check validity of types [valid-type],  Next: Require annotation if variable type is unclear [var-annotated],  Prev: Check calls to overloaded functions [call-overload],  Up: Error codes enabled by default

1.31.7 Check validity of types [valid-type]
-------------------------------------------

Mypy checks that each type annotation and any expression that represents
a type is a valid type.  Examples of valid types include classes, union
types, callable types, type aliases, and literal types.  Examples of
invalid types include bare integer literals, functions, variables, and
modules.

This example incorrectly uses the function ‘log’ as a type:

     def log(x: object) -> None:
         print('log:', repr(x))

     # Error: Function "t.log" is not valid as a type  [valid-type]
     def log_all(objs: list[object], f: log) -> None:
         for x in objs:
             f(x)

You can use Callable(1) as the type for callable objects:

     from typing import Callable

     # OK
     def log_all(objs: list[object], f: Callable[[object], None]) -> None:
         for x in objs:
             f(x)

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Callable


File: Mypy.info,  Node: Require annotation if variable type is unclear [var-annotated],  Next: Check validity of overrides [override],  Prev: Check validity of types [valid-type],  Up: Error codes enabled by default

1.31.8 Require annotation if variable type is unclear [var-annotated]
---------------------------------------------------------------------

In some cases mypy can’t infer the type of a variable without an
explicit annotation.  Mypy treats this as an error.  This typically
happens when you initialize a variable with an empty collection or
‘None’.  If mypy can’t infer the collection item type, mypy replaces any
parts of the type it couldn’t infer with ‘Any’ and generates an error.

Example with an error:

     class Bundle:
         def __init__(self) -> None:
             # Error: Need type annotation for "items"
             #        (hint: "items: list[<type>] = ...")  [var-annotated]
             self.items = []

     reveal_type(Bundle().items)  # list[Any]

To address this, we add an explicit annotation:

      class Bundle:
          def __init__(self) -> None:
              self.items: list[str] = []  # OK

     reveal_type(Bundle().items)  # list[str]


File: Mypy.info,  Node: Check validity of overrides [override],  Next: Check that function returns a value [return],  Prev: Require annotation if variable type is unclear [var-annotated],  Up: Error codes enabled by default

1.31.9 Check validity of overrides [override]
---------------------------------------------

Mypy checks that an overridden method or attribute is compatible with
the base class.  A method in a subclass must accept all arguments that
the base class method accepts, and the return type must conform to the
return type in the base class (Liskov substitution principle).

Argument types can be more general is a subclass (i.e., they can vary
contravariantly).  The return type can be narrowed in a subclass (i.e.,
it can vary covariantly).  It’s okay to define additional arguments in a
subclass method, as long all extra arguments have default values or can
be left out (‘*args’, for example).

Example:

     from typing import Optional, Union

     class Base:
         def method(self,
                    arg: int) -> Optional[int]:
             ...

     class Derived(Base):
         def method(self,
                    arg: Union[int, str]) -> int:  # OK
             ...

     class DerivedBad(Base):
         # Error: Argument 1 of "method" is incompatible with "Base"  [override]
         def method(self,
                    arg: bool) -> int:
             ...


File: Mypy.info,  Node: Check that function returns a value [return],  Next: Check that return value is compatible [return-value],  Prev: Check validity of overrides [override],  Up: Error codes enabled by default

1.31.10 Check that function returns a value [return]
----------------------------------------------------

If a function has a non-‘None’ return type, mypy expects that the
function always explicitly returns a value (or raises an exception).
The function should not fall off the end of the function, since this is
often a bug.

Example:

     # Error: Missing return statement  [return]
     def show(x: int) -> int:
         print(x)

     # Error: Missing return statement  [return]
     def pred1(x: int) -> int:
         if x > 0:
             return x - 1

     # OK
     def pred2(x: int) -> int:
         if x > 0:
             return x - 1
         else:
             raise ValueError('not defined for zero')


File: Mypy.info,  Node: Check that return value is compatible [return-value],  Next: Check types in assignment statement [assignment],  Prev: Check that function returns a value [return],  Up: Error codes enabled by default

1.31.11 Check that return value is compatible [return-value]
------------------------------------------------------------

Mypy checks that the returned value is compatible with the type
signature of the function.

Example:

     def func(x: int) -> str:
         # Error: Incompatible return value type (got "int", expected "str")  [return-value]
         return x + 1


File: Mypy.info,  Node: Check types in assignment statement [assignment],  Next: Check type variable values [type-var],  Prev: Check that return value is compatible [return-value],  Up: Error codes enabled by default

1.31.12 Check types in assignment statement [assignment]
--------------------------------------------------------

Mypy checks that the assigned expression is compatible with the
assignment target (or targets).

Example:

     class Resource:
         def __init__(self, name: str) -> None:
             self.name = name

     r = Resource('A')

     r.name = 'B'  # OK

     # Error: Incompatible types in assignment (expression has type "int",
     #        variable has type "str")  [assignment]
     r.name = 5


File: Mypy.info,  Node: Check type variable values [type-var],  Next: Check uses of various operators [operator],  Prev: Check types in assignment statement [assignment],  Up: Error codes enabled by default

1.31.13 Check type variable values [type-var]
---------------------------------------------

Mypy checks that value of a type variable is compatible with a value
restriction or the upper bound type.

Example:

     from typing import TypeVar

     T1 = TypeVar('T1', int, float)

     def add(x: T1, y: T1) -> T1:
         return x + y

     add(4, 5.5)  # OK

     # Error: Value of type variable "T1" of "add" cannot be "str"  [type-var]
     add('x', 'y')


File: Mypy.info,  Node: Check uses of various operators [operator],  Next: Check indexing operations [index],  Prev: Check type variable values [type-var],  Up: Error codes enabled by default

1.31.14 Check uses of various operators [operator]
--------------------------------------------------

Mypy checks that operands support a binary or unary operation, such as
‘+’ or ‘~’.  Indexing operations are so common that they have their own
error code ‘index’ (see below).

Example:

     # Error: Unsupported operand types for + ("int" and "str")  [operator]
     1 + 'x'


File: Mypy.info,  Node: Check indexing operations [index],  Next: Check list items [list-item],  Prev: Check uses of various operators [operator],  Up: Error codes enabled by default

1.31.15 Check indexing operations [index]
-----------------------------------------

Mypy checks that the indexed value in indexing operation such as ‘x[y]’
supports indexing, and that the index expression has a valid type.

Example:

     a = {'x': 1, 'y': 2}

     a['x']  # OK

     # Error: Invalid index type "int" for "dict[str, int]"; expected type "str"  [index]
     print(a[1])

     # Error: Invalid index type "bytes" for "dict[str, int]"; expected type "str"  [index]
     a[b'x'] = 4


File: Mypy.info,  Node: Check list items [list-item],  Next: Check dict items [dict-item],  Prev: Check indexing operations [index],  Up: Error codes enabled by default

1.31.16 Check list items [list-item]
------------------------------------

When constructing a list using ‘[item, ...]’, mypy checks that each item
is compatible with the list type that is inferred from the surrounding
context.

Example:

     # Error: List item 0 has incompatible type "int"; expected "str"  [list-item]
     a: list[str] = [0]


File: Mypy.info,  Node: Check dict items [dict-item],  Next: Check TypedDict items [typeddict-item],  Prev: Check list items [list-item],  Up: Error codes enabled by default

1.31.17 Check dict items [dict-item]
------------------------------------

When constructing a dictionary using ‘{key: value, ...}’ or
‘dict(key=value, ...)’, mypy checks that each key and value is
compatible with the dictionary type that is inferred from the
surrounding context.

Example:

     # Error: Dict entry 0 has incompatible type "str": "str"; expected "str": "int"  [dict-item]
     d: dict[str, int] = {'key': 'value'}


File: Mypy.info,  Node: Check TypedDict items [typeddict-item],  Next: Check that type of target is known [has-type],  Prev: Check dict items [dict-item],  Up: Error codes enabled by default

1.31.18 Check TypedDict items [typeddict-item]
----------------------------------------------

When constructing a ‘TypedDict’ object, mypy checks that each key and
value is compatible with the ‘TypedDict’ type that is inferred from the
surrounding context.

When getting a ‘TypedDict’ item, mypy checks that the key exists.  When
assigning to a ‘TypedDict’, mypy checks that both the key and the value
are valid.

Example:

     from typing_extensions import TypedDict

     class Point(TypedDict):
         x: int
         y: int

     # Error: Incompatible types (expression has type "float",
     #        TypedDict item "x" has type "int")  [typeddict-item]
     p: Point = {'x': 1.2, 'y': 4}


File: Mypy.info,  Node: Check that type of target is known [has-type],  Next: Check that import target can be found [import],  Prev: Check TypedDict items [typeddict-item],  Up: Error codes enabled by default

1.31.19 Check that type of target is known [has-type]
-----------------------------------------------------

Mypy sometimes generates an error when it hasn’t inferred any type for a
variable being referenced.  This can happen for references to variables
that are initialized later in the source file, and for references across
modules that form an import cycle.  When this happens, the reference
gets an implicit ‘Any’ type.

In this example the definitions of ‘x’ and ‘y’ are circular:

     class Problem:
         def set_x(self) -> None:
             # Error: Cannot determine type of "y"  [has-type]
             self.x = self.y

         def set_y(self) -> None:
             self.y = self.x

To work around this error, you can add an explicit type annotation to
the target variable or attribute.  Sometimes you can also reorganize the
code so that the definition of the variable is placed earlier than the
reference to the variable in a source file.  Untangling cyclic imports
may also help.

We add an explicit annotation to the ‘y’ attribute to work around the
issue:

     class Problem:
         def set_x(self) -> None:
             self.x = self.y  # OK

         def set_y(self) -> None:
             self.y: int = self.x  # Added annotation here


File: Mypy.info,  Node: Check that import target can be found [import],  Next: Check that each name is defined once [no-redef],  Prev: Check that type of target is known [has-type],  Up: Error codes enabled by default

1.31.20 Check that import target can be found [import]
------------------------------------------------------

Mypy generates an error if it can’t find the source code or a stub file
for an imported module.

Example:

     # Error: Cannot find implementation or library stub for module named 'acme'  [import]
     import acme

See *note Missing imports: 16. for how to work around these errors.


File: Mypy.info,  Node: Check that each name is defined once [no-redef],  Next: Check that called function returns a value [func-returns-value],  Prev: Check that import target can be found [import],  Up: Error codes enabled by default

1.31.21 Check that each name is defined once [no-redef]
-------------------------------------------------------

Mypy may generate an error if you have multiple definitions for a name
in the same namespace.  The reason is that this is often an error, as
the second definition may overwrite the first one.  Also, mypy often
can’t be able to determine whether references point to the first or the
second definition, which would compromise type checking.

If you silence this error, all references to the defined name refer to
the ‘first’ definition.

Example:

     class A:
         def __init__(self, x: int) -> None: ...

     class A:  # Error: Name "A" already defined on line 1  [no-redef]
         def __init__(self, x: str) -> None: ...

     # Error: Argument 1 to "A" has incompatible type "str"; expected "int"
     #        (the first definition wins!)
     A('x')


File: Mypy.info,  Node: Check that called function returns a value [func-returns-value],  Next: Check instantiation of abstract classes [abstract],  Prev: Check that each name is defined once [no-redef],  Up: Error codes enabled by default

1.31.22 Check that called function returns a value [func-returns-value]
-----------------------------------------------------------------------

Mypy reports an error if you call a function with a ‘None’ return type
and don’t ignore the return value, as this is usually (but not always) a
programming error.

In this example, the ‘if f()’ check is always false since ‘f’ returns
‘None’:

     def f() -> None:
         ...

     # OK: we don't do anything with the return value
     f()

     # Error: "f" does not return a value  [func-returns-value]
     if f():
          print("not false")


File: Mypy.info,  Node: Check instantiation of abstract classes [abstract],  Next: Safe handling of abstract type object types [type-abstract],  Prev: Check that called function returns a value [func-returns-value],  Up: Error codes enabled by default

1.31.23 Check instantiation of abstract classes [abstract]
----------------------------------------------------------

Mypy generates an error if you try to instantiate an abstract base class
(ABC). An abstract base class is a class with at least one abstract
method or attribute.  (See also abc(1) module documentation)

Sometimes a class is made accidentally abstract, often due to an
unimplemented abstract method.  In a case like this you need to provide
an implementation for the method to make the class concrete
(non-abstract).

Example:

     from abc import ABCMeta, abstractmethod

     class Persistent(metaclass=ABCMeta):
         @abstractmethod
         def save(self) -> None: ...

     class Thing(Persistent):
         def __init__(self) -> None:
             ...

         ...  # No "save" method

     # Error: Cannot instantiate abstract class "Thing" with abstract attribute "save"  [abstract]
     t = Thing()

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/abc.html#module-abc


File: Mypy.info,  Node: Safe handling of abstract type object types [type-abstract],  Next: Check that call to an abstract method via super is valid [safe-super],  Prev: Check instantiation of abstract classes [abstract],  Up: Error codes enabled by default

1.31.24 Safe handling of abstract type object types [type-abstract]
-------------------------------------------------------------------

Mypy always allows instantiating (calling) type objects typed as
‘Type[t]’, even if it is not known that ‘t’ is non-abstract, since it is
a common pattern to create functions that act as object factories
(custom constructors).  Therefore, to prevent issues described in the
above section, when an abstract type object is passed where ‘Type[t]’ is
expected, mypy will give an error.  Example:

     from abc import ABCMeta, abstractmethod
     from typing import List, Type, TypeVar

     class Config(metaclass=ABCMeta):
         @abstractmethod
         def get_value(self, attr: str) -> str: ...

     T = TypeVar("T")
     def make_many(typ: Type[T], n: int) -> List[T]:
         return [typ() for _ in range(n)]  # This will raise if typ is abstract

     # Error: Only concrete class can be given where "Type[Config]" is expected [type-abstract]
     make_many(Config, 5)


File: Mypy.info,  Node: Check that call to an abstract method via super is valid [safe-super],  Next: Check the target of NewType [valid-newtype],  Prev: Safe handling of abstract type object types [type-abstract],  Up: Error codes enabled by default

1.31.25 Check that call to an abstract method via super is valid [safe-super]
-----------------------------------------------------------------------------

Abstract methods often don’t have any default implementation, i.e.
their bodies are just empty.  Calling such methods in subclasses via
‘super()’ will cause runtime errors, so mypy prevents you from doing so:

     from abc import abstractmethod
     class Base:
         @abstractmethod
         def foo(self) -> int: ...
     class Sub(Base):
         def foo(self) -> int:
             return super().foo() + 1  # error: Call to abstract method "foo" of "Base" with
                                       # trivial body via super() is unsafe  [safe-super]
     Sub().foo()  # This will crash at runtime.

Mypy considers the following as trivial bodies: a ‘pass’ statement, a
literal ellipsis ‘...’, a docstring, and a ‘raise NotImplementedError’
statement.


File: Mypy.info,  Node: Check the target of NewType [valid-newtype],  Next: Check the return type of __exit__ [exit-return],  Prev: Check that call to an abstract method via super is valid [safe-super],  Up: Error codes enabled by default

1.31.26 Check the target of NewType [valid-newtype]
---------------------------------------------------

The target of a ‘NewType’ definition must be a class type.  It can’t be
a union type, ‘Any’, or various other special types.

You can also get this error if the target has been imported from a
module whose source mypy cannot find, since any such definitions are
treated by mypy as values with ‘Any’ types.  Example:

     from typing import NewType

     # The source for "acme" is not available for mypy
     from acme import Entity  # type: ignore

     # Error: Argument 2 to NewType(...) must be subclassable (got "Any")  [valid-newtype]
     UserEntity = NewType('UserEntity', Entity)

To work around the issue, you can either give mypy access to the sources
for ‘acme’ or create a stub file for the module.  See *note Missing
imports: 16. for more information.


File: Mypy.info,  Node: Check the return type of __exit__ [exit-return],  Next: Check that naming is consistent [name-match],  Prev: Check the target of NewType [valid-newtype],  Up: Error codes enabled by default

1.31.27 Check the return type of __exit__ [exit-return]
-------------------------------------------------------

If mypy can determine that __exit__(1) always returns ‘False’, mypy
checks that the return type is ‘not’ ‘bool’.  The boolean value of the
return type affects which lines mypy thinks are reachable after a ‘with’
statement, since any __exit__(2) method that can return ‘True’ may
swallow exceptions.  An imprecise return type can result in mysterious
errors reported near ‘with’ statements.

To fix this, use either ‘typing_extensions.Literal[False]’ or ‘None’ as
the return type.  Returning ‘None’ is equivalent to returning ‘False’ in
this context, since both are treated as false values.

Example:

     class MyContext:
         ...
         def __exit__(self, exc, value, tb) -> bool:  # Error
             print('exit')
             return False

This produces the following output from mypy:

     example.py:3: error: "bool" is invalid as return type for "__exit__" that always returns False
     example.py:3: note: Use "typing_extensions.Literal[False]" as the return type or change it to
         "None"
     example.py:3: note: If return type of "__exit__" implies that it may return True, the context
         manager may swallow exceptions

You can use ‘Literal[False]’ to fix the error:

     from typing_extensions import Literal

     class MyContext:
         ...
         def __exit__(self, exc, value, tb) -> Literal[False]:  # OK
             print('exit')
             return False

You can also use ‘None’:

     class MyContext:
         ...
         def __exit__(self, exc, value, tb) -> None:  # Also OK
             print('exit')

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__exit__

   (2) 
https://docs.python.org/3/reference/datamodel.html#object.__exit__


File: Mypy.info,  Node: Check that naming is consistent [name-match],  Next: Check that overloaded functions have an implementation [no-overload-impl],  Prev: Check the return type of __exit__ [exit-return],  Up: Error codes enabled by default

1.31.28 Check that naming is consistent [name-match]
----------------------------------------------------

The definition of a named tuple or a TypedDict must be named
consistently when using the call-based syntax.  Example:

     from typing import NamedTuple

     # Error: First argument to namedtuple() should be "Point2D", not "Point"
     Point2D = NamedTuple("Point", [("x", int), ("y", int)])


File: Mypy.info,  Node: Check that overloaded functions have an implementation [no-overload-impl],  Next: Check that coroutine return value is used [unused-coroutine],  Prev: Check that naming is consistent [name-match],  Up: Error codes enabled by default

1.31.29 Check that overloaded functions have an implementation [no-overload-impl]
---------------------------------------------------------------------------------

Overloaded functions outside of stub files must be followed by a non
overloaded implementation.

     from typing import overload

     @overload
     def func(value: int) -> int:
         ...

     @overload
     def func(value: str) -> str:
         ...

     # presence of required function below is checked
     def func(value):
         pass  # actual implementation


File: Mypy.info,  Node: Check that coroutine return value is used [unused-coroutine],  Next: Check types in assert_type [assert-type],  Prev: Check that overloaded functions have an implementation [no-overload-impl],  Up: Error codes enabled by default

1.31.30 Check that coroutine return value is used [unused-coroutine]
--------------------------------------------------------------------

Mypy ensures that return values of async def functions are not ignored,
as this is usually a programming error, as the coroutine won’t be
executed at the call site.

     async def f() -> None:
         ...

     async def g() -> None:
         f()  # Error: missing await
         await f()  # OK

You can work around this error by assigning the result to a temporary,
otherwise unused variable:

     _ = f()  # No error


File: Mypy.info,  Node: Check types in assert_type [assert-type],  Next: Report syntax errors [syntax],  Prev: Check that coroutine return value is used [unused-coroutine],  Up: Error codes enabled by default

1.31.31 Check types in assert_type [assert-type]
------------------------------------------------

The inferred type for an expression passed to ‘assert_type’ must match
the provided type.

     from typing_extensions import assert_type

     assert_type([1], list[int])  # OK

     assert_type([1], list[str])  # Error


File: Mypy.info,  Node: Report syntax errors [syntax],  Next: Miscellaneous checks [misc],  Prev: Check types in assert_type [assert-type],  Up: Error codes enabled by default

1.31.32 Report syntax errors [syntax]
-------------------------------------

If the code being checked is not syntactically valid, mypy issues a
syntax error.  Most, but not all, syntax errors are ‘blocking errors’:
they can’t be ignored with a ‘# type: ignore’ comment.


File: Mypy.info,  Node: Miscellaneous checks [misc],  Prev: Report syntax errors [syntax],  Up: Error codes enabled by default

1.31.33 Miscellaneous checks [misc]
-----------------------------------

Mypy performs numerous other, less commonly failing checks that don’t
have specific error codes.  These use the ‘misc’ error code.  Other than
being used for multiple unrelated errors, the ‘misc’ error code is not
special.  For example, you can ignore all errors in this category by
using ‘# type: ignore[misc]’ comment.  Since these errors are not
expected to be common, it’s unlikely that you’ll see two ‘different’
errors with the ‘misc’ code on a single line – though this can certainly
happen once in a while.

     Note: Future mypy versions will likely add new error codes for some
     errors that currently use the ‘misc’ error code.


File: Mypy.info,  Node: Error codes for optional checks,  Next: Additional features,  Prev: Error codes enabled by default,  Up: Contents

1.32 Error codes for optional checks
====================================

This section documents various errors codes that mypy generates only if
you enable certain options.  See *note Error codes: 176. for general
documentation about error codes.  *note Error codes enabled by default:
278. documents error codes that are enabled by default.

     Note: The examples in this section use *note inline configuration:
     1a6. to specify mypy options.  You can also set the same options by
     using a *note configuration file: 20. or *note command-line
     options: a.

* Menu:

* Check that type arguments exist [type-arg]::
* Check that every function has an annotation [no-untyped-def]::
* Check that cast is not redundant [redundant-cast]::
* Check that comparisons are overlapping [comparison-overlap]::
* Check that no untyped functions are called [no-untyped-call]::
* Check that function does not return Any value [no-any-return]::
* Check that types have no Any components due to missing imports [no-any-unimported]::
* Check that statement or expression is unreachable [unreachable]::
* Check that expression is redundant [redundant-expr]::
* Check that expression is not implicitly true in boolean context [truthy-bool]::
* Check that # type; ignore include an error code [ignore-without-code]: Check that # type ignore include an error code [ignore-without-code].
* Check that awaitable return value is used [unused-awaitable]::


File: Mypy.info,  Node: Check that type arguments exist [type-arg],  Next: Check that every function has an annotation [no-untyped-def],  Up: Error codes for optional checks

1.32.1 Check that type arguments exist [type-arg]
-------------------------------------------------

If you use *note –disallow-any-generics: 15e, mypy requires that each
generic type has values for each type argument.  For example, the types
‘list’ or ‘dict’ would be rejected.  You should instead use types like
‘list[int]’ or ‘dict[str, int]’.  Any omitted generic type arguments get
implicit ‘Any’ values.  The type ‘list’ is equivalent to ‘list[Any]’,
and so on.

Example:

     # mypy: disallow-any-generics

     # Error: Missing type parameters for generic type "list"  [type-arg]
     def remove_dups(items: list) -> list:
         ...


File: Mypy.info,  Node: Check that every function has an annotation [no-untyped-def],  Next: Check that cast is not redundant [redundant-cast],  Prev: Check that type arguments exist [type-arg],  Up: Error codes for optional checks

1.32.2 Check that every function has an annotation [no-untyped-def]
-------------------------------------------------------------------

If you use *note –disallow-untyped-defs: 9, mypy requires that all
functions have annotations (either a Python 3 annotation or a type
comment).

Example:

     # mypy: disallow-untyped-defs

     def inc(x):  # Error: Function is missing a type annotation  [no-untyped-def]
         return x + 1

     def inc_ok(x: int) -> int:  # OK
         return x + 1

     class Counter:
          # Error: Function is missing a type annotation  [no-untyped-def]
          def __init__(self):
              self.value = 0

     class CounterOk:
          # OK: An explicit "-> None" is needed if "__init__" takes no arguments
          def __init__(self) -> None:
              self.value = 0


File: Mypy.info,  Node: Check that cast is not redundant [redundant-cast],  Next: Check that comparisons are overlapping [comparison-overlap],  Prev: Check that every function has an annotation [no-untyped-def],  Up: Error codes for optional checks

1.32.3 Check that cast is not redundant [redundant-cast]
--------------------------------------------------------

If you use *note –warn-redundant-casts: 16a, mypy will generate an error
if the source type of a cast is the same as the target type.

Example:

     # mypy: warn-redundant-casts

     from typing import cast

     Count = int

     def example(x: Count) -> int:
         # Error: Redundant cast to "int"  [redundant-cast]
         return cast(int, x)


File: Mypy.info,  Node: Check that comparisons are overlapping [comparison-overlap],  Next: Check that no untyped functions are called [no-untyped-call],  Prev: Check that cast is not redundant [redundant-cast],  Up: Error codes for optional checks

1.32.4 Check that comparisons are overlapping [comparison-overlap]
------------------------------------------------------------------

If you use *note –strict-equality: 174, mypy will generate an error if
it thinks that a comparison operation is always true or false.  These
are often bugs.  Sometimes mypy is too picky and the comparison can
actually be useful.  Instead of disabling strict equality checking
everywhere, you can use ‘# type: ignore[comparison-overlap]’ to ignore
the issue on a particular line only.

Example:

     # mypy: strict-equality

     def is_magic(x: bytes) -> bool:
         # Error: Non-overlapping equality check (left operand type: "bytes",
         #        right operand type: "str")  [comparison-overlap]
         return x == 'magic'

We can fix the error by changing the string literal to a bytes literal:

     # mypy: strict-equality

     def is_magic(x: bytes) -> bool:
         return x == b'magic'  # OK


File: Mypy.info,  Node: Check that no untyped functions are called [no-untyped-call],  Next: Check that function does not return Any value [no-any-return],  Prev: Check that comparisons are overlapping [comparison-overlap],  Up: Error codes for optional checks

1.32.5 Check that no untyped functions are called [no-untyped-call]
-------------------------------------------------------------------

If you use *note –disallow-untyped-calls: 161, mypy generates an error
when you call an unannotated function in an annotated function.

Example:

     # mypy: disallow-untyped-calls

     def do_it() -> None:
         # Error: Call to untyped function "bad" in typed context  [no-untyped-call]
         bad()

     def bad():
         ...


File: Mypy.info,  Node: Check that function does not return Any value [no-any-return],  Next: Check that types have no Any components due to missing imports [no-any-unimported],  Prev: Check that no untyped functions are called [no-untyped-call],  Up: Error codes for optional checks

1.32.6 Check that function does not return Any value [no-any-return]
--------------------------------------------------------------------

If you use *note –warn-return-any: 16d, mypy generates an error if you
return a value with an ‘Any’ type in a function that is annotated to
return a non-‘Any’ value.

Example:

     # mypy: warn-return-any

     def fields(s):
          return s.split(',')

     def first_field(x: str) -> str:
         # Error: Returning Any from function declared to return "str"  [no-any-return]
         return fields(x)[0]


File: Mypy.info,  Node: Check that types have no Any components due to missing imports [no-any-unimported],  Next: Check that statement or expression is unreachable [unreachable],  Prev: Check that function does not return Any value [no-any-return],  Up: Error codes for optional checks

1.32.7 Check that types have no Any components due to missing imports [no-any-unimported]
-----------------------------------------------------------------------------------------

If you use *note –disallow-any-unimported: 15a, mypy generates an error
if a component of a type becomes ‘Any’ because mypy couldn’t resolve an
import.  These “stealth” ‘Any’ types can be surprising and accidentally
cause imprecise type checking.

In this example, we assume that mypy can’t find the module ‘animals’,
which means that ‘Cat’ falls back to ‘Any’ in a type annotation:

     # mypy: disallow-any-unimported

     from animals import Cat  # type: ignore

     # Error: Argument 1 to "feed" becomes "Any" due to an unfollowed import  [no-any-unimported]
     def feed(cat: Cat) -> None:
         ...


File: Mypy.info,  Node: Check that statement or expression is unreachable [unreachable],  Next: Check that expression is redundant [redundant-expr],  Prev: Check that types have no Any components due to missing imports [no-any-unimported],  Up: Error codes for optional checks

1.32.8 Check that statement or expression is unreachable [unreachable]
----------------------------------------------------------------------

If you use *note –warn-unreachable: b6, mypy generates an error if it
thinks that a statement or expression will never be executed.  In most
cases, this is due to incorrect control flow or conditional checks that
are accidentally always true or false.

     # mypy: warn-unreachable

     def example(x: int) -> None:
         # Error: Right operand of "or" is never evaluated  [unreachable]
         assert isinstance(x, int) or x == 'unused'

         return
         # Error: Statement is unreachable  [unreachable]
         print('unreachable')


File: Mypy.info,  Node: Check that expression is redundant [redundant-expr],  Next: Check that expression is not implicitly true in boolean context [truthy-bool],  Prev: Check that statement or expression is unreachable [unreachable],  Up: Error codes for optional checks

1.32.9 Check that expression is redundant [redundant-expr]
----------------------------------------------------------

If you use *note –enable-error-code redundant-expr: 177, mypy generates
an error if it thinks that an expression is redundant.

     # Use "mypy --enable-error-code redundant-expr ..."

     def example(x: int) -> None:
         # Error: Left operand of "and" is always true  [redundant-expr]
         if isinstance(x, int) and x > 0:
             pass

         # Error: If condition is always true  [redundant-expr]
         1 if isinstance(x, int) else 0

         # Error: If condition in comprehension is always true  [redundant-expr]
         [i for i in range(x) if isinstance(i, int)]


File: Mypy.info,  Node: Check that expression is not implicitly true in boolean context [truthy-bool],  Next: Check that # type ignore include an error code [ignore-without-code],  Prev: Check that expression is redundant [redundant-expr],  Up: Error codes for optional checks

1.32.10 Check that expression is not implicitly true in boolean context [truthy-bool]
-------------------------------------------------------------------------------------

Warn when an expression whose type does not implement ‘__bool__’ or
‘__len__’ is used in boolean context, since unless implemented by a
sub-type, the expression will always evaluate to true.

     # Use "mypy --enable-error-code truthy-bool ..."

     class Foo:
       pass
     foo = Foo()
     # Error: "foo" has type "Foo" which does not implement __bool__ or __len__ so it could always be true in boolean context
     if foo:
        ...

This check might falsely imply an error.  For example, ‘Iterable’ does
not implement ‘__len__’ and so this code will be flagged:

     # Use "mypy -enable-error-code truthy-bool ..."

     from typing import Iterable

     def transform(items: Iterable[int]) -> Iterable[int]:
         # Error: "items" has type "Iterable[int]" which does not implement __bool__ or __len__ so it could always be true in boolean context  [truthy-bool]
         if not items:
             return [42]
         return [x + 1 for x in items]

If called as ‘transform((int(s) for s in []))’, this function would not
return ‘[42]’ unlike what the author might have intended.  Of course
it’s possible that ‘transform’ is only passed ‘list’ objects, and so
there is no error in practice.  In such case, it might be prudent to
annotate ‘items: Sequence[int]’.

This is similar in concept to ensuring that an expression’s type
implements an expected interface (e.g.  ‘Sized’), except that attempting
to invoke an undefined method (e.g.  ‘__len__’) results in an error,
while attempting to evaluate an object in boolean context without a
concrete implementation results in a truthy value.


File: Mypy.info,  Node: Check that # type ignore include an error code [ignore-without-code],  Next: Check that awaitable return value is used [unused-awaitable],  Prev: Check that expression is not implicitly true in boolean context [truthy-bool],  Up: Error codes for optional checks

1.32.11 Check that ‘# type: ignore’ include an error code [ignore-without-code]
-------------------------------------------------------------------------------

Warn when a ‘# type: ignore’ comment does not specify any error codes.
This clarifies the intent of the ignore and ensures that only the
expected errors are silenced.

Example:

     # Use "mypy --enable-error-code ignore-without-code ..."

     class Foo:
         def __init__(self, name: str) -> None:
             self.name = name

     f = Foo('foo')

     # This line has a typo that mypy can't help with as both:
     # - the expected error 'assignment', and
     # - the unexpected error 'attr-defined'
     # are silenced.
     # Error: "type: ignore" comment without error code (consider "type: ignore[attr-defined]" instead)
     f.nme = 42  # type: ignore

     # This line warns correctly about the typo in the attribute name
     # Error: "Foo" has no attribute "nme"; maybe "name"?
     f.nme = 42  # type: ignore[assignment]


File: Mypy.info,  Node: Check that awaitable return value is used [unused-awaitable],  Prev: Check that # type ignore include an error code [ignore-without-code],  Up: Error codes for optional checks

1.32.12 Check that awaitable return value is used [unused-awaitable]
--------------------------------------------------------------------

If you use *note –enable-error-code unused-awaitable: 177, mypy
generates an error if you don’t use a returned value that defines
‘__await__’.

Example:

     # Use "mypy --enable-error-code unused-awaitable ..."

     import asyncio

     async def f() -> int: ...

     async def g() -> None:
         # Error: Value of type "Task[int]" must be used
         #        Are you missing an await?
         asyncio.create_task(f())

You can assign the value to a temporary, otherwise unused to variable to
silence the error:

     async def g() -> None:
         _ = asyncio.create_task(f())  # No error


File: Mypy.info,  Node: Additional features,  Next: Frequently Asked Questions,  Prev: Error codes for optional checks,  Up: Contents

1.33 Additional features
========================

This section discusses various features that did not fit in naturally in
one of the previous sections.

* Menu:

* Dataclasses::
* The attrs package::
* Using a remote cache to speed up mypy runs::
* Extended Callable types::


File: Mypy.info,  Node: Dataclasses,  Next: The attrs package,  Up: Additional features

1.33.1 Dataclasses
------------------

In Python 3.7, a new dataclasses(1) module has been added to the
standard library.  This module allows defining and customizing simple
boilerplate-free classes.  They can be defined using the
@dataclasses.dataclass(2) decorator:

     from dataclasses import dataclass, field

     @dataclass
     class Application:
         name: str
         plugins: list[str] = field(default_factory=list)

     test = Application("Testing...")  # OK
     bad = Application("Testing...", "with plugin")  # Error: list[str] expected

Mypy will detect special methods (such as __lt__(3)) depending on the
flags used to define dataclasses.  For example:

     from dataclasses import dataclass

     @dataclass(order=True)
     class OrderedPoint:
         x: int
         y: int

     @dataclass(order=False)
     class UnorderedPoint:
         x: int
         y: int

     OrderedPoint(1, 2) < OrderedPoint(3, 4)  # OK
     UnorderedPoint(1, 2) < UnorderedPoint(3, 4)  # Error: Unsupported operand types

Dataclasses can be generic and can be used in any other way a normal
class can be used:

     from dataclasses import dataclass
     from typing import Generic, TypeVar

     T = TypeVar('T')

     @dataclass
     class BoxedData(Generic[T]):
         data: T
         label: str

     def unbox(bd: BoxedData[T]) -> T:
         ...

     val = unbox(BoxedData(42, "<important>"))  # OK, inferred type is int

For more information see official docs(4) and PEP 557(5).

* Menu:

* Caveats/Known Issues::

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/dataclasses.html#module-dataclasses

   (2) 
https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass

   (3) https://docs.python.org/3/reference/datamodel.html#object.__lt__

   (4) https://docs.python.org/3/library/dataclasses.html

   (5) https://peps.python.org/pep-0557/


File: Mypy.info,  Node: Caveats/Known Issues,  Up: Dataclasses

1.33.1.1 Caveats/Known Issues
.............................

Some functions in the dataclasses(1) module, such as replace()(2) and
asdict()(3), have imprecise (too permissive) types.  This will be fixed
in future releases.

Mypy does not yet recognize aliases of dataclasses.dataclass(4), and
will probably never recognize dynamically computed decorators.  The
following examples do ‘not’ work:

     from dataclasses import dataclass

     dataclass_alias = dataclass
     def dataclass_wrapper(cls):
       return dataclass(cls)

     @dataclass_alias
     class AliasDecorated:
       """
       Mypy doesn't recognize this as a dataclass because it is decorated by an
       alias of `dataclass` rather than by `dataclass` itself.
       """
       attribute: int

     @dataclass_wrapper
     class DynamicallyDecorated:
       """
       Mypy doesn't recognize this as a dataclass because it is decorated by a
       function returning `dataclass` rather than by `dataclass` itself.
       """
       attribute: int

     AliasDecorated(attribute=1) # error: Unexpected keyword argument
     DynamicallyDecorated(attribute=1) # error: Unexpected keyword argument

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/library/dataclasses.html#module-dataclasses

   (2) 
https://docs.python.org/3/library/dataclasses.html#dataclasses.replace

   (3) 
https://docs.python.org/3/library/dataclasses.html#dataclasses.asdict

   (4) 
https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass


File: Mypy.info,  Node: The attrs package,  Next: Using a remote cache to speed up mypy runs,  Prev: Dataclasses,  Up: Additional features

1.33.2 The attrs package
------------------------

attrs(1) is a package that lets you define classes without writing
boilerplate code.  Mypy can detect uses of the package and will generate
the necessary method definitions for decorated classes using the type
annotations it finds.  Type annotations can be added as follows:

     import attr

     @attr.s
     class A:
         one: int = attr.ib()          # Variable annotation (Python 3.6+)
         two = attr.ib()  # type: int  # Type comment
         three = attr.ib(type=int)     # type= argument

If you’re using ‘auto_attribs=True’ you must use variable annotations.

     import attr

     @attr.s(auto_attribs=True)
     class A:
         one: int
         two: int = 7
         three: int = attr.ib(8)

Typeshed has a couple of “white lie” annotations to make type checking
easier.  attr.ib()(2) and ‘attr.Factory’ actually return objects, but
the annotation says these return the types that they expect to be
assigned to.  That enables this to work:

     import attr
     from typing import Dict

     @attr.s(auto_attribs=True)
     class A:
         one: int = attr.ib(8)
         two: Dict[str, str] = attr.Factory(dict)
         bad: str = attr.ib(16)   # Error: can't assign int to str

* Menu:

* Caveats/Known Issues: Caveats/Known Issues<2>.

   ---------- Footnotes ----------

   (1) https://www.attrs.org/en/stable/index.html

   (2) https://www.attrs.org/en/stable/api.html#attr.ib


File: Mypy.info,  Node: Caveats/Known Issues<2>,  Up: The attrs package

1.33.2.1 Caveats/Known Issues
.............................

   * The detection of attr classes and attributes works by function name
     only.  This means that if you have your own helper functions that,
     for example, ‘return attr.ib()’ mypy will not see them.

   * All boolean arguments that mypy cares about must be literal ‘True’
     or ‘False’.  e.g the following will not work:

          import attr
          YES = True
          @attr.s(init=YES)
          class A:
              ...

   * Currently, ‘converter’ only supports named functions.  If mypy
     finds something else it will complain about not understanding the
     argument and the type annotation in __init__(1) will be replaced by
     ‘Any’.

   * Validator decorators(2) and default decorators(3) are not
     type-checked against the attribute they are setting/validating.

   * Method definitions added by mypy currently overwrite any existing
     method definitions.

   ---------- Footnotes ----------

   (1) 
https://docs.python.org/3/reference/datamodel.html#object.__init__

   (2) https://www.attrs.org/en/stable/examples.html#examples-validators

   (3) http://www.attrs.org/en/stable/examples.html#defaults


File: Mypy.info,  Node: Using a remote cache to speed up mypy runs,  Next: Extended Callable types,  Prev: The attrs package,  Up: Additional features

1.33.3 Using a remote cache to speed up mypy runs
-------------------------------------------------

Mypy performs type checking ‘incrementally’, reusing results from
previous runs to speed up successive runs.  If you are type checking a
large codebase, mypy can still be sometimes slower than desirable.  For
example, if you create a new branch based on a much more recent commit
than the target of the previous mypy run, mypy may have to process
almost every file, as a large fraction of source files may have changed.
This can also happen after you’ve rebased a local branch.

Mypy supports using a ‘remote cache’ to improve performance in cases
such as the above.  In a large codebase, remote caching can sometimes
speed up mypy runs by a factor of 10, or more.

Mypy doesn’t include all components needed to set this up – generally
you will have to perform some simple integration with your Continuous
Integration (CI) or build system to configure mypy to use a remote
cache.  This discussion assumes you have a CI system set up for the mypy
build you want to speed up, and that you are using a central git
repository.  Generalizing to different environments should not be
difficult.

Here are the main components needed:

   * A shared repository for storing mypy cache files for all landed
     commits.

   * CI build that uploads mypy incremental cache files to the shared
     repository for each commit for which the CI build runs.

   * A wrapper script around mypy that developers use to run mypy with
     remote caching enabled.

Below we discuss each of these components in some detail.

* Menu:

* Shared repository for cache files::
* Continuous Integration build::
* Mypy wrapper script::
* Caching with mypy daemon::
* Refinements::


File: Mypy.info,  Node: Shared repository for cache files,  Next: Continuous Integration build,  Up: Using a remote cache to speed up mypy runs

1.33.3.1 Shared repository for cache files
..........................................

You need a repository that allows you to upload mypy cache files from
your CI build and make the cache files available for download based on a
commit id.  A simple approach would be to produce an archive of the
‘.mypy_cache’ directory (which contains the mypy cache data) as a
downloadable ‘build artifact’ from your CI build (depending on the
capabilities of your CI system).  Alternatively, you could upload the
data to a web server or to S3, for example.


File: Mypy.info,  Node: Continuous Integration build,  Next: Mypy wrapper script,  Prev: Shared repository for cache files,  Up: Using a remote cache to speed up mypy runs

1.33.3.2 Continuous Integration build
.....................................

The CI build would run a regular mypy build and create an archive
containing the ‘.mypy_cache’ directory produced by the build.  Finally,
it will produce the cache as a build artifact or upload it to a
repository where it is accessible by the mypy wrapper script.

Your CI script might work like this:

   * Run mypy normally.  This will generate cache data under the
     ‘.mypy_cache’ directory.

   * Create a tarball from the ‘.mypy_cache’ directory.

   * Determine the current git master branch commit id (say, using ‘git
     rev-parse HEAD’).

   * Upload the tarball to the shared repository with a name derived
     from the commit id.


File: Mypy.info,  Node: Mypy wrapper script,  Next: Caching with mypy daemon,  Prev: Continuous Integration build,  Up: Using a remote cache to speed up mypy runs

1.33.3.3 Mypy wrapper script
............................

The wrapper script is used by developers to run mypy locally during
development instead of invoking mypy directly.  The wrapper first
populates the local ‘.mypy_cache’ directory from the shared repository
and then runs a normal incremental build.

The wrapper script needs some logic to determine the most recent central
repository commit (by convention, the ‘origin/master’ branch for git)
the local development branch is based on.  In a typical git setup you
can do it like this:

     git merge-base HEAD origin/master

The next step is to download the cache data (contents of the
‘.mypy_cache’ directory) from the shared repository based on the commit
id of the merge base produced by the git command above.  The script will
decompress the data so that mypy will start with a fresh ‘.mypy_cache’.
Finally, the script runs mypy normally.  And that’s all!


File: Mypy.info,  Node: Caching with mypy daemon,  Next: Refinements,  Prev: Mypy wrapper script,  Up: Using a remote cache to speed up mypy runs

1.33.3.4 Caching with mypy daemon
.................................

You can also use remote caching with the *note mypy daemon: 2e.  The
remote cache will significantly speed up the first ‘dmypy check’ run
after starting or restarting the daemon.

The mypy daemon requires extra fine-grained dependency data in the cache
files which aren’t included by default.  To use caching with the mypy
daemon, use the *note –cache-fine-grained: 187. option in your CI build:

     $ mypy --cache-fine-grained <args...>

This flag adds extra information for the daemon to the cache.  In order
to use this extra information, you will also need to use the
‘--use-fine-grained-cache’ option with ‘dmypy start’ or ‘dmypy restart’.
Example:

     $ dmypy start -- --use-fine-grained-cache <options...>

Now your first ‘dmypy check’ run should be much faster, as it can use
cache information to avoid processing the whole program.


File: Mypy.info,  Node: Refinements,  Prev: Caching with mypy daemon,  Up: Using a remote cache to speed up mypy runs

1.33.3.5 Refinements
....................

There are several optional refinements that may improve things further,
at least if your codebase is hundreds of thousands of lines or more:

   * If the wrapper script determines that the merge base hasn’t changed
     from a previous run, there’s no need to download the cache data and
     it’s better to instead reuse the existing local cache data.

   * If you use the mypy daemon, you may want to restart the daemon each
     time after the merge base or local branch has changed to avoid
     processing a potentially large number of changes in an incremental
     build, as this can be much slower than downloading cache data and
     restarting the daemon.

   * If the current local branch is based on a very recent master
     commit, the remote cache data may not yet be available for that
     commit, as there will necessarily be some latency to build the
     cache files.  It may be a good idea to look for cache data for,
     say, the 5 latest master commits and use the most recent data that
     is available.

   * If the remote cache is not accessible for some reason (say, from a
     public network), the script can still fall back to a normal
     incremental build.

   * You can have multiple local cache directories for different local
     branches using the *note –cache-dir: 185. option.  If the user
     switches to an existing branch where downloaded cache data is
     already available, you can continue to use the existing cache data
     instead of redownloading the data.

   * You can set up your CI build to use a remote cache to speed up the
     CI build.  This would be particularly useful if each CI build
     starts from a fresh state without access to cache files from
     previous builds.  It’s still recommended to run a full,
     non-incremental mypy build to create the cache data, as repeatedly
     updating cache data incrementally could result in drift over a long
     time period (due to a mypy caching issue, perhaps).


File: Mypy.info,  Node: Extended Callable types,  Prev: Using a remote cache to speed up mypy runs,  Up: Additional features

1.33.4 Extended Callable types
------------------------------

     Note: This feature is deprecated.  You can use *note callback
     protocols: 5d. as a replacement.

As an experimental mypy extension, you can specify Callable(1) types
that support keyword arguments, optional arguments, and more.  When you
specify the arguments of a Callable(2), you can choose to supply just
the type of a nameless positional argument, or an “argument specifier”
representing a more complicated form of argument.  This allows one to
more closely emulate the full range of possibilities given by the ‘def’
statement in Python.

As an example, here’s a complicated function definition and the
corresponding Callable(3):

     from typing import Callable
     from mypy_extensions import (Arg, DefaultArg, NamedArg,
                                  DefaultNamedArg, VarArg, KwArg)

     def func(__a: int,  # This convention is for nameless arguments
              b: int,
              c: int = 0,
              *args: int,
              d: int,
              e: int = 0,
              **kwargs: int) -> int:
         ...

     F = Callable[[int,  # Or Arg(int)
                   Arg(int, 'b'),
                   DefaultArg(int, 'c'),
                   VarArg(int),
                   NamedArg(int, 'd'),
                   DefaultNamedArg(int, 'e'),
                   KwArg(int)],
                  int]

     f: F = func

Argument specifiers are special function calls that can specify the
following aspects of an argument:

   - its type (the only thing that the basic format supports)

   - its name (if it has one)

   - whether it may be omitted

   - whether it may or must be passed using a keyword

   - whether it is a ‘*args’ argument (representing the remaining
     positional arguments)

   - whether it is a ‘**kwargs’ argument (representing the remaining
     keyword arguments)

The following functions are available in ‘mypy_extensions’ for this
purpose:

     def Arg(type=Any, name=None):
         # A normal, mandatory, positional argument.
         # If the name is specified it may be passed as a keyword.

     def DefaultArg(type=Any, name=None):
         # An optional positional argument (i.e. with a default value).
         # If the name is specified it may be passed as a keyword.

     def NamedArg(type=Any, name=None):
         # A mandatory keyword-only argument.

     def DefaultNamedArg(type=Any, name=None):
         # An optional keyword-only argument (i.e. with a default value).

     def VarArg(type=Any):
         # A *args-style variadic positional argument.
         # A single VarArg() specifier represents all remaining
         # positional arguments.

     def KwArg(type=Any):
         # A **kwargs-style variadic keyword argument.
         # A single KwArg() specifier represents all remaining
         # keyword arguments.

In all cases, the ‘type’ argument defaults to ‘Any’, and if the ‘name’
argument is omitted the argument has no name (the name is required for
‘NamedArg’ and ‘DefaultNamedArg’).  A basic Callable(4) such as

     MyFunc = Callable[[int, str, int], float]

is equivalent to the following:

     MyFunc = Callable[[Arg(int), Arg(str), Arg(int)], float]

A Callable(5) with unspecified argument types, such as

     MyOtherFunc = Callable[..., int]

is (roughly) equivalent to

     MyOtherFunc = Callable[[VarArg(), KwArg()], int]

     Note: Each of the functions above currently just returns its ‘type’
     argument at runtime, so the information contained in the argument
     specifiers is not available at runtime.  This limitation is
     necessary for backwards compatibility with the existing ‘typing.py’
     module as present in the Python 3.5+ standard library and
     distributed via PyPI.

   ---------- Footnotes ----------

   (1) https://docs.python.org/3/library/typing.html#typing.Callable

   (2) https://docs.python.org/3/library/typing.html#typing.Callable

   (3) https://docs.python.org/3/library/typing.html#typing.Callable

   (4) https://docs.python.org/3/library/typing.html#typing.Callable

   (5) https://docs.python.org/3/library/typing.html#typing.Callable


File: Mypy.info,  Node: Frequently Asked Questions,  Prev: Additional features,  Up: Contents

1.34 Frequently Asked Questions
===============================

* Menu:

* Why have both dynamic and static typing?::
* Would my project benefit from static typing?::
* Can I use mypy to type check my existing Python code?::
* Will static typing make my programs run faster?::
* Is mypy free?::
* Can I use duck typing with mypy?::
* I like Python and I have no need for static typing::
* How are mypy programs different from normal Python?::
* How is mypy different from Cython?::
* Does it run on PyPy?::
* Mypy is a cool project. Can I help?: Mypy is a cool project Can I help?.


File: Mypy.info,  Node: Why have both dynamic and static typing?,  Next: Would my project benefit from static typing?,  Up: Frequently Asked Questions

1.34.1 Why have both dynamic and static typing?
-----------------------------------------------

Dynamic typing can be flexible, powerful, convenient and easy.  But it’s
not always the best approach; there are good reasons why many developers
choose to use statically typed languages or static typing for Python.

Here are some potential benefits of mypy-style static typing:

   - Static typing can make programs easier to understand and maintain.
     Type declarations can serve as machine-checked documentation.  This
     is important as code is typically read much more often than
     modified, and this is especially important for large and complex
     programs.

   - Static typing can help you find bugs earlier and with less testing
     and debugging.  Especially in large and complex projects this can
     be a major time-saver.

   - Static typing can help you find difficult-to-find bugs before your
     code goes into production.  This can improve reliability and reduce
     the number of security issues.

   - Static typing makes it practical to build very useful development
     tools that can improve programming productivity or software
     quality, including IDEs with precise and reliable code completion,
     static analysis tools, etc.

   - You can get the benefits of both dynamic and static typing in a
     single language.  Dynamic typing can be perfect for a small project
     or for writing the UI of your program, for example.  As your
     program grows, you can adapt tricky application logic to static
     typing to help maintenance.

See also the front page(1) of the mypy web site.

   ---------- Footnotes ----------

   (1) http://www.mypy-lang.org


File: Mypy.info,  Node: Would my project benefit from static typing?,  Next: Can I use mypy to type check my existing Python code?,  Prev: Why have both dynamic and static typing?,  Up: Frequently Asked Questions

1.34.2 Would my project benefit from static typing?
---------------------------------------------------

For many projects dynamic typing is perfectly fine (we think that Python
is a great language).  But sometimes your projects demand bigger guns,
and that’s when mypy may come in handy.

If some of these ring true for your projects, mypy (and static typing)
may be useful:

   - Your project is large or complex.

   - Your codebase must be maintained for a long time.

   - Multiple developers are working on the same code.

   - Running tests takes a lot of time or work (type checking helps you
     find errors quickly early in development, reducing the number of
     testing iterations).

   - Some project members (devs or management) don’t like dynamic
     typing, but others prefer dynamic typing and Python syntax.  Mypy
     could be a solution that everybody finds easy to accept.

   - You want to future-proof your project even if currently none of the
     above really apply.  The earlier you start, the easier it will be
     to adopt static typing.


File: Mypy.info,  Node: Can I use mypy to type check my existing Python code?,  Next: Will static typing make my programs run faster?,  Prev: Would my project benefit from static typing?,  Up: Frequently Asked Questions

1.34.3 Can I use mypy to type check my existing Python code?
------------------------------------------------------------

Mypy supports most Python features and idioms, and many large Python
projects are using mypy successfully.  Code that uses complex
introspection or metaprogramming may be impractical to type check, but
it should still be possible to use static typing in other parts of a
codebase that are less dynamic.


File: Mypy.info,  Node: Will static typing make my programs run faster?,  Next: Is mypy free?,  Prev: Can I use mypy to type check my existing Python code?,  Up: Frequently Asked Questions

1.34.4 Will static typing make my programs run faster?
------------------------------------------------------

Mypy only does static type checking and it does not improve performance.
It has a minimal performance impact.  In the future, there could be
other tools that can compile statically typed mypy code to C modules or
to efficient JVM bytecode, for example, but this is outside the scope of
the mypy project.


File: Mypy.info,  Node: Is mypy free?,  Next: Can I use duck typing with mypy?,  Prev: Will static typing make my programs run faster?,  Up: Frequently Asked Questions

1.34.5 Is mypy free?
--------------------

Yes.  Mypy is free software, and it can also be used for commercial and
proprietary projects.  Mypy is available under the MIT license.


File: Mypy.info,  Node: Can I use duck typing with mypy?,  Next: I like Python and I have no need for static typing,  Prev: Is mypy free?,  Up: Frequently Asked Questions

1.34.6 Can I use duck typing with mypy?
---------------------------------------

Mypy provides support for both nominal subtyping(1) and structural
subtyping(2).  Structural subtyping can be thought of as “static duck
typing”.  Some argue that structural subtyping is better suited for
languages with duck typing such as Python.  Mypy however primarily uses
nominal subtyping, leaving structural subtyping mostly opt-in (except
for built-in protocols such as Iterable(3) that always support
structural subtyping).  Here are some reasons why:

  1. It is easy to generate short and informative error messages when
     using a nominal type system.  This is especially important when
     using type inference.

  2. Python provides built-in support for nominal isinstance()(4) tests
     and they are widely used in programs.  Only limited support for
     structural isinstance()(5) is available, and it’s less type safe
     than nominal type tests.

  3. Many programmers are already familiar with static, nominal
     subtyping and it has been successfully used in languages such as
     Java, C++ and C#.  Fewer languages use structural subtyping.

However, structural subtyping can also be useful.  For example, a
“public API” may be more flexible if it is typed with protocols.  Also,
using protocol types removes the necessity to explicitly declare
implementations of ABCs.  As a rule of thumb, we recommend using nominal
classes where possible, and protocols where necessary.  For more details
about protocol types and structural subtyping see *note Protocols and
structural subtyping: 3a. and PEP 544(6).

   ---------- Footnotes ----------

   (1) https://en.wikipedia.org/wiki/Nominative_type_system

   (2) https://en.wikipedia.org/wiki/Structural_type_system

   (3) https://docs.python.org/3/library/typing.html#typing.Iterable

   (4) https://docs.python.org/3/library/functions.html#isinstance

   (5) https://docs.python.org/3/library/functions.html#isinstance

   (6) https://peps.python.org/pep-0544/


File: Mypy.info,  Node: I like Python and I have no need for static typing,  Next: How are mypy programs different from normal Python?,  Prev: Can I use duck typing with mypy?,  Up: Frequently Asked Questions

1.34.7 I like Python and I have no need for static typing
---------------------------------------------------------

The aim of mypy is not to convince everybody to write statically typed
Python – static typing is entirely optional, now and in the future.  The
goal is to give more options for Python programmers, to make Python a
more competitive alternative to other statically typed languages in
large projects, to improve programmer productivity, and to improve
software quality.


File: Mypy.info,  Node: How are mypy programs different from normal Python?,  Next: How is mypy different from Cython?,  Prev: I like Python and I have no need for static typing,  Up: Frequently Asked Questions

1.34.8 How are mypy programs different from normal Python?
----------------------------------------------------------

Since you use a vanilla Python implementation to run mypy programs, mypy
programs are also Python programs.  The type checker may give warnings
for some valid Python code, but the code is still always runnable.
Also, some Python features and syntax are still not supported by mypy,
but this is gradually improving.

The obvious difference is the availability of static type checking.  The
section *note Common issues and solutions: 1b. mentions some
modifications to Python code that may be required to make code type
check without errors.  Also, your code must make attributes explicit.

Mypy supports modular, efficient type checking, and this seems to rule
out type checking some language features, such as arbitrary monkey
patching of methods.


File: Mypy.info,  Node: How is mypy different from Cython?,  Next: Does it run on PyPy?,  Prev: How are mypy programs different from normal Python?,  Up: Frequently Asked Questions

1.34.9 How is mypy different from Cython?
-----------------------------------------

Cython(1) is a variant of Python that supports compilation to CPython C
modules.  It can give major speedups to certain classes of programs
compared to CPython, and it provides static typing (though this is
different from mypy).  Mypy differs in the following aspects, among
others:

   - Cython is much more focused on performance than mypy.  Mypy is only
     about static type checking, and increasing performance is not a
     direct goal.

   - The mypy syntax is arguably simpler and more “Pythonic” (no
     cdef/cpdef, etc.)  for statically typed code.

   - The mypy syntax is compatible with Python.  Mypy programs are
     normal Python programs that can be run using any Python
     implementation.  Cython has many incompatible extensions to Python
     syntax, and Cython programs generally cannot be run without first
     compiling them to CPython extension modules via C. Cython also has
     a pure Python mode, but it seems to support only a subset of Cython
     functionality, and the syntax is quite verbose.

   - Mypy has a different set of type system features.  For example,
     mypy has genericity (parametric polymorphism), function types and
     bidirectional type inference, which are not supported by Cython.
     (Cython has fused types that are different but related to mypy
     generics.  Mypy also has a similar feature as an extension of
     generics.)

   - The mypy type checker knows about the static types of many Python
     stdlib modules and can effectively type check code that uses them.

   - Cython supports accessing C functions directly and many features
     are defined in terms of translating them to C or C++.  Mypy just
     uses Python semantics, and mypy does not deal with accessing C
     library functionality.

   ---------- Footnotes ----------

   (1) http://docs.cython.org/en/latest/index.html


File: Mypy.info,  Node: Does it run on PyPy?,  Next: Mypy is a cool project Can I help?,  Prev: How is mypy different from Cython?,  Up: Frequently Asked Questions

1.34.10 Does it run on PyPy?
----------------------------

Somewhat.  With PyPy 3.8, mypy is at least able to type check itself.
With older versions of PyPy, mypy relies on typed-ast(1), which uses
several APIs that PyPy does not support (including some internal CPython
APIs).

   ---------- Footnotes ----------

   (1) https://github.com/python/typed_ast


File: Mypy.info,  Node: Mypy is a cool project Can I help?,  Prev: Does it run on PyPy?,  Up: Frequently Asked Questions

1.34.11 Mypy is a cool project. Can I help?
-------------------------------------------

Any help is much appreciated!  Contact(1) the developers if you would
like to contribute.  Any help related to development, design, publicity,
documentation, testing, web site maintenance, financing, etc.  can be
helpful.  You can learn a lot by contributing, and anybody can help,
even beginners!  However, some knowledge of compilers and/or type
systems is essential if you want to work on mypy internals.

   ---------- Footnotes ----------

   (1) http://www.mypy-lang.org/contact.html


File: Mypy.info,  Node: Indices and tables,  Next: Index,  Prev: Contents,  Up: Top

Indices and tables
******************

   * genindex

   * search


File: Mypy.info,  Node: Index,  Prev: Indices and tables,  Up: Top

Index
*****

 [index ]
* Menu:

* allow_redefinition; configuration value: Miscellaneous strictness flags<2>.
                                                              (line  20)
* allow_untyped_globals; configuration value: Miscellaneous strictness flags<2>.
                                                              (line   9)
* always_false; configuration value:     Platform configuration<2>.
                                                              (line  38)
* always_true; configuration value:      Platform configuration<2>.
                                                              (line  30)
* any_exprs_report; configuration value: Report generation<2>.
                                                              (line   9)
* cache_dir; configuration value:        Incremental mode<2>. (line  18)
* cache_fine_grained; configuration value: Incremental mode<2>.
                                                              (line  45)
* check_untyped_defs; configuration value: Untyped definitions and calls<2>.
                                                              (line  41)
* cobertura_xml_report; configuration value: Report generation<2>.
                                                              (line  17)
* color_output; configuration value:     Configuring error messages<2>.
                                                              (line  53)
* custom_typeshed_dir; configuration value: Advanced options<2>.
                                                              (line  54)
* custom_typing_module; configuration value: Advanced options<2>.
                                                              (line  46)
* disable_error_code; configuration value: Miscellaneous strictness flags<2>.
                                                              (line  57)
* disallow_any_decorated; configuration value: Disallow dynamic typing<2>.
                                                              (line  31)
* disallow_any_explicit; configuration value: Disallow dynamic typing<2>.
                                                              (line  42)
* disallow_any_expr; configuration value: Disallow dynamic typing<2>.
                                                              (line  21)
* disallow_any_generics; configuration value: Disallow dynamic typing<2>.
                                                              (line  53)
* disallow_any_unimported; configuration value: Disallow dynamic typing<2>.
                                                              (line   9)
* disallow_incomplete_defs; configuration value: Untyped definitions and calls<2>.
                                                              (line  31)
* disallow_subclassing_any; configuration value: Disallow dynamic typing<2>.
                                                              (line  64)
* disallow_untyped_calls; configuration value: Untyped definitions and calls<2>.
                                                              (line   9)
* disallow_untyped_decorators; configuration value: Untyped definitions and calls<2>.
                                                              (line  51)
* disallow_untyped_defs; configuration value: Untyped definitions and calls<2>.
                                                              (line  20)
* dmypy command line option; –callsites: Static inference of annotations.
                                                              (line  76)
* dmypy command line option; –export-types: Additional daemon flags.
                                                              (line  62)
* dmypy command line option; –flex-any:  Static inference of annotations.
                                                              (line  70)
* dmypy command line option; –force-reload: Statically inspect expressions.
                                                              (line 123)
* dmypy command line option; –fswatcher-dump-file: Additional daemon flags.
                                                              (line  48)
* dmypy command line option; –include-kind: Statically inspect expressions.
                                                              (line  89)
* dmypy command line option; –include-object-attrs: Statically inspect expressions.
                                                              (line  97)
* dmypy command line option; –include-span: Statically inspect expressions.
                                                              (line  82)
* dmypy command line option; –json:      Static inference of annotations.
                                                              (line  46)
* dmypy command line option; –limit:     Statically inspect expressions.
                                                              (line  66)
* dmypy command line option; –log-file:  Additional daemon flags.
                                                              (line  13)
* dmypy command line option; –max-guesses: Static inference of annotations.
                                                              (line  89)
* dmypy command line option; –no-any:    Static inference of annotations.
                                                              (line  64)
* dmypy command line option; –no-errors: Static inference of annotations.
                                                              (line  58)
* dmypy command line option; –perf-stats-file: Additional daemon flags.
                                                              (line  57)
* dmypy command line option; –remove:    Additional daemon flags.
                                                              (line  40)
* dmypy command line option; –show:      Statically inspect expressions.
                                                              (line  38)
* dmypy command line option; –status-file: Additional daemon flags.
                                                              (line   6)
* dmypy command line option; –timeout:   Additional daemon flags.
                                                              (line  20)
* dmypy command line option; –union-attrs: Statically inspect expressions.
                                                              (line 102)
* dmypy command line option; –update:    Additional daemon flags.
                                                              (line  26)
* dmypy command line option; –use-fixme: Static inference of annotations.
                                                              (line  83)
* dmypy command line option; –verbose:   Statically inspect expressions.
                                                              (line  59)
* enable_error_code; configuration value: Miscellaneous strictness flags<2>.
                                                              (line  64)
* error_summary; configuration value:    Configuring error messages<2>.
                                                              (line  63)
* exclude; configuration value:          Import discovery<2>. (line  44)
* explicit_package_bases; configuration value: Import discovery<2>.
                                                              (line 111)
* files; configuration value:            Import discovery<2>. (line  30)
* follow_imports; configuration value:   Import discovery<2>. (line 141)
* follow_imports_for_stubs; configuration value: Import discovery<2>.
                                                              (line 165)
* hide_error_codes; configuration value: Configuring error messages<2>.
                                                              (line  31)
* html_report / xslt_html_report; configuration value: Report generation<2>.
                                                              (line  29)
* ignore_errors; configuration value:    Suppressing errors.  (line   9)
* ignore_missing_imports; configuration value: Import discovery<2>.
                                                              (line 127)
* implicit_optional; configuration value: None and Optional handling<2>.
                                                              (line   9)
* implicit_reexport; configuration value: Miscellaneous strictness flags<2>.
                                                              (line  74)
* incremental; configuration value:      Incremental mode<2>. (line   8)
* junit_xml; configuration value:        Miscellaneous<3>.    (line   8)
* linecount_report; configuration value: Report generation<2>.
                                                              (line  40)
* linecoverage_report; configuration value: Report generation<2>.
                                                              (line  49)
* lineprecision_report; configuration value: Report generation<2>.
                                                              (line  58)
* local_partial_types; configuration value: Miscellaneous strictness flags<2>.
                                                              (line  45)
* mypy command line option; –allow-redefinition: Miscellaneous strictness flags.
                                                              (line  14)
* mypy command line option; –allow-untyped-globals: Miscellaneous strictness flags.
                                                              (line   9)
* mypy command line option; –always-false: Platform configuration.
                                                              (line  37)
* mypy command line option; –always-true: Platform configuration.
                                                              (line  32)
* mypy command line option; –any-exprs-report: Report generation.
                                                              (line   9)
* mypy command line option; -c:          Specifying what to type check.
                                                              (line  34)
* mypy command line option; –cache-dir:  Incremental mode.    (line  25)
* mypy command line option; –cache-fine-grained: Incremental mode.
                                                              (line  44)
* mypy command line option; –check-untyped-defs: Untyped definitions and calls.
                                                              (line  24)
* mypy command line option; –cobertura-xml-report: Report generation.
                                                              (line  14)
* mypy command line option; –command:    Specifying what to type check.
                                                              (line  34)
* mypy command line option; –config-file: Config file.        (line   6)
* mypy command line option; –custom-typeshed-dir: Advanced options.
                                                              (line  28)
* mypy command line option; –custom-typing-module: Advanced options.
                                                              (line  23)
* mypy command line option; –disable-error-code: Miscellaneous strictness flags.
                                                              (line 110)
* mypy command line option; –disallow-any-decorated: Disallow dynamic typing.
                                                              (line  32)
* mypy command line option; –disallow-any-explicit: Disallow dynamic typing.
                                                              (line  37)
* mypy command line option; –disallow-any-expr: Disallow dynamic typing.
                                                              (line  20)
* mypy command line option; –disallow-any-generics: Disallow dynamic typing.
                                                              (line  42)
* mypy command line option; –disallow-any-unimported: Disallow dynamic typing.
                                                              (line  13)
* mypy command line option; –disallow-incomplete-defs: Untyped definitions and calls.
                                                              (line  19)
* mypy command line option; –disallow-subclassing-any: Disallow dynamic typing.
                                                              (line  49)
* mypy command line option; –disallow-untyped-calls: Untyped definitions and calls.
                                                              (line   9)
* mypy command line option; –disallow-untyped-decorators: Untyped definitions and calls.
                                                              (line  34)
* mypy command line option; –disallow-untyped-defs: Untyped definitions and calls.
                                                              (line  14)
* mypy command line option; –enable-error-code: Miscellaneous strictness flags.
                                                              (line 123)
* mypy command line option; –exclude:    Specifying what to type check.
                                                              (line  38)
* mypy command line option; –explicit-package-bases: Import discovery.
                                                              (line   9)
* mypy command line option; –fast-module-lookup: Import discovery.
                                                              (line  75)
* mypy command line option; –find-occurrences: Miscellaneous<2>.
                                                              (line  47)
* mypy command line option; –follow-imports: Import discovery.
                                                              (line  41)
* mypy command line option; -h:          Optional arguments.  (line   6)
* mypy command line option; –help:       Optional arguments.  (line   6)
* mypy command line option; –hide-error-codes: Configuring error messages.
                                                              (line  44)
* mypy command line option; –html-report: Report generation.  (line  23)
* mypy command line option; –ignore-missing-imports: Import discovery.
                                                              (line  17)
* mypy command line option; –implicit-optional: None and Optional handling.
                                                              (line   7)
* mypy command line option; –install-types: Miscellaneous<2>. (line   6)
* mypy command line option; –junit-xml:  Miscellaneous<2>.    (line  41)
* mypy command line option; –linecount-report: Report generation.
                                                              (line  31)
* mypy command line option; –linecoverage-report: Report generation.
                                                              (line  37)
* mypy command line option; –lineprecision-report: Report generation.
                                                              (line  43)
* mypy command line option; –local-partial-types: Miscellaneous strictness flags.
                                                              (line  35)
* mypy command line option; -m:          Specifying what to type check.
                                                              (line  17)
* mypy command line option; –module:     Specifying what to type check.
                                                              (line  17)
* mypy command line option; –no-color-output: Configuring error messages.
                                                              (line  58)
* mypy command line option; –no-error-summary: Configuring error messages.
                                                              (line  63)
* mypy command line option; –no-implicit-reexport: Miscellaneous strictness flags.
                                                              (line  62)
* mypy command line option; –no-incremental: Incremental mode.
                                                              (line  16)
* mypy command line option; –no-namespace-packages: Import discovery.
                                                              (line  99)
* mypy command line option; –no-silence-site-packages: Import discovery.
                                                              (line  69)
* mypy command line option; –no-site-packages: Import discovery.
                                                              (line  60)
* mypy command line option; –no-strict-optional: None and Optional handling.
                                                              (line  22)
* mypy command line option; –no-warn-no-return: Configuring warnings.
                                                              (line  29)
* mypy command line option; –non-interactive: Miscellaneous<2>.
                                                              (line  27)
* mypy command line option; -p:          Specifying what to type check.
                                                              (line  25)
* mypy command line option; –package:    Specifying what to type check.
                                                              (line  25)
* mypy command line option; –pdb:        Advanced options.    (line   9)
* mypy command line option; –platform:   Platform configuration.
                                                              (line  24)
* mypy command line option; –pretty:     Configuring error messages.
                                                              (line  53)
* mypy command line option; –python-executable: Import discovery.
                                                              (line  50)
* mypy command line option; –python-version: Platform configuration.
                                                              (line  13)
* mypy command line option; –raise-exceptions: Advanced options.
                                                              (line  19)
* mypy command line option; –scripts-are-modules: Miscellaneous<2>.
                                                              (line  52)
* mypy command line option; –shadow-file: Advanced options.   (line  54)
* mypy command line option; –show-absolute-path: Configuring error messages.
                                                              (line  69)
* mypy command line option; –show-column-numbers: Configuring error messages.
                                                              (line  28)
* mypy command line option; –show-error-context: Configuring error messages.
                                                              (line   9)
* mypy command line option; –show-error-end: Configuring error messages.
                                                              (line  36)
* mypy command line option; –show-traceback: Advanced options.
                                                              (line  14)
* mypy command line option; –skip-cache-mtime-checks: Incremental mode.
                                                              (line  54)
* mypy command line option; –skip-version-check: Incremental mode.
                                                              (line  49)
* mypy command line option; –soft-error-limit: Configuring error messages.
                                                              (line  73)
* mypy command line option; –sqlite-cache: Incremental mode.  (line  40)
* mypy command line option; –strict:     Miscellaneous strictness flags.
                                                              (line 101)
* mypy command line option; –strict-equality: Miscellaneous strictness flags.
                                                              (line  83)
* mypy command line option; –tb:         Advanced options.    (line  14)
* mypy command line option; –txt-report: Report generation.   (line  48)
* mypy command line option; -v:          Optional arguments.  (line  10)
* mypy command line option; -V:          Optional arguments.  (line  14)
* mypy command line option; –verbose:    Optional arguments.  (line  10)
* mypy command line option; –version:    Optional arguments.  (line  14)
* mypy command line option; –warn-incomplete-stub: Advanced options.
                                                              (line  38)
* mypy command line option; –warn-redundant-casts: Configuring warnings.
                                                              (line   9)
* mypy command line option; –warn-return-any: Configuring warnings.
                                                              (line  43)
* mypy command line option; –warn-unreachable: Configuring warnings.
                                                              (line  49)
* mypy command line option; –warn-unused-configs: Config file.
                                                              (line  22)
* mypy command line option; –warn-unused-ignores: Configuring warnings.
                                                              (line  14)
* mypy command line option; –xml-report: Report generation.   (line  56)
* mypy_path; configuration value:        Import discovery<2>. (line   9)
* namespace_packages; configuration value: Import discovery<2>.
                                                              (line  98)
* no_silence_site_packages; configuration value: Import discovery<2>.
                                                              (line 210)
* no_site_packages; configuration value: Import discovery<2>. (line 197)
* pdb; configuration value:              Advanced options<2>. (line  16)
* platform; configuration value:         Platform configuration<2>.
                                                              (line  18)
* plugins; configuration value:          Advanced options<2>. (line   8)
* pretty; configuration value:           Configuring error messages<2>.
                                                              (line  42)
* Python Enhancement Proposals; PEP 420: Import discovery.    (line 101)
* Python Enhancement Proposals; PEP 420 <1>: Import discovery<2>.
                                                              (line 106)
* Python Enhancement Proposals; PEP 484: Top.                 (line  16)
* Python Enhancement Proposals; PEP 484 <1>: Extending mypy using plugins.
                                                              (line   9)
* Python Enhancement Proposals; PEP 484 <2>: Extending mypy using plugins.
                                                              (line  15)
* Python Enhancement Proposals; PEP 484 <3>: Current list of plugin hooks.
                                                              (line   7)
* Python Enhancement Proposals; PEP 484 <4>: Automatic stub generation stubgen.
                                                              (line   6)
* Python Enhancement Proposals; PEP 484#function-method-overloading: Function overloading.
                                                              (line  33)
* Python Enhancement Proposals; PEP 484#the-type-of-class-objects: The type of class objects.
                                                              (line   6)
* Python Enhancement Proposals; PEP 484#the-type-of-class-objects <1>: The type of class objects.
                                                              (line  71)
* Python Enhancement Proposals; PEP 484#type-aliases: Generic type aliases.
                                                              (line  11)
* Python Enhancement Proposals; PEP 492: Typing async/await.  (line   8)
* Python Enhancement Proposals; PEP 508: Using new additions to the typing module.
                                                              (line  27)
* Python Enhancement Proposals; PEP 526: Local type inference.
                                                              (line  39)
* Python Enhancement Proposals; PEP 544: Protocols and structural subtyping.
                                                              (line  19)
* Python Enhancement Proposals; PEP 544 <1>: Can I use duck typing with mypy?.
                                                              (line  33)
* Python Enhancement Proposals; PEP 544#generic-protocols: Generic protocols.
                                                              (line  37)
* Python Enhancement Proposals; PEP 557: Dataclasses.         (line  57)
* Python Enhancement Proposals; PEP 561: Creating a stub.     (line  21)
* Python Enhancement Proposals; PEP 561 <1>: How imports are found.
                                                              (line  27)
* Python Enhancement Proposals; PEP 561 <2>: Import discovery.
                                                              (line  52)
* Python Enhancement Proposals; PEP 561 <3>: Import discovery.
                                                              (line  62)
* Python Enhancement Proposals; PEP 561 <4>: Import discovery.
                                                              (line  71)
* Python Enhancement Proposals; PEP 561 <5>: Platform configuration.
                                                              (line  20)
* Python Enhancement Proposals; PEP 561 <6>: Import discovery<2>.
                                                              (line 205)
* Python Enhancement Proposals; PEP 561 <7>: Import discovery<2>.
                                                              (line 219)
* Python Enhancement Proposals; PEP 561 <8>: Using installed packages.
                                                              (line  20)
* Python Enhancement Proposals; PEP 561 <9>: Creating PEP 561 compatible packages.
                                                              (line  10)
* Python Enhancement Proposals; PEP 561#stub-only-packages: Using installed packages with mypy PEP 561.
                                                              (line  32)
* Python Enhancement Proposals; PEP 563: Annotation issues at runtime.
                                                              (line  11)
* Python Enhancement Proposals; PEP 563 <1>: Future annotations import PEP 563.
                                                              (line  15)
* Python Enhancement Proposals; PEP 585: Using generic builtins.
                                                              (line   6)
* Python Enhancement Proposals; PEP 604: X | Y syntax for Unions.
                                                              (line   6)
* Python Enhancement Proposals; PEP 604 <1>: Future annotations import PEP 563.
                                                              (line  38)
* Python Enhancement Proposals; PEP 604 <2>: Using X | Y syntax for Unions.
                                                              (line   6)
* Python Enhancement Proposals; PEP 613: Type aliases.        (line  27)
* Python Enhancement Proposals; PEP 613 <1>: Variables vs type aliases.
                                                              (line  22)
* Python Enhancement Proposals; PEP 647: User-Defined Type Guards.
                                                              (line   6)
* python_executable; configuration value: Import discovery<2>.
                                                              (line 185)
* python_version; configuration value:   Platform configuration<2>.
                                                              (line   6)
* raise_exceptions; configuration value: Advanced options<2>. (line  36)
* scripts_are_modules; configuration value: Miscellaneous<3>. (line  17)
* show_absolute_path; configuration value: Configuring error messages<2>.
                                                              (line  73)
* show_column_numbers; configuration value: Configuring error messages<2>.
                                                              (line  21)
* show_error_context; configuration value: Configuring error messages<2>.
                                                              (line  11)
* show_traceback; configuration value:   Advanced options<2>. (line  26)
* skip_cache_mtime_checks; configuration value: Incremental mode<2>.
                                                              (line  69)
* skip_version_check; configuration value: Incremental mode<2>.
                                                              (line  56)
* sqlite_cache; configuration value:     Incremental mode<2>. (line  35)
* strict; configuration value:           Miscellaneous strictness flags<2>.
                                                              (line 118)
* strict_concatenate; configuration value: Miscellaneous strictness flags<2>.
                                                              (line  96)
* strict_equality; configuration value:  Miscellaneous strictness flags<2>.
                                                              (line 107)
* strict_optional; configuration value:  None and Optional handling<2>.
                                                              (line  23)
* stubgen command line option; –doc-dir: Specifying how to generate stubs.
                                                              (line  33)
* stubgen command line option; –export-less: Additional flags.
                                                              (line  22)
* stubgen command line option; -h:       Additional flags.    (line   6)
* stubgen command line option; –help:    Additional flags.    (line   6)
* stubgen command line option; –ignore-errors: Additional flags.
                                                              (line  10)
* stubgen command line option; –include-private: Additional flags.
                                                              (line  16)
* stubgen command line option; -m:       Specifying what to stub.
                                                              (line  26)
* stubgen command line option; –module:  Specifying what to stub.
                                                              (line  26)
* stubgen command line option; –no-import: Specifying how to generate stubs.
                                                              (line  13)
* stubgen command line option; -o:       Additional flags.    (line  33)
* stubgen command line option; –output:  Additional flags.    (line  33)
* stubgen command line option; -p:       Specifying what to stub.
                                                              (line  34)
* stubgen command line option; –package: Specifying what to stub.
                                                              (line  34)
* stubgen command line option; –parse-only: Specifying how to generate stubs.
                                                              (line  25)
* stubgen command line option; -q:       Additional flags.    (line  44)
* stubgen command line option; –quiet:   Additional flags.    (line  44)
* stubgen command line option; –search-path: Additional flags.
                                                              (line  28)
* stubgen command line option; -v:       Additional flags.    (line  40)
* stubgen command line option; –verbose: Additional flags.    (line  40)
* stubtest command line option; –allowlist: Usage.            (line  45)
* stubtest command line option; –check-typeshed: Usage.       (line  68)
* stubtest command line option; –concise: Usage.              (line  32)
* stubtest command line option; –custom-typeshed-dir: Usage.  (line  64)
* stubtest command line option; –generate-allowlist: Usage.   (line  51)
* stubtest command line option; –help:   Usage.               (line  72)
* stubtest command line option; –ignore-missing-stub: Usage.  (line  36)
* stubtest command line option; –ignore-positional-only: Usage.
                                                              (line  40)
* stubtest command line option; –ignore-unused-allowlist: Usage.
                                                              (line  55)
* stubtest command line option; –mypy-config-file: Usage.     (line  59)
* txt_report / xslt_txt_report; configuration value: Report generation<2>.
                                                              (line  66)
* verbosity; configuration value:        Miscellaneous<3>.    (line  40)
* warn_incomplete_stub; configuration value: Advanced options<2>.
                                                              (line  70)
* warn_no_return; configuration value:   Configuring warnings<2>.
                                                              (line  31)
* warn_redundant_casts; configuration value: Configuring warnings<2>.
                                                              (line   9)
* warn_return_any; configuration value:  Configuring warnings<2>.
                                                              (line  41)
* warn_unreachable; configuration value: Configuring warnings<2>.
                                                              (line  52)
* warn_unused_configs; configuration value: Miscellaneous<3>. (line  28)
* warn_unused_ignores; configuration value: Configuring warnings<2>.
                                                              (line  21)
* xml_report; configuration value:       Report generation<2>.
                                                              (line  77)



Tag Table:
Node: Top387
Ref: index doc646
Ref: 0646
Ref: Top-Footnote-115775
Node: Contents15817
Ref: index contents15902
Ref: 115902
Ref: index welcome-to-mypy-documentation15902
Ref: 215902
Node: Getting started17007
Ref: getting_started doc17110
Ref: 317110
Ref: getting_started getting-started17110
Ref: 417110
Ref: getting_started id117110
Ref: 517110
Ref: Getting started-Footnote-117896
Node: Installing and running mypy17964
Ref: getting_started installing-and-running-mypy18098
Ref: 718098
Node: Function signatures and dynamic vs static typing19116
Ref: getting_started function-signatures-and-dynamic-vs-static-typing19283
Ref: 819283
Node: More function signatures21495
Ref: getting_started more-function-signatures21673
Ref: b21673
Node: Additional types and the typing module22970
Ref: getting_started additional-types-and-the-typing-module23120
Ref: c23120
Ref: Additional types and the typing module-Footnote-127162
Ref: Additional types and the typing module-Footnote-227223
Ref: Additional types and the typing module-Footnote-327284
Ref: Additional types and the typing module-Footnote-427350
Ref: Additional types and the typing module-Footnote-527418
Ref: Additional types and the typing module-Footnote-627486
Ref: Additional types and the typing module-Footnote-727575
Ref: Additional types and the typing module-Footnote-827645
Ref: Additional types and the typing module-Footnote-927706
Ref: Additional types and the typing module-Footnote-1027773
Ref: Additional types and the typing module-Footnote-1127841
Ref: Additional types and the typing module-Footnote-1227910
Ref: Additional types and the typing module-Footnote-1327979
Ref: Additional types and the typing module-Footnote-1428067
Node: Local type inference28138
Ref: getting_started local-type-inference28281
Ref: e28281
Ref: Local type inference-Footnote-130222
Ref: Local type inference-Footnote-230290
Node: Types and classes30332
Ref: getting_started types-and-classes30461
Ref: f30461
Node: Stubs files and typeshed33392
Ref: getting_started stubs-files-and-typeshed33517
Ref: 1133517
Ref: getting_started stubs-intro33517
Ref: 1233517
Ref: Stubs files and typeshed-Footnote-135831
Ref: Stubs files and typeshed-Footnote-235886
Node: Configuring mypy35929
Ref: getting_started configuring-mypy36047
Ref: 1736047
Node: Next steps37122
Ref: getting_started next-steps37207
Ref: 1a37207
Ref: Next steps-Footnote-138305
Ref: Next steps-Footnote-238379
Ref: Next steps-Footnote-338431
Ref: Next steps-Footnote-438483
Ref: Next steps-Footnote-538529
Node: Using mypy with an existing codebase38569
Ref: existing_code doc38703
Ref: 1c38703
Ref: existing_code existing-code38703
Ref: 1938703
Ref: existing_code using-mypy-with-an-existing-codebase38703
Ref: 1d38703
Node: Start small39298
Ref: existing_code start-small39434
Ref: 1e39434
Node: Run mypy consistently and prevent regressions40066
Ref: existing_code run-mypy-consistently-and-prevent-regressions40247
Ref: 1f40247
Node: Ignoring errors from certain modules41473
Ref: existing_code ignoring-errors-from-certain-modules41675
Ref: 2241675
Node: Fixing errors related to imports42572
Ref: existing_code fixing-errors-related-to-imports42774
Ref: 2442774
Node: Prioritise annotating widely imported modules44804
Ref: existing_code prioritise-annotating-widely-imported-modules44997
Ref: 2744997
Node: Write annotations as you go45582
Ref: existing_code write-annotations-as-you-go45777
Ref: 2845777
Node: Automate annotation of legacy code46156
Ref: existing_code automate-annotation-of-legacy-code46332
Ref: 2946332
Ref: Automate annotation of legacy code-Footnote-147019
Ref: Automate annotation of legacy code-Footnote-247082
Ref: Automate annotation of legacy code-Footnote-347134
Node: Introduce stricter options47180
Ref: existing_code introduce-stricter-options47347
Ref: 2a47347
Node: Speed up mypy runs49794
Ref: existing_code speed-up-mypy-runs49918
Ref: 2d49918
Node: Type hints cheat sheet50241
Ref: cheat_sheet_py3 doc50374
Ref: 3050374
Ref: cheat_sheet_py3 autotyping50374
Ref: 3150374
Ref: cheat_sheet_py3 cheat-sheet-py350374
Ref: 650374
Ref: cheat_sheet_py3 type-hints-cheat-sheet50374
Ref: 3250374
Node: Variables50762
Ref: cheat_sheet_py3 variables50858
Ref: 3350858
Node: Useful built-in types51431
Ref: cheat_sheet_py3 useful-built-in-types51545
Ref: 3551545
Node: Functions52981
Ref: cheat_sheet_py3 functions53138
Ref: 3653138
Node: When you’re puzzled or when things are complicated55120
Ref: cheat_sheet_py3 when-you-re-puzzled-or-when-things-are-complicated55281
Ref: 3755281
Node: Standard “duck types”57339
Ref: cheat_sheet_py3 standard-duck-types57498
Ref: 3957498
Node: Classes58889
Ref: cheat_sheet_py3 classes59018
Ref: 3b59018
Node: Coroutines and asyncio60727
Ref: cheat_sheet_py3 coroutines-and-asyncio60844
Ref: 3c60844
Node: Miscellaneous61295
Ref: cheat_sheet_py3 miscellaneous61415
Ref: 3e61415
Node: Decorators62385
Ref: cheat_sheet_py3 decorators62474
Ref: 3f62474
Ref: index overview-type-system-reference62834
Ref: d62834
Node: Built-in types62835
Ref: builtin_types doc62967
Ref: 4162967
Ref: builtin_types built-in-types62967
Ref: 4262967
Node: Simple types63172
Ref: builtin_types simple-types63250
Ref: 4363250
Node: Any type64266
Ref: builtin_types any-type64366
Ref: 4464366
Ref: Any type-Footnote-164915
Node: Generic types64983
Ref: builtin_types generic-types65062
Ref: 4665062
Ref: Generic types-Footnote-169003
Ref: Generic types-Footnote-269090
Ref: Generic types-Footnote-369158
Ref: Generic types-Footnote-469226
Node: Type inference and type annotations69313
Ref: type_inference_and_annotations doc69437
Ref: 4869437
Ref: type_inference_and_annotations type-inference-and-annotations69437
Ref: 3469437
Ref: type_inference_and_annotations type-inference-and-type-annotations69437
Ref: 4969437
Node: Type inference69708
Ref: type_inference_and_annotations type-inference69829
Ref: 4a69829
Node: Explicit types for variables70720
Ref: type_inference_and_annotations explicit-types-for-variables70880
Ref: 4b70880
Ref: type_inference_and_annotations explicit-var-types70880
Ref: 4c70880
Ref: Explicit types for variables-Footnote-172207
Node: Explicit types for collections72273
Ref: type_inference_and_annotations explicit-types-for-collections72451
Ref: 4e72451
Ref: Explicit types for collections-Footnote-173372
Ref: Explicit types for collections-Footnote-273433
Ref: Explicit types for collections-Footnote-373494
Ref: Explicit types for collections-Footnote-473556
Ref: Explicit types for collections-Footnote-573616
Ref: Explicit types for collections-Footnote-673682
Node: Compatibility of container types73748
Ref: type_inference_and_annotations compatibility-of-container-types73923
Ref: 4f73923
Ref: Compatibility of container types-Footnote-175145
Ref: Compatibility of container types-Footnote-275206
Node: Context in type inference75266
Ref: type_inference_and_annotations context-in-type-inference75432
Ref: 5175432
Node: Silencing type errors76861
Ref: type_inference_and_annotations silencing-type-errors76986
Ref: 5276986
Node: Kinds of types79233
Ref: kinds_of_types doc79355
Ref: 5479355
Ref: kinds_of_types kinds-of-types79355
Ref: 5579355
Node: Class types79896
Ref: kinds_of_types class-types79977
Ref: 5679977
Ref: Class types-Footnote-180797
Node: The Any type80861
Ref: kinds_of_types the-any-type80962
Ref: 5780962
Node: Tuple types83330
Ref: kinds_of_types id183446
Ref: 5883446
Ref: kinds_of_types tuple-types83446
Ref: 5983446
Ref: Tuple types-Footnote-184770
Node: Callable types and lambdas84840
Ref: kinds_of_types callable-types84955
Ref: 5b84955
Ref: kinds_of_types callable-types-and-lambdas84955
Ref: 5c84955
Node: Union types86951
Ref: kinds_of_types id287087
Ref: 5e87087
Ref: kinds_of_types union-types87087
Ref: 5f87087
Ref: Union types-Footnote-188411
Ref: Union types-Footnote-288479
Ref: Union types-Footnote-388547
Node: Optional types and the None type88615
Ref: kinds_of_types optional-types-and-the-none-type88759
Ref: 6188759
Ref: kinds_of_types strict-optional88759
Ref: 6288759
Ref: Optional types and the None type-Footnote-193408
Ref: Optional types and the None type-Footnote-293478
Ref: Optional types and the None type-Footnote-393548
Node: X | Y syntax for Unions93616
Ref: kinds_of_types alternative-union-syntax93706
Ref: 6393706
Ref: kinds_of_types x-y-syntax-for-unions93706
Ref: 6493706
Ref: X | Y syntax for Unions-Footnote-194230
Node: Disabling strict optional checking94272
Ref: kinds_of_types disabling-strict-optional-checking94417
Ref: 6594417
Ref: kinds_of_types no-strict-optional94417
Ref: 6694417
Ref: Disabling strict optional checking-Footnote-196751
Ref: Disabling strict optional checking-Footnote-296821
Node: Type aliases96891
Ref: kinds_of_types id397016
Ref: 6997016
Ref: kinds_of_types type-aliases97016
Ref: 6a97016
Ref: Type aliases-Footnote-198561
Node: Named tuples98603
Ref: kinds_of_types id498719
Ref: 6c98719
Ref: kinds_of_types named-tuples98719
Ref: 5a98719
Ref: Named tuples-Footnote-1100633
Ref: Named tuples-Footnote-2100716
Node: The type of class objects100788
Ref: kinds_of_types the-type-of-class-objects100902
Ref: 6d100902
Ref: kinds_of_types type-of-class100902
Ref: 6e100902
Ref: The type of class objects-Footnote-1103450
Ref: The type of class objects-Footnote-2103518
Ref: The type of class objects-Footnote-3103584
Ref: The type of class objects-Footnote-4103650
Node: Generators103718
Ref: kinds_of_types generators103811
Ref: 70103811
Ref: kinds_of_types id5103811
Ref: 71103811
Ref: Generators-Footnote-1106016
Ref: Generators-Footnote-2106086
Ref: Generators-Footnote-3106156
Ref: Generators-Footnote-4106226
Ref: Generators-Footnote-5106296
Ref: Generators-Footnote-6106358
Ref: Generators-Footnote-7106435
Ref: Generators-Footnote-8106506
Ref: Generators-Footnote-9106577
Ref: Generators-Footnote-10106655
Ref: Generators-Footnote-11106733
Ref: Generators-Footnote-12106812
Ref: Generators-Footnote-13106884
Ref: Generators-Footnote-14106955
Node: Class basics107026
Ref: class_basics doc107141
Ref: 72107141
Ref: class_basics class-basics107141
Ref: 10107141
Ref: class_basics id1107141
Ref: 73107141
Node: Instance and class attributes107515
Ref: class_basics instance-and-class-attributes107627
Ref: 74107627
Ref: Instance and class attributes-Footnote-1109283
Ref: Instance and class attributes-Footnote-2109360
Node: Annotating __init__ methods109430
Ref: class_basics annotating-init-methods109578
Ref: 75109578
Ref: Annotating __init__ methods-Footnote-1110453
Ref: Annotating __init__ methods-Footnote-2110529
Ref: Annotating __init__ methods-Footnote-3110605
Ref: Annotating __init__ methods-Footnote-4110681
Node: Class attribute annotations110757
Ref: class_basics class-attribute-annotations110911
Ref: 76110911
Ref: Class attribute annotations-Footnote-1113026
Ref: Class attribute annotations-Footnote-2113096
Ref: Class attribute annotations-Footnote-3113166
Ref: Class attribute annotations-Footnote-4113236
Ref: Class attribute annotations-Footnote-5113306
Ref: Class attribute annotations-Footnote-6113374
Ref: Class attribute annotations-Footnote-7113442
Ref: Class attribute annotations-Footnote-8113512
Ref: Class attribute annotations-Footnote-9113582
Node: Overriding statically typed methods113652
Ref: class_basics overriding-statically-typed-methods113825
Ref: 78113825
Node: Abstract base classes and multiple inheritance115730
Ref: class_basics abstract-base-classes-and-multiple-inheritance115881
Ref: 79115881
Ref: Abstract base classes and multiple inheritance-Footnote-1119513
Ref: Abstract base classes and multiple inheritance-Footnote-2119576
Ref: Abstract base classes and multiple inheritance-Footnote-3119646
Node: Slots119709
Ref: class_basics slots119816
Ref: 7a119816
Ref: Slots-Footnote-1120878
Node: Annotation issues at runtime120943
Ref: runtime_troubles doc121078
Ref: 7b121078
Ref: runtime_troubles annotation-issues-at-runtime121078
Ref: 7c121078
Ref: runtime_troubles runtime-troubles121078
Ref: 38121078
Ref: Annotation issues at runtime-Footnote-1122243
Node: String literal types and type comments122285
Ref: runtime_troubles string-literal-types122428
Ref: 7d122428
Ref: runtime_troubles string-literal-types-and-type-comments122428
Ref: 7e122428
Node: Future annotations import PEP 563123843
Ref: runtime_troubles future-annotations124015
Ref: 80124015
Ref: runtime_troubles future-annotations-import-pep-563124015
Ref: 81124015
Ref: Future annotations import PEP 563-Footnote-1125629
Ref: Future annotations import PEP 563-Footnote-2125671
Ref: Future annotations import PEP 563-Footnote-3125740
Ref: Future annotations import PEP 563-Footnote-4125812
Node: typing TYPE_CHECKING125854
Ref: runtime_troubles id1126017
Ref: 83126017
Ref: runtime_troubles typing-type-checking126017
Ref: 84126017
Ref: typing TYPE_CHECKING-Footnote-1126472
Ref: typing TYPE_CHECKING-Footnote-2126540
Node: Class name forward references126616
Ref: runtime_troubles class-name-forward-references126759
Ref: 85126759
Node: Import cycles127695
Ref: runtime_troubles id2127876
Ref: 86127876
Ref: runtime_troubles import-cycles127876
Ref: 7f127876
Node: Using classes that are generic in stubs but not at runtime129077
Ref: runtime_troubles not-generic-runtime129276
Ref: 87129276
Ref: runtime_troubles using-classes-that-are-generic-in-stubs-but-not-at-runtime129276
Ref: 88129276
Ref: Using classes that are generic in stubs but not at runtime-Footnote-1131261
Ref: Using classes that are generic in stubs but not at runtime-Footnote-2131323
Ref: Using classes that are generic in stubs but not at runtime-Footnote-3131388
Node: Using types defined in stubs but not at runtime131453
Ref: runtime_troubles using-types-defined-in-stubs-but-not-at-runtime131661
Ref: 89131661
Node: Using generic builtins132210
Ref: runtime_troubles generic-builtins132389
Ref: 47132389
Ref: runtime_troubles using-generic-builtins132389
Ref: 8a132389
Ref: Using generic builtins-Footnote-1133251
Ref: Using generic builtins-Footnote-2133293
Ref: Using generic builtins-Footnote-3133361
Node: Using X | Y syntax for Unions133448
Ref: runtime_troubles using-x-y-syntax-for-unions133620
Ref: 8b133620
Ref: Using X | Y syntax for Unions-Footnote-1134396
Node: Using new additions to the typing module134438
Ref: runtime_troubles using-new-additions-to-the-typing-module134579
Ref: 8c134579
Ref: Using new additions to the typing module-Footnote-1135562
Ref: Using new additions to the typing module-Footnote-2135630
Node: Protocols and structural subtyping135672
Ref: protocols doc135817
Ref: 8d135817
Ref: protocols protocol-types135817
Ref: 3a135817
Ref: protocols protocols-and-structural-subtyping135817
Ref: 8e135817
Ref: Protocols and structural subtyping-Footnote-1137258
Ref: Protocols and structural subtyping-Footnote-2137326
Node: Predefined protocols137368
Ref: protocols id1137495
Ref: 8f137495
Ref: protocols predefined-protocols137495
Ref: 90137495
Ref: Predefined protocols-Footnote-1138820
Ref: Predefined protocols-Footnote-2138888
Ref: Predefined protocols-Footnote-3138958
Ref: Predefined protocols-Footnote-4139034
Ref: Predefined protocols-Footnote-5139104
Node: Simple user-defined protocols139172
Ref: protocols simple-user-defined-protocols139355
Ref: 92139355
Ref: Simple user-defined protocols-Footnote-1140524
Node: Defining subprotocols and subclassing protocols140586
Ref: protocols defining-subprotocols-and-subclassing-protocols140768
Ref: 93140768
Node: Recursive protocols142982
Ref: protocols recursive-protocols143166
Ref: 94143166
Node: Using isinstance with protocols143925
Ref: protocols using-isinstance-with-protocols144080
Ref: 95144080
Ref: Using isinstance with protocols-Footnote-1145091
Ref: Using isinstance with protocols-Footnote-2145159
Ref: Using isinstance with protocols-Footnote-3145227
Ref: Using isinstance with protocols-Footnote-4145295
Ref: Using isinstance with protocols-Footnote-5145365
Node: Callback protocols145433
Ref: protocols callback-protocols145598
Ref: 5d145598
Ref: protocols id2145598
Ref: 96145598
Ref: Callback protocols-Footnote-1147119
Ref: Callback protocols-Footnote-2147189
Ref: Callback protocols-Footnote-3147265
Ref: Callback protocols-Footnote-4147335
Node: Predefined protocol reference147411
Ref: protocols predefined-protocol-reference147536
Ref: 97147536
Ref: protocols predefined-protocols-reference147536
Ref: 91147536
Node: Iteration protocols147740
Ref: protocols iteration-protocols147852
Ref: 98147852
Node: Iterable[T]148065
Ref: protocols iterable-t148150
Ref: 99148150
Ref: Iterable[T]-Footnote-1148374
Ref: Iterable[T]-Footnote-2148450
Node: Iterator[T]148520
Ref: protocols iterator-t148605
Ref: 9a148605
Ref: Iterator[T]-Footnote-1148774
Node: Collection protocols148844
Ref: protocols collection-protocols148982
Ref: 9b148982
Ref: Collection protocols-Footnote-1149283
Ref: Collection protocols-Footnote-2149344
Node: Sized149405
Ref: protocols sized149486
Ref: 9c149486
Ref: Sized-Footnote-1149654
Ref: Sized-Footnote-2149715
Node: Container[T]149782
Ref: protocols container-t149885
Ref: 9d149885
Ref: Container[T]-Footnote-1150100
Node: Collection[T]150171
Ref: protocols collection-t150260
Ref: 9e150260
Ref: Collection[T]-Footnote-1150483
Node: One-off protocols150555
Ref: protocols one-off-protocols150689
Ref: 9f150689
Node: Reversible[T]150975
Ref: protocols reversible-t151063
Ref: a0151063
Ref: Reversible[T]-Footnote-1151270
Ref: Reversible[T]-Footnote-2151336
Node: SupportsAbs[T]151408
Ref: protocols supportsabs-t151518
Ref: a1151518
Ref: SupportsAbs[T]-Footnote-1151763
Ref: SupportsAbs[T]-Footnote-2151824
Ref: SupportsAbs[T]-Footnote-3151885
Node: SupportsBytes151958
Ref: protocols supportsbytes152070
Ref: a2152070
Ref: SupportsBytes-Footnote-1152270
Ref: SupportsBytes-Footnote-2152332
Node: SupportsComplex152408
Ref: protocols supports-int-etc152519
Ref: a3152519
Ref: protocols supportscomplex152519
Ref: a4152519
Ref: SupportsComplex-Footnote-1152782
Ref: SupportsComplex-Footnote-2152847
Node: SupportsFloat152925
Ref: protocols supportsfloat153034
Ref: a5153034
Ref: SupportsFloat-Footnote-1153285
Ref: SupportsFloat-Footnote-2153348
Node: SupportsInt153424
Ref: protocols supportsint153534
Ref: a6153534
Ref: SupportsInt-Footnote-1153773
Ref: SupportsInt-Footnote-2153834
Node: SupportsRound[T]153907
Ref: protocols supportsround-t153995
Ref: a7153995
Ref: SupportsRound[T]-Footnote-1154197
Ref: SupportsRound[T]-Footnote-2154260
Node: Async protocols154336
Ref: protocols async-protocols154475
Ref: a8154475
Node: Awaitable[T]154698
Ref: protocols awaitable-t154785
Ref: a9154785
Ref: Awaitable[T]-Footnote-1154943
Node: AsyncIterable[T]155014
Ref: protocols asynciterable-t155126
Ref: aa155126
Ref: AsyncIterable[T]-Footnote-1155289
Node: AsyncIterator[T]155365
Ref: protocols asynciterator-t155456
Ref: ab155456
Ref: AsyncIterator[T]-Footnote-1155660
Node: Context manager protocols155736
Ref: protocols context-manager-protocols155849
Ref: ac155849
Node: ContextManager[T]156180
Ref: protocols contextmanager-t156288
Ref: ad156288
Ref: ContextManager[T]-Footnote-1156648
Node: AsyncContextManager[T]156725
Ref: protocols asynccontextmanager-t156833
Ref: ae156833
Ref: AsyncContextManager[T]-Footnote-1157235
Node: Dynamically typed code157317
Ref: dynamic_typing doc157448
Ref: af157448
Ref: dynamic_typing dynamic-typing157448
Ref: 45157448
Ref: dynamic_typing dynamically-typed-code157448
Ref: b0157448
Node: Operations on Any values158169
Ref: dynamic_typing operations-on-any-values158272
Ref: b1158272
Node: Any vs object159095
Ref: dynamic_typing any-vs-object159198
Ref: b2159198
Ref: Any vs object-Footnote-1160200
Ref: Any vs object-Footnote-2160264
Ref: Any vs object-Footnote-3160328
Ref: Any vs object-Footnote-4160392
Node: Type narrowing160456
Ref: type_narrowing doc160576
Ref: b3160576
Ref: type_narrowing id1160576
Ref: b4160576
Ref: type_narrowing type-narrowing160576
Ref: 82160576
Node: Type narrowing expressions160985
Ref: type_narrowing type-narrowing-expressions161074
Ref: b5161074
Ref: Type narrowing expressions-Footnote-1163870
Ref: Type narrowing expressions-Footnote-2163938
Ref: Type narrowing expressions-Footnote-3164006
Node: issubclass164072
Ref: type_narrowing issubclass164160
Ref: b8164160
Ref: issubclass-Footnote-1164768
Node: callable164836
Ref: type_narrowing callable164924
Ref: b9164924
Node: Casts165697
Ref: type_narrowing casts165819
Ref: 4d165819
Ref: type_narrowing id2165819
Ref: ba165819
Ref: Casts-Footnote-1167357
Node: User-Defined Type Guards167423
Ref: type_narrowing type-guards167510
Ref: bb167510
Ref: type_narrowing user-defined-type-guards167510
Ref: bc167510
Ref: User-Defined Type Guards-Footnote-1169760
Ref: User-Defined Type Guards-Footnote-2169802
Node: Generic TypeGuards169880
Ref: type_narrowing generic-typeguards169992
Ref: bd169992
Node: Typeguards with parameters170546
Ref: type_narrowing typeguards-with-parameters170688
Ref: be170688
Node: TypeGuards as methods171175
Ref: type_narrowing typeguards-as-methods171335
Ref: bf171335
Ref: TypeGuards as methods-Footnote-1172444
Node: Assignment expressions as TypeGuards172541
Ref: type_narrowing assignment-expressions-as-typeguards172666
Ref: c0172666
Ref: Assignment expressions as TypeGuards-Footnote-1173800
Node: Duck type compatibility173876
Ref: duck_type_compatibility doc173984
Ref: c1173984
Ref: duck_type_compatibility duck-type-compatibility173984
Ref: c2173984
Node: Stub files175317
Ref: stubs doc175419
Ref: c3175419
Ref: stubs id1175419
Ref: c4175419
Ref: stubs stub-files175419
Ref: 15175419
Ref: Stub files-Footnote-1175916
Node: Creating a stub175959
Ref: stubs creating-a-stub176044
Ref: c5176044
Ref: Creating a stub-Footnote-1178313
Node: Stub file syntax178355
Ref: stubs stub-file-syntax178482
Ref: c8178482
Node: Using stub file syntax at runtime179481
Ref: stubs using-stub-file-syntax-at-runtime179584
Ref: c9179584
Ref: Using stub file syntax at runtime-Footnote-1180976
Node: Generics181055
Ref: generics doc181144
Ref: ca181144
Ref: generics generics181144
Ref: cb181144
Node: Defining generic classes181836
Ref: generics defining-generic-classes181935
Ref: cc181935
Ref: generics generic-classes181935
Ref: 77181935
Node: Generic class internals183639
Ref: generics generic-class-internals183786
Ref: cd183786
Ref: Generic class internals-Footnote-1185679
Ref: Generic class internals-Footnote-2185740
Ref: Generic class internals-Footnote-3185801
Ref: Generic class internals-Footnote-4185867
Ref: Generic class internals-Footnote-5185933
Node: Defining sub-classes of generic classes186001
Ref: generics defining-sub-classes-of-generic-classes186141
Ref: ce186141
Ref: generics generic-subclasses186141
Ref: cf186141
Ref: Defining sub-classes of generic classes-Footnote-1188697
Ref: Defining sub-classes of generic classes-Footnote-2188765
Ref: Defining sub-classes of generic classes-Footnote-3188834
Ref: Defining sub-classes of generic classes-Footnote-4188904
Ref: Defining sub-classes of generic classes-Footnote-5188974
Node: Generic functions189043
Ref: generics generic-functions189192
Ref: d0189192
Ref: generics id1189192
Ref: d1189192
Node: Generic methods and generic self190387
Ref: generics generic-methods-and-generic-self190522
Ref: d2190522
Ref: generics id2190522
Ref: d3190522
Ref: Generic methods and generic self-Footnote-1192962
Node: Variance of generic types193028
Ref: generics variance-of-generic-types193183
Ref: d5193183
Ref: generics variance-of-generics193183
Ref: d6193183
Ref: Variance of generic types-Footnote-1196217
Ref: Variance of generic types-Footnote-2196284
Ref: Variance of generic types-Footnote-3196354
Ref: Variance of generic types-Footnote-4196425
Ref: Variance of generic types-Footnote-5196495
Ref: Variance of generic types-Footnote-6196561
Node: Type variables with value restriction196627
Ref: generics type-variable-value-restriction196782
Ref: d7196782
Ref: generics type-variables-with-value-restriction196782
Ref: d8196782
Ref: Type variables with value restriction-Footnote-1199129
Ref: Type variables with value restriction-Footnote-2199197
Ref: Type variables with value restriction-Footnote-3199265
Ref: Type variables with value restriction-Footnote-4199333
Ref: Type variables with value restriction-Footnote-5199402
Ref: Type variables with value restriction-Footnote-6199471
Node: Type variables with upper bounds199532
Ref: generics type-variable-upper-bound199682
Ref: 6f199682
Ref: generics type-variables-with-upper-bounds199682
Ref: d9199682
Ref: Type variables with upper bounds-Footnote-1201140
Node: Declaring decorators201209
Ref: generics declaring-decorators201339
Ref: 40201339
Ref: generics id3201339
Ref: da201339
Ref: Declaring decorators-Footnote-1204517
Node: Decorator factories204583
Ref: generics decorator-factories204657
Ref: db204657
Ref: generics id4204657
Ref: dc204657
Ref: Decorator factories-Footnote-1205987
Node: Generic protocols206057
Ref: generics generic-protocols206175
Ref: dd206175
Ref: Generic protocols-Footnote-1208788
Ref: Generic protocols-Footnote-2208858
Node: Generic type aliases208918
Ref: generics generic-type-aliases209007
Ref: 6b209007
Ref: generics id5209007
Ref: de209007
Ref: Generic type aliases-Footnote-1211308
Node: More types211363
Ref: more_types doc211465
Ref: df211465
Ref: more_types more-types211465
Ref: e0211465
Ref: More types-Footnote-1212913
Ref: More types-Footnote-2212983
Ref: More types-Footnote-3213053
Node: The NoReturn type213123
Ref: more_types noreturn213202
Ref: e1213202
Ref: more_types the-noreturn-type213202
Ref: e2213202
Ref: The NoReturn type-Footnote-1214097
Ref: The NoReturn type-Footnote-2214167
Node: NewTypes214237
Ref: more_types id1214345
Ref: e3214345
Ref: more_types newtypes214345
Ref: e4214345
Ref: NewTypes-Footnote-1217556
Ref: NewTypes-Footnote-2217623
Ref: NewTypes-Footnote-3217691
Node: Function overloading217759
Ref: more_types function-overloading217877
Ref: 60217877
Ref: more_types id2217877
Ref: e5217877
Ref: Function overloading-Footnote-1222609
Ref: Function overloading-Footnote-2222676
Ref: Function overloading-Footnote-3222746
Ref: Function overloading-Footnote-4222825
Node: Runtime behavior222895
Ref: more_types runtime-behavior223007
Ref: e6223007
Ref: Runtime behavior-Footnote-1224092
Node: Type checking calls to overloads224160
Ref: more_types type-checking-calls-to-overloads224307
Ref: e7224307
Ref: Type checking calls to overloads-Footnote-1227028
Node: Type checking the variants227096
Ref: more_types type-checking-the-variants227259
Ref: e8227259
Ref: Type checking the variants-Footnote-1232343
Node: Type checking the implementation232407
Ref: more_types type-checking-the-implementation232559
Ref: e9232559
Node: Conditional overloads234360
Ref: more_types conditional-overloads234477
Ref: ec234477
Ref: Conditional overloads-Footnote-1237157
Node: Advanced uses of self-types237233
Ref: more_types advanced-self237361
Ref: d4237361
Ref: more_types advanced-uses-of-self-types237361
Ref: f1237361
Node: Restricted methods in generic classes237748
Ref: more_types restricted-methods-in-generic-classes237869
Ref: f2237869
Ref: Restricted methods in generic classes-Footnote-1239874
Ref: Restricted methods in generic classes-Footnote-2239950
Node: Mixin classes240026
Ref: more_types mixin-classes240198
Ref: f3240198
Node: Precise typing of alternative constructors241397
Ref: more_types precise-typing-of-alternative-constructors241523
Ref: f4241523
Node: Typing async/await242335
Ref: more_types async-and-await242452
Ref: 3d242452
Ref: more_types typing-async-await242452
Ref: f5242452
Ref: Typing async/await-Footnote-1246296
Ref: Typing async/await-Footnote-2246338
Ref: Typing async/await-Footnote-3246409
Ref: Typing async/await-Footnote-4246480
Ref: Typing async/await-Footnote-5246551
Ref: Typing async/await-Footnote-6246627
Node: TypedDict246706
Ref: more_types id3246787
Ref: f7246787
Ref: more_types typeddict246787
Ref: f8246787
Ref: TypedDict-Footnote-1250922
Ref: TypedDict-Footnote-2250983
Ref: TypedDict-Footnote-3251044
Ref: TypedDict-Footnote-4251105
Ref: TypedDict-Footnote-5251166
Ref: TypedDict-Footnote-6251235
Node: Totality251303
Ref: more_types totality251384
Ref: f9251384
Ref: Totality-Footnote-1252873
Ref: Totality-Footnote-2252938
Ref: Totality-Footnote-3253005
Ref: Totality-Footnote-4253070
Node: Supported operations253135
Ref: more_types supported-operations253243
Ref: fa253243
Ref: Supported operations-Footnote-1254253
Ref: Supported operations-Footnote-2254322
Ref: Supported operations-Footnote-3254387
Ref: Supported operations-Footnote-4254453
Ref: Supported operations-Footnote-5254521
Ref: Supported operations-Footnote-6254588
Ref: Supported operations-Footnote-7254654
Ref: Supported operations-Footnote-8254726
Ref: Supported operations-Footnote-9254794
Ref: Supported operations-Footnote-10254859
Ref: Supported operations-Footnote-11254927
Node: Class-based syntax254997
Ref: more_types class-based-syntax255135
Ref: fb255135
Node: Mixing required and non-required items256023
Ref: more_types mixing-required-and-non-required-items256161
Ref: fc256161
Node: Unions of TypedDicts257072
Ref: more_types unions-of-typeddicts257183
Ref: fd257183
Node: Literal types and Enums257780
Ref: literal_types doc257905
Ref: 100257905
Ref: literal_types literal-types-and-enums257905
Ref: 101257905
Node: Literal types258002
Ref: literal_types id1258087
Ref: 102258087
Ref: literal_types literal-types258087
Ref: ff258087
Node: Parameterizing Literals260157
Ref: literal_types parameterizing-literals260264
Ref: 103260264
Node: Declaring literal variables261757
Ref: literal_types declaring-literal-variables261893
Ref: 104261893
Node: Intelligent indexing264314
Ref: literal_types intelligent-indexing264440
Ref: 106264440
Node: Tagged unions266113
Ref: literal_types id2266235
Ref: 107266235
Ref: literal_types tagged-unions266235
Ref: fe266235
Node: Exhaustiveness checking269305
Ref: literal_types exhaustiveness-checking269418
Ref: 108269418
Node: Limitations271979
Ref: literal_types limitations272070
Ref: 109272070
Node: Enums272782
Ref: literal_types enums272867
Ref: 10a272867
Ref: Enums-Footnote-1273779
Ref: Enums-Footnote-2273841
Ref: Enums-Footnote-3273906
Ref: Enums-Footnote-4273968
Node: Exhaustiveness checking<2>274033
Ref: literal_types id3274125
Ref: 10b274125
Node: Extra Enum checks275477
Ref: literal_types extra-enum-checks275569
Ref: 10c275569
Node: Final names methods and classes276916
Ref: final_attrs doc277042
Ref: 10d277042
Ref: final_attrs final-attrs277042
Ref: 105277042
Ref: final_attrs final-names-methods-and-classes277042
Ref: 10e277042
Node: Final names277893
Ref: final_attrs final-names277992
Ref: 10f277992
Ref: Final names-Footnote-1279154
Node: Syntax variants279220
Ref: final_attrs syntax-variants279312
Ref: 110279312
Ref: Syntax variants-Footnote-1280203
Node: Details of using Final280279
Ref: final_attrs details-of-using-final280371
Ref: 111280371
Ref: Details of using Final-Footnote-1282385
Ref: Details of using Final-Footnote-2282461
Ref: Details of using Final-Footnote-3282531
Node: Final methods282607
Ref: final_attrs final-methods282728
Ref: 112282728
Node: Final classes283654
Ref: final_attrs final-classes283755
Ref: 113283755
Node: Metaclasses285170
Ref: metaclasses doc285306
Ref: 114285306
Ref: metaclasses id1285306
Ref: 115285306
Ref: metaclasses metaclasses285306
Ref: 116285306
Ref: Metaclasses-Footnote-1285923
Ref: Metaclasses-Footnote-2285994
Ref: Metaclasses-Footnote-3286056
Ref: Metaclasses-Footnote-4286118
Ref: Metaclasses-Footnote-5286190
Node: Defining a metaclass286253
Ref: metaclasses defining286351
Ref: 117286351
Ref: metaclasses defining-a-metaclass286351
Ref: 118286351
Node: Metaclass usage example286485
Ref: metaclasses examples286636
Ref: 119286636
Ref: metaclasses metaclass-usage-example286636
Ref: 11a286636
Node: Gotchas and limitations of metaclass support287310
Ref: metaclasses gotchas-and-limitations-of-metaclass-support287432
Ref: 11b287432
Ref: metaclasses limitations287432
Ref: 11c287432
Ref: Gotchas and limitations of metaclass support-Footnote-1288606
Node: Running mypy and managing imports288668
Ref: running_mypy doc288794
Ref: 11d288794
Ref: running_mypy running-mypy288794
Ref: 11e288794
Ref: running_mypy running-mypy-and-managing-imports288794
Ref: 11f288794
Node: Specifying code to be checked289682
Ref: running_mypy id1289823
Ref: 120289823
Ref: running_mypy specifying-code-to-be-checked289823
Ref: 21289823
Node: Reading a list of files from a file292408
Ref: running_mypy reading-a-list-of-files-from-a-file292587
Ref: 127292587
Node: Mapping file paths to modules293275
Ref: running_mypy mapping-file-paths-to-modules293449
Ref: 128293449
Ref: running_mypy mapping-paths-to-modules293449
Ref: 121293449
Node: How mypy handles imports297017
Ref: running_mypy how-mypy-handles-imports297171
Ref: 12f297171
Ref: running_mypy ignore-missing-imports298006
Ref: 16298006
Node: Missing imports298008
Ref: running_mypy fix-missing-imports298154
Ref: 13298154
Ref: running_mypy missing-imports298154
Ref: 130298154
Node: Missing library stubs or py typed marker299361
Ref: running_mypy missing-library-stubs-or-py-typed-marker299487
Ref: 131299487
Ref: Missing library stubs or py typed marker-Footnote-1303336
Ref: Missing library stubs or py typed marker-Footnote-2303379
Node: Library stubs not installed303426
Ref: running_mypy library-stubs-not-installed303603
Ref: 134303603
Node: Cannot find implementation or library stub305378
Ref: running_mypy cannot-find-implementation-or-library-stub305506
Ref: 138305506
Ref: running_mypy missing-type-hints-for-third-party-library305506
Ref: 139305506
Node: How imports are found307678
Ref: running_mypy finding-imports307817
Ref: 123307817
Ref: running_mypy how-imports-are-found307817
Ref: 13a307817
Ref: How imports are found-Footnote-1310328
Ref: How imports are found-Footnote-2310371
Node: Following imports310413
Ref: running_mypy follow-imports310528
Ref: 26310528
Ref: running_mypy following-imports310528
Ref: 13b310528
Node: The mypy command line313447
Ref: command_line doc313589
Ref: 13e313589
Ref: command_line command-line313589
Ref: a313589
Ref: command_line the-mypy-command-line313589
Ref: 13f313589
Node: Specifying what to type check314274
Ref: command_line specifying-what-to-type-check314386
Ref: 141314386
Ref: command_line cmdoption-mypy-m314882
Ref: 122314882
Ref: command_line cmdoption-mypy-module314882
Ref: 142314882
Ref: command_line cmdoption-mypy-p315114
Ref: 124315114
Ref: command_line cmdoption-mypy-package315114
Ref: 143315114
Ref: command_line cmdoption-mypy-c315427
Ref: 125315427
Ref: command_line cmdoption-mypy-command315427
Ref: 144315427
Ref: command_line cmdoption-mypy-exclude315544
Ref: 129315544
Node: Optional arguments317243
Ref: command_line optional-arguments317375
Ref: 145317375
Ref: command_line cmdoption-mypy-h317428
Ref: 140317428
Ref: command_line cmdoption-mypy-help317428
Ref: 146317428
Ref: command_line cmdoption-mypy-v317486
Ref: 12e317486
Ref: command_line cmdoption-mypy-verbose317486
Ref: 147317486
Ref: command_line cmdoption-mypy-V317542
Ref: 148317542
Ref: command_line cmdoption-mypy-version317542
Ref: 149317542
Node: Config file317617
Ref: command_line config-file317736
Ref: 14a317736
Ref: command_line config-file-flag317736
Ref: 14b317736
Ref: command_line cmdoption-mypy-config-file317775
Ref: 14c317775
Ref: command_line cmdoption-mypy-warn-unused-configs318339
Ref: 14d318339
Node: Import discovery318556
Ref: command_line id1318679
Ref: 14f318679
Ref: command_line import-discovery318679
Ref: 150318679
Ref: command_line cmdoption-mypy-explicit-package-bases318807
Ref: 12b318807
Ref: command_line cmdoption-mypy-ignore-missing-imports319186
Ref: 133319186
Ref: command_line cmdoption-mypy-follow-imports320076
Ref: 13c320076
Ref: command_line cmdoption-mypy-python-executable320435
Ref: 137320435
Ref: command_line cmdoption-mypy-no-site-packages320846
Ref: 151320846
Ref: command_line cmdoption-mypy-no-silence-site-packages321234
Ref: 152321234
Ref: command_line cmdoption-mypy-fast-module-lookup321434
Ref: 153321434
Ref: command_line cmdoption-mypy-no-namespace-packages322127
Ref: 12a322127
Ref: Import discovery-Footnote-1322690
Ref: Import discovery-Footnote-2322732
Ref: Import discovery-Footnote-3322774
Ref: Import discovery-Footnote-4322816
Node: Platform configuration322858
Ref: command_line id2322993
Ref: 154322993
Ref: command_line platform-configuration322993
Ref: 155322993
Ref: command_line cmdoption-mypy-python-version323359
Ref: f0323359
Ref: command_line cmdoption-mypy-platform323868
Ref: 156323868
Ref: command_line always-true324202
Ref: 157324202
Ref: command_line cmdoption-mypy-always-true324202
Ref: ee324202
Ref: command_line cmdoption-mypy-always-false324373
Ref: ef324373
Ref: Platform configuration-Footnote-1324582
Ref: Platform configuration-Footnote-2324624
Node: Disallow dynamic typing324688
Ref: command_line disallow-dynamic-typing324836
Ref: 158324836
Ref: command_line id3324836
Ref: 159324836
Ref: command_line cmdoption-mypy-disallow-any-unimported325211
Ref: 15a325211
Ref: command_line cmdoption-mypy-disallow-any-expr325507
Ref: 15b325507
Ref: command_line cmdoption-mypy-disallow-any-decorated326064
Ref: 15c326064
Ref: command_line cmdoption-mypy-disallow-any-explicit326214
Ref: 15d326214
Ref: command_line cmdoption-mypy-disallow-any-generics326373
Ref: 15e326373
Ref: command_line cmdoption-mypy-disallow-subclassing-any326639
Ref: 15f326639
Ref: Disallow dynamic typing-Footnote-1327358
Node: Untyped definitions and calls327424
Ref: command_line id4327576
Ref: 160327576
Ref: command_line untyped-definitions-and-calls327576
Ref: eb327576
Ref: command_line cmdoption-mypy-disallow-untyped-calls327738
Ref: 161327738
Ref: command_line cmdoption-mypy-disallow-untyped-defs327902
Ref: 9327902
Ref: command_line cmdoption-mypy-disallow-incomplete-defs328048
Ref: 162328048
Ref: command_line cmdoption-mypy-check-untyped-defs328189
Ref: ea328189
Ref: command_line cmdoption-mypy-disallow-untyped-decorators328580
Ref: 163328580
Node: None and Optional handling328754
Ref: command_line id5328903
Ref: 164328903
Ref: command_line none-and-optional-handling328903
Ref: 165328903
Ref: command_line implicit-optional329111
Ref: 166329111
Ref: command_line cmdoption-mypy-implicit-optional329111
Ref: 167329111
Ref: command_line cmdoption-mypy-no-strict-optional329610
Ref: 67329610
Ref: None and Optional handling-Footnote-1330184
Ref: None and Optional handling-Footnote-2330254
Node: Configuring warnings330324
Ref: command_line configuring-warnings330474
Ref: 168330474
Ref: command_line id6330474
Ref: 169330474
Ref: command_line cmdoption-mypy-warn-redundant-casts330648
Ref: 16a330648
Ref: command_line cmdoption-mypy-warn-unused-ignores330808
Ref: 16b330808
Ref: command_line cmdoption-mypy-no-warn-no-return331418
Ref: 16c331418
Ref: command_line cmdoption-mypy-warn-return-any331926
Ref: 16d331926
Ref: command_line cmdoption-mypy-warn-unreachable332119
Ref: b6332119
Ref: Configuring warnings-Footnote-1333853
Node: Miscellaneous strictness flags333923
Ref: command_line id7334073
Ref: 16e334073
Ref: command_line miscellaneous-strictness-flags334073
Ref: 16f334073
Ref: command_line cmdoption-mypy-allow-untyped-globals334249
Ref: 170334249
Ref: command_line cmdoption-mypy-allow-redefinition334419
Ref: 171334419
Ref: command_line cmdoption-mypy-local-partial-types335351
Ref: 172335351
Ref: command_line cmdoption-mypy-no-implicit-reexport336446
Ref: 173336446
Ref: command_line cmdoption-mypy-strict-equality337172
Ref: 174337172
Ref: command_line cmdoption-mypy-strict337774
Ref: 18337774
Ref: command_line cmdoption-mypy-disable-error-code338072
Ref: 175338072
Ref: command_line cmdoption-mypy-enable-error-code338455
Ref: 177338455
Node: Configuring error messages339006
Ref: command_line configuring-error-messages339152
Ref: 178339152
Ref: command_line id8339152
Ref: 179339152
Ref: command_line cmdoption-mypy-show-error-context339308
Ref: 17a339308
Ref: command_line cmdoption-mypy-show-column-numbers339955
Ref: 17b339955
Ref: command_line cmdoption-mypy-show-error-end340249
Ref: 17c340249
Ref: command_line cmdoption-mypy-hide-error-codes340622
Ref: 17d340622
Ref: command_line cmdoption-mypy-pretty340929
Ref: 17e340929
Ref: command_line cmdoption-mypy-no-color-output341087
Ref: 17f341087
Ref: command_line cmdoption-mypy-no-error-summary341204
Ref: 180341204
Ref: command_line cmdoption-mypy-show-absolute-path341420
Ref: 181341420
Ref: command_line cmdoption-mypy-soft-error-limit341490
Ref: 182341490
Node: Incremental mode341854
Ref: command_line incremental341986
Ref: 183341986
Ref: command_line incremental-mode341986
Ref: 184341986
Ref: command_line cmdoption-mypy-no-incremental342488
Ref: 14e342488
Ref: command_line cmdoption-mypy-cache-dir342786
Ref: 185342786
Ref: command_line cmdoption-mypy-sqlite-cache343420
Ref: 186343420
Ref: command_line cmdoption-mypy-cache-fine-grained343500
Ref: 187343500
Ref: command_line cmdoption-mypy-skip-version-check343623
Ref: 188343623
Ref: command_line cmdoption-mypy-skip-cache-mtime-checks343785
Ref: 189343785
Ref: Incremental mode-Footnote-1343921
Node: Advanced options343953
Ref: command_line advanced-options344076
Ref: 18a344076
Ref: command_line cmdoption-mypy-pdb344239
Ref: 18b344239
Ref: command_line cmdoption-mypy-show-traceback344347
Ref: 18c344347
Ref: command_line cmdoption-mypy-tb344347
Ref: 18d344347
Ref: command_line cmdoption-mypy-raise-exceptions344478
Ref: 18e344478
Ref: command_line cmdoption-mypy-custom-typing-module344548
Ref: 18f344548
Ref: command_line cmdoption-mypy-custom-typeshed-dir344683
Ref: 190344683
Ref: command_line warn-incomplete-stub345191
Ref: 191345191
Ref: command_line cmdoption-mypy-warn-incomplete-stub345191
Ref: 192345191
Ref: command_line shadow-file345991
Ref: 193345991
Ref: command_line cmdoption-mypy-shadow-file345991
Ref: 194345991
Ref: Advanced options-Footnote-1347007
Node: Report generation347075
Ref: command_line report-generation347198
Ref: 195347198
Ref: command_line cmdoption-mypy-any-exprs-report347358
Ref: 196347358
Ref: command_line cmdoption-mypy-cobertura-xml-report347533
Ref: 197347533
Ref: command_line cmdoption-mypy-html-report347825
Ref: 198347825
Ref: command_line cmdoption-mypy-linecount-report348116
Ref: 199348116
Ref: command_line cmdoption-mypy-linecoverage-report348296
Ref: 19a348296
Ref: command_line cmdoption-mypy-lineprecision-report348507
Ref: 19b348507
Ref: command_line cmdoption-mypy-txt-report348672
Ref: 19c348672
Ref: command_line cmdoption-mypy-xml-report348965
Ref: 19d348965
Ref: Report generation-Footnote-1349269
Ref: Report generation-Footnote-2349308
Ref: Report generation-Footnote-3349347
Ref: Report generation-Footnote-4349386
Node: Miscellaneous<2>349425
Ref: command_line miscellaneous349523
Ref: 19e349523
Ref: command_line cmdoption-mypy-install-types349568
Ref: 135349568
Ref: command_line cmdoption-mypy-non-interactive350595
Ref: 136350595
Ref: command_line cmdoption-mypy-junit-xml351234
Ref: 19f351234
Ref: command_line cmdoption-mypy-find-occurrences351453
Ref: 1a0351453
Ref: command_line cmdoption-mypy-scripts-are-modules351638
Ref: 12d351638
Ref: Miscellaneous<2>-Footnote-1352198
Ref: Miscellaneous<2>-Footnote-2352270
Node: The mypy configuration file352342
Ref: config_file doc352471
Ref: 1a1352471
Ref: config_file config-file352471
Ref: 20352471
Ref: config_file sqlite352471
Ref: 1a2352471
Ref: config_file the-mypy-configuration-file352471
Ref: 1a3352471
Node: Config file format354647
Ref: config_file config-file-format354765
Ref: 1a4354765
Ref: config_file config-precedence356130
Ref: 1a5356130
Ref: Config file format-Footnote-1357203
Node: Per-module and global options357263
Ref: config_file per-module-and-global-options357413
Ref: 1a8357413
Node: Inverting option values358074
Ref: config_file inverting-option-values358214
Ref: 1a9358214
Node: Examples358461
Ref: config_file examples358591
Ref: 1aa358591
Node: Import discovery<2>360331
Ref: config_file config-file-import-discovery360463
Ref: 132360463
Ref: config_file import-discovery360463
Ref: 1ab360463
Ref: config_file confval-mypy_path360606
Ref: 12c360606
Ref: config_file confval-files361510
Ref: 126361510
Ref: config_file confval-exclude362071
Ref: 1ac362071
Ref: config_file confval-namespace_packages364183
Ref: 1ae364183
Ref: config_file confval-explicit_package_bases364485
Ref: 1af364485
Ref: config_file confval-ignore_missing_imports364987
Ref: 25364987
Ref: config_file confval-follow_imports365330
Ref: 13d365330
Ref: config_file confval-follow_imports_for_stubs366168
Ref: 1b0366168
Ref: config_file confval-python_executable366760
Ref: 1b1366760
Ref: config_file confval-no_site_packages367142
Ref: 1b2367142
Ref: config_file confval-no_silence_site_packages367458
Ref: 1b3367458
Ref: Import discovery<2>-Footnote-1367935
Ref: Import discovery<2>-Footnote-2367999
Ref: Import discovery<2>-Footnote-3368054
Ref: Import discovery<2>-Footnote-4368096
Ref: Import discovery<2>-Footnote-5368138
Node: Platform configuration<2>368180
Ref: config_file platform-configuration368330
Ref: 1b4368330
Ref: config_file confval-python_version368391
Ref: 1b5368391
Ref: config_file confval-platform368771
Ref: 1b6368771
Ref: config_file confval-always_true369139
Ref: 1b7369139
Ref: config_file confval-always_false369332
Ref: 1b8369332
Ref: Platform configuration<2>-Footnote-1369563
Node: Disallow dynamic typing<2>369627
Ref: config_file disallow-dynamic-typing369790
Ref: 1b9369790
Ref: config_file confval-disallow_any_unimported369954
Ref: 1ba369954
Ref: config_file confval-disallow_any_expr370212
Ref: 1bb370212
Ref: config_file confval-disallow_any_decorated370371
Ref: 1bc370371
Ref: config_file confval-disallow_any_explicit370565
Ref: 1bd370565
Ref: config_file confval-disallow_any_generics370768
Ref: 1be370768
Ref: config_file confval-disallow_subclassing_any370949
Ref: 1bf370949
Node: Untyped definitions and calls<2>371098
Ref: config_file untyped-definitions-and-calls371265
Ref: 1c0371265
Ref: config_file confval-disallow_untyped_calls371446
Ref: 1c1371446
Ref: config_file confval-disallow_untyped_defs371640
Ref: 2b371640
Ref: config_file confval-disallow_incomplete_defs371833
Ref: 1c2371833
Ref: config_file confval-check_untyped_defs371996
Ref: 1c3371996
Ref: config_file confval-disallow_untyped_decorators372154
Ref: 1c4372154
Node: None and Optional handling<2>372372
Ref: config_file config-file-none-and-optional-handling372536
Ref: 1c5372536
Ref: config_file none-and-optional-handling372536
Ref: 1c6372536
Ref: config_file confval-implicit_optional372709
Ref: 1c7372709
Ref: config_file confval-strict_optional372994
Ref: 68372994
Ref: None and Optional handling<2>-Footnote-1373320
Node: Configuring warnings<2>373390
Ref: config_file configuring-warnings373540
Ref: 1c8373540
Ref: config_file confval-warn_redundant_casts373697
Ref: 1c9373697
Ref: config_file confval-warn_unused_ignores373921
Ref: 1ca373921
Ref: config_file confval-warn_no_return374068
Ref: 1cb374068
Ref: config_file confval-warn_return_any374225
Ref: 1cc374225
Ref: config_file confval-warn_unreachable374440
Ref: 1cd374440
Node: Suppressing errors374652
Ref: config_file suppressing-errors374806
Ref: 1ce374806
Ref: config_file confval-ignore_errors374994
Ref: 23374994
Node: Miscellaneous strictness flags<2>375113
Ref: config_file miscellaneous-strictness-flags375273
Ref: 1cf375273
Ref: config_file confval-allow_untyped_globals375460
Ref: 1d0375460
Ref: config_file confval-allow_redefinition375674
Ref: 1d1375674
Ref: config_file confval-local_partial_types376528
Ref: 1d2376528
Ref: config_file confval-disable_error_code376797
Ref: 1d3376797
Ref: config_file confval-enable_error_code376948
Ref: 1d4376948
Ref: config_file confval-implicit_reexport377197
Ref: 1d5377197
Ref: config_file confval-strict_concatenate377899
Ref: 1d6377899
Ref: config_file confval-strict_equality378071
Ref: 1d7378071
Ref: config_file confval-strict378272
Ref: 1d8378272
Node: Configuring error messages<2>378608
Ref: config_file configuring-error-messages378769
Ref: 1d9378769
Ref: config_file confval-show_error_context379013
Ref: 1da379013
Ref: config_file confval-show_column_numbers379154
Ref: 1db379154
Ref: config_file confval-hide_error_codes379289
Ref: 1dc379289
Ref: config_file confval-pretty379474
Ref: 1dd379474
Ref: config_file confval-color_output379686
Ref: 1de379686
Ref: config_file confval-error_summary379814
Ref: 1df379814
Ref: config_file confval-show_absolute_path379951
Ref: 1e0379951
Node: Incremental mode<2>380075
Ref: config_file incremental-mode380222
Ref: 1e1380222
Ref: config_file confval-incremental380342
Ref: 1e2380342
Ref: config_file confval-cache_dir380465
Ref: 1e3380465
Ref: config_file confval-sqlite_cache380969
Ref: 1e4380969
Ref: config_file confval-cache_fine_grained381103
Ref: 1e5381103
Ref: config_file confval-skip_version_check381280
Ref: 1e6381280
Ref: config_file confval-skip_cache_mtime_checks381603
Ref: 1e7381603
Ref: Incremental mode<2>-Footnote-1381793
Node: Advanced options<2>381825
Ref: config_file advanced-options381963
Ref: 1e8381963
Ref: config_file confval-plugins382083
Ref: 1e9382083
Ref: config_file confval-pdb382259
Ref: 1eb382259
Ref: config_file confval-show_traceback382369
Ref: 1ec382369
Ref: config_file confval-raise_exceptions382491
Ref: 1ed382491
Ref: config_file confval-custom_typing_module382615
Ref: 1ee382615
Ref: config_file confval-custom_typeshed_dir382768
Ref: 1ef382768
Ref: config_file confval-warn_incomplete_stub383369
Ref: 1f0383369
Ref: Advanced options<2>-Footnote-1383677
Ref: Advanced options<2>-Footnote-2383739
Node: Report generation<2>383807
Ref: config_file report-generation383942
Ref: 1f1383942
Ref: config_file confval-any_exprs_report384104
Ref: 1f2384104
Ref: config_file confval-cobertura_xml_report384306
Ref: 1f3384306
Ref: config_file confval-html_report-xslt_html_report384625
Ref: 1f4384625
Ref: config_file confval-linecount_report384941
Ref: 1f5384941
Ref: config_file confval-linecoverage_report385148
Ref: 1f6385148
Ref: config_file confval-lineprecision_report385386
Ref: 1f7385386
Ref: config_file confval-txt_report-xslt_txt_report385578
Ref: 1f8385578
Ref: config_file confval-xml_report385896
Ref: 1f9385896
Ref: Report generation<2>-Footnote-1386227
Ref: Report generation<2>-Footnote-2386266
Ref: Report generation<2>-Footnote-3386305
Ref: Report generation<2>-Footnote-4386344
Node: Miscellaneous<3>386383
Ref: config_file miscellaneous386526
Ref: 1fa386526
Ref: config_file confval-junit_xml386640
Ref: 1fb386640
Ref: config_file confval-scripts_are_modules386880
Ref: 1fc386880
Ref: config_file confval-warn_unused_configs387114
Ref: 1a7387114
Ref: config_file confval-verbosity387412
Ref: 1fd387412
Node: Using a pyproject toml file387582
Ref: config_file using-a-pyproject-toml387727
Ref: 1ad387727
Ref: config_file using-a-pyproject-toml-file387727
Ref: 1fe387727
Ref: Using a pyproject toml file-Footnote-1389206
Ref: Using a pyproject toml file-Footnote-2389256
Ref: Using a pyproject toml file-Footnote-3389281
Node: Example pyproject toml389331
Ref: config_file example-pyproject-toml389451
Ref: 1ff389451
Node: Inline configuration390422
Ref: inline_config doc390553
Ref: 200390553
Ref: inline_config inline-config390553
Ref: 1a6390553
Ref: inline_config inline-configuration390553
Ref: 201390553
Ref: inline_config toml-documentation390553
Ref: 202390553
Node: Configuration comment format390895
Ref: inline_config configuration-comment-format390978
Ref: 203390978
Node: Mypy daemon mypy server391772
Ref: mypy_daemon doc391900
Ref: 204391900
Ref: mypy_daemon mypy-daemon391900
Ref: 2e391900
Ref: mypy_daemon mypy-daemon-mypy-server391900
Ref: 205391900
Node: Basic usage393239
Ref: mypy_daemon basic-usage393339
Ref: 206393339
Node: Daemon client commands394460
Ref: mypy_daemon daemon-client-commands394592
Ref: 207394592
Node: Additional daemon flags396106
Ref: mypy_daemon additional-daemon-flags396258
Ref: 20a396258
Ref: mypy_daemon cmdoption-dmypy-status-file396321
Ref: 20b396321
Ref: mypy_daemon cmdoption-dmypy-log-file396607
Ref: 20c396607
Ref: mypy_daemon cmdoption-dmypy-timeout396889
Ref: 20d396889
Ref: mypy_daemon cmdoption-dmypy-update397089
Ref: 208397089
Ref: mypy_daemon cmdoption-dmypy-remove397884
Ref: 209397884
Ref: mypy_daemon cmdoption-dmypy-fswatcher-dump-file398227
Ref: 20e398227
Ref: mypy_daemon cmdoption-dmypy-perf-stats-file398644
Ref: 20f398644
Ref: mypy_daemon cmdoption-dmypy-export-types398830
Ref: 210398830
Ref: Additional daemon flags-Footnote-1399118
Ref: Additional daemon flags-Footnote-2399163
Node: Static inference of annotations399206
Ref: mypy_daemon static-inference-of-annotations399366
Ref: 211399366
Ref: mypy_daemon cmdoption-dmypy-json401048
Ref: 212401048
Ref: mypy_daemon cmdoption-dmypy-no-errors401445
Ref: 213401445
Ref: mypy_daemon cmdoption-dmypy-no-any401646
Ref: 214401646
Ref: mypy_daemon cmdoption-dmypy-flex-any401844
Ref: 215401844
Ref: mypy_daemon cmdoption-dmypy-callsites402048
Ref: 216402048
Ref: mypy_daemon cmdoption-dmypy-use-fixme402315
Ref: 217402315
Ref: mypy_daemon cmdoption-dmypy-max-guesses402558
Ref: 218402558
Ref: Static inference of annotations-Footnote-1402714
Ref: Static inference of annotations-Footnote-2402769
Node: Statically inspect expressions402815
Ref: mypy_daemon statically-inspect-expressions402943
Ref: 219402943
Ref: mypy_daemon cmdoption-dmypy-show404587
Ref: 21b404587
Ref: mypy_daemon cmdoption-dmypy-verbose405500
Ref: 21c405500
Ref: mypy_daemon cmdoption-dmypy-limit405761
Ref: 21d405761
Ref: mypy_daemon cmdoption-dmypy-include-span406402
Ref: 21e406402
Ref: mypy_daemon cmdoption-dmypy-include-kind406671
Ref: 21f406671
Ref: mypy_daemon cmdoption-dmypy-include-object-attrs407008
Ref: 220407008
Ref: mypy_daemon cmdoption-dmypy-union-attrs407175
Ref: 221407175
Ref: mypy_daemon cmdoption-dmypy-force-reload407821
Ref: 21a407821
Node: Using installed packages408164
Ref: installed_packages doc408302
Ref: 222408302
Ref: installed_packages installed-packages408302
Ref: 14408302
Ref: installed_packages mypy-plugin-for-pycharm408302
Ref: 223408302
Ref: installed_packages using-installed-packages408302
Ref: 224408302
Ref: Using installed packages-Footnote-1409978
Ref: Using installed packages-Footnote-2410022
Ref: Using installed packages-Footnote-3410073
Ref: Using installed packages-Footnote-4410116
Node: Using installed packages with mypy PEP 561410158
Ref: installed_packages using-installed-packages-with-mypy-pep-561410304
Ref: 225410304
Ref: Using installed packages with mypy PEP 561-Footnote-1411980
Node: Creating PEP 561 compatible packages412041
Ref: installed_packages creating-pep-561-compatible-packages412187
Ref: 226412187
Ref: Creating PEP 561 compatible packages-Footnote-1415580
Ref: Creating PEP 561 compatible packages-Footnote-2415622
Ref: Creating PEP 561 compatible packages-Footnote-3415665
Node: Extending and integrating mypy415721
Ref: extending_mypy doc415869
Ref: 227415869
Ref: extending_mypy extending-and-integrating-mypy415869
Ref: 228415869
Ref: extending_mypy extending-mypy415869
Ref: 229415869
Node: Integrating mypy into another Python application416169
Ref: extending_mypy integrating-mypy416319
Ref: 22a416319
Ref: extending_mypy integrating-mypy-into-another-python-application416319
Ref: 22b416319
Ref: Integrating mypy into another Python application-Footnote-1417438
Ref: Integrating mypy into another Python application-Footnote-2417500
Node: Extending mypy using plugins417562
Ref: extending_mypy extending-mypy-using-plugins417752
Ref: 1ea417752
Ref: extending_mypy id1417752
Ref: 22c417752
Ref: Extending mypy using plugins-Footnote-1419065
Ref: Extending mypy using plugins-Footnote-2419107
Ref: Extending mypy using plugins-Footnote-3419149
Ref: Extending mypy using plugins-Footnote-4419189
Node: Configuring mypy to use plugins419240
Ref: extending_mypy configuring-mypy-to-use-plugins419401
Ref: 22d419401
Ref: Configuring mypy to use plugins-Footnote-1420458
Ref: Configuring mypy to use plugins-Footnote-2420524
Node: High-level overview420588
Ref: extending_mypy high-level-overview420749
Ref: 22e420749
Node: Current list of plugin hooks422408
Ref: extending_mypy current-list-of-plugin-hooks422571
Ref: 230422571
Ref: extending_mypy plugin-hooks422571
Ref: 22f422571
Ref: Current list of plugin hooks-Footnote-1426910
Ref: Current list of plugin hooks-Footnote-2426952
Ref: Current list of plugin hooks-Footnote-3427028
Ref: Current list of plugin hooks-Footnote-4427102
Ref: Current list of plugin hooks-Footnote-5427170
Ref: Current list of plugin hooks-Footnote-6427249
Ref: Current list of plugin hooks-Footnote-7427333
Ref: Current list of plugin hooks-Footnote-8427412
Node: Notes about the semantic analyzer427496
Ref: extending_mypy notes-about-the-semantic-analyzer427631
Ref: 231427631
Ref: Notes about the semantic analyzer-Footnote-1428805
Node: Automatic stub generation stubgen428871
Ref: stubgen doc429026
Ref: 232429026
Ref: stubgen automatic-stub-generation-stubgen429026
Ref: 233429026
Ref: stubgen stubgen429026
Ref: c6429026
Ref: Automatic stub generation stubgen-Footnote-1430928
Node: Specifying what to stub430970
Ref: stubgen specifying-what-to-stub431102
Ref: 235431102
Ref: stubgen cmdoption-stubgen-m431760
Ref: 237431760
Ref: stubgen cmdoption-stubgen-module431760
Ref: 239431760
Ref: stubgen cmdoption-stubgen-p432001
Ref: 238432001
Ref: stubgen cmdoption-stubgen-package432001
Ref: 23a432001
Node: Specifying how to generate stubs432551
Ref: stubgen specifying-how-to-generate-stubs432708
Ref: 23b432708
Ref: stubgen cmdoption-stubgen-no-import433164
Ref: 23c433164
Ref: stubgen cmdoption-stubgen-parse-only433778
Ref: 23d433778
Ref: stubgen cmdoption-stubgen-doc-dir434111
Ref: 23e434111
Node: Additional flags434318
Ref: stubgen additional-flags434443
Ref: 23f434443
Ref: stubgen cmdoption-stubgen-h434492
Ref: 234434492
Ref: stubgen cmdoption-stubgen-help434492
Ref: 240434492
Ref: stubgen cmdoption-stubgen-ignore-errors434550
Ref: 241434550
Ref: stubgen cmdoption-stubgen-include-private434734
Ref: 242434734
Ref: stubgen cmdoption-stubgen-export-less434930
Ref: 243434930
Ref: stubgen cmdoption-stubgen-search-path435152
Ref: 244435152
Ref: stubgen cmdoption-stubgen-o435300
Ref: 236435300
Ref: stubgen cmdoption-stubgen-output435300
Ref: 245435300
Ref: stubgen cmdoption-stubgen-v435588
Ref: 246435588
Ref: stubgen cmdoption-stubgen-verbose435588
Ref: 247435588
Ref: stubgen cmdoption-stubgen-q435650
Ref: 248435650
Ref: stubgen cmdoption-stubgen-quiet435650
Ref: 249435650
Node: Automatic stub testing stubtest435710
Ref: stubtest doc435862
Ref: 24a435862
Ref: stubtest automatic-stub-testing-stubtest435862
Ref: 24b435862
Ref: stubtest stubtest435862
Ref: c7435862
Ref: Automatic stub testing stubtest-Footnote-1436382
Node: What stubtest does and does not do436443
Ref: stubtest what-stubtest-does-and-does-not-do436559
Ref: 24c436559
Ref: What stubtest does and does not do-Footnote-1438021
Ref: What stubtest does and does not do-Footnote-2438091
Node: Example438134
Ref: stubtest example438264
Ref: 24d438264
Node: Usage438966
Ref: stubtest usage439053
Ref: 24e439053
Ref: stubtest cmdoption-stubtest-concise440229
Ref: 250440229
Ref: stubtest cmdoption-stubtest-ignore-missing-stub440317
Ref: 251440317
Ref: stubtest cmdoption-stubtest-ignore-positional-only440424
Ref: 252440424
Ref: stubtest cmdoption-stubtest-allowlist440552
Ref: 253440552
Ref: stubtest cmdoption-stubtest-generate-allowlist440782
Ref: 254440782
Ref: stubtest cmdoption-stubtest-ignore-unused-allowlist440882
Ref: 255440882
Ref: stubtest cmdoption-stubtest-mypy-config-file440959
Ref: 256440959
Ref: stubtest cmdoption-stubtest-custom-typeshed-dir441078
Ref: 257441078
Ref: stubtest cmdoption-stubtest-check-typeshed441154
Ref: 258441154
Ref: stubtest cmdoption-stubtest-help441227
Ref: 24f441227
Node: Common issues and solutions441277
Ref: common_issues doc441421
Ref: 259441421
Ref: common_issues common-issues441421
Ref: 1b441421
Ref: common_issues common-issues-and-solutions441421
Ref: 25a441421
Node: Can’t install mypy using pip442556
Ref: common_issues can-t-install-mypy-using-pip442700
Ref: 25b442700
Node: No errors reported for obviously wrong code442963
Ref: common_issues annotations-needed443165
Ref: 25c443165
Ref: common_issues no-errors-reported-for-obviously-wrong-code443165
Ref: 25d443165
Ref: No errors reported for obviously wrong code-Footnote-1447092
Ref: No errors reported for obviously wrong code-Footnote-2447153
Ref: No errors reported for obviously wrong code-Footnote-3447207
Ref: No errors reported for obviously wrong code-Footnote-4447283
Ref: No errors reported for obviously wrong code-Footnote-5447359
Ref: No errors reported for obviously wrong code-Footnote-6447435
Node: Spurious errors and locally silencing the checker447511
Ref: common_issues silencing-checker447704
Ref: 25e447704
Ref: common_issues spurious-errors-and-locally-silencing-the-checker447704
Ref: 25f447704
Ref: Spurious errors and locally silencing the checker-Footnote-1449778
Node: Ignoring a whole file449857
Ref: common_issues ignoring-a-whole-file450034
Ref: 260450034
Node: Issues with code at runtime450667
Ref: common_issues issues-with-code-at-runtime450813
Ref: 261450813
Node: Mypy runs are slow451589
Ref: common_issues mypy-runs-are-slow451740
Ref: 262451740
Node: Types of empty collections452019
Ref: common_issues types-of-empty-collections452180
Ref: 263452180
Node: Redefinitions with incompatible types453149
Ref: common_issues redefinitions-with-incompatible-types453316
Ref: 264453316
Node: Invariance vs covariance454225
Ref: common_issues invariance-vs-covariance454404
Ref: 265454404
Ref: common_issues variance454404
Ref: 50454404
Node: Declaring a supertype as variable type455469
Ref: common_issues declaring-a-supertype-as-variable-type455629
Ref: 266455629
Node: Complex type tests456355
Ref: common_issues complex-type-tests456532
Ref: 267456532
Ref: Complex type tests-Footnote-1458709
Ref: Complex type tests-Footnote-2458777
Ref: Complex type tests-Footnote-3458845
Ref: Complex type tests-Footnote-4458909
Node: Python version and system platform checks458977
Ref: common_issues python-version-and-system-platform-checks459152
Ref: 268459152
Ref: common_issues version-and-platform-checks459152
Ref: ed459152
Ref: Python version and system platform checks-Footnote-1461799
Ref: Python version and system platform checks-Footnote-2461867
Ref: Python version and system platform checks-Footnote-3461931
Ref: Python version and system platform checks-Footnote-4462007
Ref: Python version and system platform checks-Footnote-5462075
Ref: Python version and system platform checks-Footnote-6462139
Ref: Python version and system platform checks-Footnote-7462207
Ref: Python version and system platform checks-Footnote-8462271
Node: Displaying the type of an expression462335
Ref: common_issues displaying-the-type-of-an-expression462509
Ref: 269462509
Ref: common_issues reveal-type462509
Ref: f6462509
Node: Silencing linters463490
Ref: common_issues id1463682
Ref: 26a463682
Ref: common_issues silencing-linters463682
Ref: 26b463682
Node: Covariant subtyping of mutable protocol members is rejected464199
Ref: common_issues covariant-subtyping-of-mutable-protocol-members-is-rejected464385
Ref: 26c464385
Ref: Covariant subtyping of mutable protocol members is rejected-Footnote-1465287
Node: Dealing with conflicting names465353
Ref: common_issues dealing-with-conflicting-names465552
Ref: 26d465552
Node: Using a development mypy build466294
Ref: common_issues using-a-development-mypy-build466459
Ref: 26e466459
Ref: Using a development mypy build-Footnote-1466832
Node: Variables vs type aliases466871
Ref: common_issues variables-vs-type-aliases467028
Ref: 26f467028
Ref: Variables vs type aliases-Footnote-1468861
Node: Incompatible overrides468903
Ref: common_issues incompatible-overrides469046
Ref: 270469046
Ref: Incompatible overrides-Footnote-1470927
Node: Unreachable code471034
Ref: common_issues unreachable471181
Ref: b7471181
Ref: common_issues unreachable-code471181
Ref: 271471181
Node: Narrowing and inner functions472720
Ref: common_issues narrowing-and-inner-functions472836
Ref: 272472836
Node: Supported Python features473749
Ref: supported_python_features doc473873
Ref: 273473873
Ref: supported_python_features supported-python-features473873
Ref: 274473873
Ref: Supported Python features-Footnote-1474138
Node: Runtime definition of methods and functions474210
Ref: supported_python_features runtime-definition-of-methods-and-functions474313
Ref: 275474313
Ref: Runtime definition of methods and functions-Footnote-1475077
Node: Error codes475142
Ref: error_codes doc475269
Ref: 276475269
Ref: error_codes error-codes475269
Ref: 176475269
Ref: error_codes id1475269
Ref: 277475269
Node: Displaying error codes476151
Ref: error_codes displaying-error-codes476265
Ref: 279476265
Node: Silencing errors based on error codes476736
Ref: error_codes silence-error-codes476888
Ref: 53476888
Ref: error_codes silencing-errors-based-on-error-codes476888
Ref: 27b476888
Node: Enabling specific error codes477636
Ref: error_codes enabling-specific-error-codes477807
Ref: 27c477807
Node: Per-module enabling/disabling error codes478223
Ref: error_codes per-module-enabling-disabling-error-codes478348
Ref: 27d478348
Node: Error codes enabled by default479817
Ref: error_code_list doc479950
Ref: 27e479950
Ref: error_code_list error-code-list479950
Ref: 278479950
Ref: error_code_list error-codes-enabled-by-default479950
Ref: 27f479950
Node: Check that attribute exists [attr-defined]481947
Ref: error_code_list check-that-attribute-exists-attr-defined482122
Ref: 280482122
Node: Check that attribute exists in each union item [union-attr]483317
Ref: error_code_list check-that-attribute-exists-in-each-union-item-union-attr483542
Ref: 281483542
Node: Check that name is defined [name-defined]484580
Ref: error_code_list check-that-name-is-defined-name-defined484798
Ref: 282484798
Ref: Check that name is defined [name-defined]-Footnote-1485299
Node: Check arguments in calls [call-arg]485363
Ref: error_code_list check-arguments-in-calls-call-arg485553
Ref: 283485553
Node: Check argument types [arg-type]486012
Ref: error_code_list check-argument-types-arg-type486212
Ref: 284486212
Node: Check calls to overloaded functions [call-overload]486712
Ref: error_code_list check-calls-to-overloaded-functions-call-overload486913
Ref: 285486913
Node: Check validity of types [valid-type]487663
Ref: error_code_list check-validity-of-types-valid-type487895
Ref: 286487895
Ref: Check validity of types [valid-type]-Footnote-1488832
Node: Require annotation if variable type is unclear [var-annotated]488902
Ref: error_code_list require-annotation-if-variable-type-is-unclear-var-annotated489121
Ref: 287489121
Node: Check validity of overrides [override]490110
Ref: error_code_list check-validity-of-overrides-override490337
Ref: 288490337
Node: Check that function returns a value [return]491515
Ref: error_code_list check-that-function-returns-a-value-return491732
Ref: 289491732
Node: Check that return value is compatible [return-value]492454
Ref: error_code_list check-that-return-value-is-compatible-return-value492681
Ref: 28a492681
Node: Check types in assignment statement [assignment]493052
Ref: error_code_list check-types-in-assignment-statement-assignment493272
Ref: 28b493272
Node: Check type variable values [type-var]493788
Ref: error_code_list check-type-variable-values-type-var493998
Ref: 28c493998
Node: Check uses of various operators [operator]494458
Ref: error_code_list check-uses-of-various-operators-operator494653
Ref: 28d494653
Node: Check indexing operations [index]495044
Ref: error_code_list check-indexing-operations-index495230
Ref: 28e495230
Node: Check list items [list-item]495733
Ref: error_code_list check-list-items-list-item495905
Ref: 28f495905
Node: Check dict items [dict-item]496256
Ref: error_code_list check-dict-items-dict-item496433
Ref: 290496433
Node: Check TypedDict items [typeddict-item]496874
Ref: error_code_list check-typeddict-items-typeddict-item497068
Ref: 291497068
Node: Check that type of target is known [has-type]497783
Ref: error_code_list check-that-type-of-target-is-known-has-type497995
Ref: 292497995
Node: Check that import target can be found [import]499275
Ref: error_code_list check-that-import-target-can-be-found-import499496
Ref: 293499496
Node: Check that each name is defined once [no-redef]499894
Ref: error_code_list check-that-each-name-is-defined-once-no-redef500133
Ref: 294500133
Node: Check that called function returns a value [func-returns-value]501015
Ref: error_code_list check-that-called-function-returns-a-value-func-returns-value501258
Ref: 295501258
Node: Check instantiation of abstract classes [abstract]501871
Ref: error_code_list check-instantiation-of-abstract-classes-abstract502126
Ref: 296502126
Ref: Check instantiation of abstract classes [abstract]-Footnote-1503095
Node: Safe handling of abstract type object types [type-abstract]503157
Ref: error_code_list safe-handling-of-abstract-type-object-types-type-abstract503418
Ref: 297503418
Node: Check that call to an abstract method via super is valid [safe-super]504445
Ref: error_code_list check-that-call-to-an-abstract-method-via-super-is-valid-safe-super504699
Ref: 298504699
Node: Check the target of NewType [valid-newtype]505635
Ref: error_code_list check-the-target-of-newtype-valid-newtype505877
Ref: 299505877
Node: Check the return type of __exit__ [exit-return]506768
Ref: error_code_list check-the-return-type-of-exit-exit-return506985
Ref: 29a506985
Ref: Check the return type of __exit__ [exit-return]-Footnote-1508739
Ref: Check the return type of __exit__ [exit-return]-Footnote-2508815
Node: Check that naming is consistent [name-match]508891
Ref: error_code_list check-that-naming-is-consistent-name-match509138
Ref: 29b509138
Node: Check that overloaded functions have an implementation [no-overload-impl]509540
Ref: error_code_list check-that-overloaded-functions-have-an-implementation-no-overload-impl509800
Ref: 29c509800
Node: Check that coroutine return value is used [unused-coroutine]510338
Ref: error_code_list check-that-coroutine-return-value-is-used-unused-coroutine510594
Ref: 29d510594
Node: Check types in assert_type [assert-type]511159
Ref: error_code_list check-types-in-assert-type-assert-type511371
Ref: 29e511371
Node: Report syntax errors [syntax]511696
Ref: error_code_list report-syntax-errors-syntax511875
Ref: 29f511875
Node: Miscellaneous checks [misc]512157
Ref: error_code_list miscellaneous-checks-misc512287
Ref: 2a0512287
Node: Error codes for optional checks513036
Ref: error_code_list2 doc513177
Ref: 2a1513177
Ref: error_code_list2 error-codes-for-optional-checks513177
Ref: 2a2513177
Ref: error_code_list2 error-codes-optional513177
Ref: 2c513177
Node: Check that type arguments exist [type-arg]514622
Ref: error_code_list2 check-that-type-arguments-exist-type-arg514799
Ref: 2a3514799
Node: Check that every function has an annotation [no-untyped-def]515475
Ref: error_code_list2 check-that-every-function-has-an-annotation-no-untyped-def515710
Ref: 2a4515710
Node: Check that cast is not redundant [redundant-cast]516533
Ref: error_code_list2 check-that-cast-is-not-redundant-redundant-cast516785
Ref: 2a5516785
Node: Check that comparisons are overlapping [comparison-overlap]517255
Ref: error_code_list2 check-that-comparisons-are-overlapping-comparison-overlap517507
Ref: 2a6517507
Node: Check that no untyped functions are called [no-untyped-call]518462
Ref: error_code_list2 check-that-no-untyped-functions-are-called-no-untyped-call518726
Ref: 2a7518726
Node: Check that function does not return Any value [no-any-return]519205
Ref: error_code_list2 check-that-function-does-not-return-any-value-no-any-return519492
Ref: 2a8519492
Node: Check that types have no Any components due to missing imports [no-any-unimported]520054
Ref: error_code_list2 check-that-types-have-no-any-components-due-to-missing-imports-no-any-unimported520344
Ref: 2a9520344
Node: Check that statement or expression is unreachable [unreachable]521168
Ref: error_code_list2 check-that-statement-or-expression-is-unreachable-unreachable521448
Ref: 2aa521448
Node: Check that expression is redundant [redundant-expr]522143
Ref: error_code_list2 check-that-expression-is-redundant-redundant-expr522418
Ref: 2ab522418
Node: Check that expression is not implicitly true in boolean context [truthy-bool]523133
Ref: error_code_list2 check-that-expression-is-not-implicitly-true-in-boolean-context-truthy-bool523413
Ref: 2ac523413
Node: Check that # type ignore include an error code [ignore-without-code]525240
Ref: error_code_list2 check-that-type-ignore-include-an-error-code-ignore-without-code525529
Ref: 2ad525529
Ref: error_code_list2 ignore-without-code525529
Ref: 27a525529
Node: Check that awaitable return value is used [unused-awaitable]526540
Ref: error_code_list2 check-that-awaitable-return-value-is-used-unused-awaitable526743
Ref: 2ae526743
Node: Additional features527493
Ref: additional_features doc527630
Ref: 2af527630
Ref: additional_features additional-features527630
Ref: 2b0527630
Node: Dataclasses527908
Ref: additional_features dataclasses527999
Ref: 2b1527999
Ref: additional_features dataclasses-support527999
Ref: 2b2527999
Ref: Dataclasses-Footnote-1529570
Ref: Dataclasses-Footnote-2529649
Ref: Dataclasses-Footnote-3529731
Ref: Dataclasses-Footnote-4529804
Ref: Dataclasses-Footnote-5529863
Node: Caveats/Known Issues529905
Ref: additional_features caveats-known-issues529971
Ref: 2b3529971
Ref: Caveats/Known Issues-Footnote-1531181
Ref: Caveats/Known Issues-Footnote-2531260
Ref: Caveats/Known Issues-Footnote-3531340
Ref: Caveats/Known Issues-Footnote-4531419
Node: The attrs package531501
Ref: additional_features attrs-package531643
Ref: 2b4531643
Ref: additional_features the-attrs-package531643
Ref: 2b5531643
Ref: The attrs package-Footnote-1533011
Ref: The attrs package-Footnote-2533062
Node: Caveats/Known Issues<2>533119
Ref: additional_features id1533194
Ref: 2b6533194
Ref: Caveats/Known Issues<2>-Footnote-1534206
Ref: Caveats/Known Issues<2>-Footnote-2534282
Ref: Caveats/Known Issues<2>-Footnote-3534356
Node: Using a remote cache to speed up mypy runs534418
Ref: additional_features remote-cache534572
Ref: 2f534572
Ref: additional_features using-a-remote-cache-to-speed-up-mypy-runs534572
Ref: 2b7534572
Node: Shared repository for cache files536340
Ref: additional_features shared-repository-for-cache-files536487
Ref: 2b8536487
Node: Continuous Integration build537041
Ref: additional_features continuous-integration-build537216
Ref: 2b9537216
Node: Mypy wrapper script537956
Ref: additional_features mypy-wrapper-script538122
Ref: 2ba538122
Node: Caching with mypy daemon539058
Ref: additional_features caching-with-mypy-daemon539207
Ref: 2bb539207
Node: Refinements540146
Ref: additional_features refinements540267
Ref: 2bc540267
Node: Extended Callable types542301
Ref: additional_features extended-callable542429
Ref: 2bd542429
Ref: additional_features extended-callable-types542429
Ref: 2be542429
Ref: Extended Callable types-Footnote-1546284
Ref: Extended Callable types-Footnote-2546354
Ref: Extended Callable types-Footnote-3546424
Ref: Extended Callable types-Footnote-4546494
Ref: Extended Callable types-Footnote-5546564
Node: Frequently Asked Questions546634
Ref: faq doc546731
Ref: 2bf546731
Ref: faq frequently-asked-questions546731
Ref: 2c0546731
Node: Why have both dynamic and static typing?547315
Ref: faq why-have-both-dynamic-and-static-typing547469
Ref: 2c1547469
Ref: Why have both dynamic and static typing?-Footnote-1549137
Node: Would my project benefit from static typing?549170
Ref: faq would-my-project-benefit-from-static-typing549386
Ref: 2c2549386
Node: Can I use mypy to type check my existing Python code?550462
Ref: faq can-i-use-mypy-to-type-check-my-existing-python-code550685
Ref: 2c3550685
Node: Will static typing make my programs run faster?551112
Ref: faq will-static-typing-make-my-programs-run-faster551304
Ref: 2c4551304
Node: Is mypy free?551720
Ref: faq is-mypy-free551891
Ref: 2c5551891
Node: Can I use duck typing with mypy?552071
Ref: faq can-i-use-duck-typing-with-mypy552245
Ref: 2c6552245
Ref: Can I use duck typing with mypy?-Footnote-1553906
Ref: Can I use duck typing with mypy?-Footnote-2553967
Ref: Can I use duck typing with mypy?-Footnote-3554028
Ref: Can I use duck typing with mypy?-Footnote-4554098
Ref: Can I use duck typing with mypy?-Footnote-5554166
Ref: Can I use duck typing with mypy?-Footnote-6554234
Node: I like Python and I have no need for static typing554276
Ref: faq i-like-python-and-i-have-no-need-for-static-typing554488
Ref: 2c7554488
Node: How are mypy programs different from normal Python?554975
Ref: faq how-are-mypy-programs-different-from-normal-python555189
Ref: 2c8555189
Node: How is mypy different from Cython?556057
Ref: faq how-is-mypy-different-from-cython556241
Ref: 2c9556241
Ref: How is mypy different from Cython?-Footnote-1558141
Node: Does it run on PyPy?558193
Ref: faq does-it-run-on-pypy558360
Ref: 2ca558360
Ref: Does it run on PyPy?-Footnote-1558675
Node: Mypy is a cool project Can I help?558719
Ref: faq mypy-is-a-cool-project-can-i-help558843
Ref: 2cb558843
Ref: Mypy is a cool project Can I help?-Footnote-1559377
Node: Indices and tables559423
Ref: index indices-and-tables559510
Ref: 2cc559510
Node: Index559577

End Tag Table


Local Variables:
coding: utf-8
End:
